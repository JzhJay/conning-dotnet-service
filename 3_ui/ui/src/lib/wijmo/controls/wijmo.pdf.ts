/*!
    *
    * Wijmo Library 5.20212.812
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the GrapeCity Commercial License.
    * sales@wijmo.com
    * wijmo.com/products/wijmo-5/license/
    *
    */

declare var PDFDocument: {
    prototype: _IPdfKitDocument;
    new(options?: _IPdfKitDocumentOptions): _IPdfKitDocument;
}

interface _IPdfKitDocument {
    x: number;
    y: number;
    _ctm: number[];
    compress: boolean;
    info: _IPdfKitDocumentInfo;
    options: _IPdfKitDocumentOptions;
    page: _IPdfKitPage;
    version: 1.3 | 1.4 | 1.5 | 1.6 | 1.7;

    addPage(options?: _IPdfKitPageOptions): _IPdfKitDocument;
    bufferedPageRange(): { start: number; count: number; };
    flushPages(): void;
    switchToPage(pageNumber: number): _IPdfKitPage;
    end(): boolean;

    lineGap(value: number): _IPdfKitDocument;
    currentLineGap(): number; // GrapeCity
    currentLineHeight(includeGap?: boolean): number;
    widthOfString(value: string, options?: _IPdfKitWidthOfStringOptions): number;
    heightOfString(value: string, options?: _IPdfKitMeasurementTextOptions): number;
    moveDown(lines: number): _IPdfKitDocument;
    moveUp(lines: number): _IPdfKitDocument;
    text(text: string, options?: _IPdfKitTextOptions): _IPdfKitDocument;
    text(text: string, x?: number, y?: number, options?: _IPdfKitTextOptions): _IPdfKitDocument;
    textAndMeasure(text: string, x: number, y: number, options: _IPdfKitMeasurementTextOptions, measureOnly?: boolean): _IPdfKitTextSize; // GrapeCity

    currentFontAscender(): number; // GrapeCity
    currentFontBBox(): _IPdfKitFontBBox; // GrapeCity
    currentFontSize(): number; // GrapeCity
    font(name: string, size?: number): _IPdfKitDocument;
    font(src: ArrayBuffer, size?: number): _IPdfKitDocument;
    font(src: ArrayBuffer, fontFamily: string, size?: number): _IPdfKitDocument;
    fontSize(size: number): _IPdfKitDocument;
    registerFont(name: string, standardFontName: string): _IPdfKitDocument;
    registerFont(name: string, src: ArrayBuffer, fontFamily?: string): _IPdfKitDocument;

    image(URI: string | _IPdfKitImage, options?: _IPdfKitImageOptions): _IPdfKitDocument;
    image(URI: string | _IPdfKitImage, x?: number, y?: number, options?: _IPdfKitImageOptions): _IPdfKitDocument;
    openImage(URI: string): _IPdfKitImage;

    on(eventName: string, handler: Function): _IPdfKitDocument;
    on(eventName: 'data', handler: (chunk: any) => {}): _IPdfKitDocument;
    removeAllListeners(type: string): _IPdfKitDocument;
    removeListener(type: string, listener: Function): _IPdfKitDocument;

    fill(colorOrRule: string): _IPdfKitDocument;
    fill(color: string, rule?: string): _IPdfKitDocument;
    fill(color: number[], rule?: string): _IPdfKitDocument;
    fill(color: _IPdfKitGradient, rule?: string): _IPdfKitDocument;

    fillAndStroke(rule?: string): _IPdfKitDocument;
    fillAndStroke(fillColor: string, strokeColor: string, rule?: string): _IPdfKitDocument;
    fillAndStroke(fillColor: number[], strokeColor: number[], rule?: string): _IPdfKitDocument;
    fillAndStroke(fillColor: _IPdfKitGradient, strokeColor: _IPdfKitGradient, rule?: string): _IPdfKitDocument;

    fillColor(color: string, opacity?: number): _IPdfKitDocument;
    fillColor(color: number[], opacity?: number): _IPdfKitDocument;
    fillColor(color: _IPdfKitGradient, opacity?: number): _IPdfKitDocument;
    strokeColor(color: string, opacity?: number): _IPdfKitDocument;
    strokeColor(color: number[], opacity?: number): _IPdfKitDocument;
    strokeColor(color: _IPdfKitGradient, opacity?: number): _IPdfKitDocument;

    fillOpacity(opacity: number): _IPdfKitDocument;
    strokeOpacity(opacity: number): _IPdfKitDocument;
    opacity(opacity: number): _IPdfKitDocument;

    linearGradient(x1: number, y1: number, x2: number, y2: number): _IPdfKitGradient;
    radialGradient(x1: number, y1: number, r1: number, x2: number, y2: number, r2: number): _IPdfKitGradient;

    closePath(): _IPdfKitDocument;
    clip(rule?: string): _IPdfKitDocument;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): _IPdfKitDocument;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): _IPdfKitDocument;
    circle(x: number, y: number, radius: number): _IPdfKitDocument;
    ellipse(x: number, y: number, r1: number, r2?: number): _IPdfKitDocument;
    lineTo(x: number, y: number): _IPdfKitDocument;
    lineWidth(width: number): _IPdfKitDocument;
    moveTo(x: number, y: number): _IPdfKitDocument;
    path(path: string): _IPdfKitDocument;
    rect(x: number, y: number, w: number, h: number): _IPdfKitDocument;
    roundedRect(x: number, y: number, w: number, h: number, r?: number): _IPdfKitDocument;
    polygon(...points: number[][]): _IPdfKitDocument;
    lineCap(value: any /*string | number */): _IPdfKitDocument;
    lineJoin(value: any /*string | number */): _IPdfKitDocument;
    miterLimit(value: number): _IPdfKitDocument;
    dash(length: number, options?: _IPdfKitDashOptions): _IPdfKitDocument;
    undash(): _IPdfKitDocument;

    stroke(color?: string): _IPdfKitDocument;
    stroke(color?: number[]): _IPdfKitDocument;
    stroke(color?: _IPdfKitGradient): _IPdfKitDocument;

    scale(xFactor: number, yFactor: number, options?: _IPdfKitOrigin): _IPdfKitDocument;
    scale(factor: number): _IPdfKitDocument;
    translate(x: number, y: number): _IPdfKitDocument;
    transform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): _IPdfKitDocument;
    rotate(angle: number, options?: _IPdfKitOrigin): _IPdfKitDocument;

    restore(): _IPdfKitDocument;
    save(): _IPdfKitDocument;
}

interface _IPdfKitPageOptions {
    layout?: string;
    margin?: number;
    margins?: _IPdfKitPageMargins;
    size?: any;  // string (named size) or number[2] (custom size)
}

interface _IPdfKitPage {
    document: _IPdfKitDocument;
    width: number;
    height: number;
    margins: _IPdfKitPageMargins;
    size: any; // string (named size) or number[2] (custom size)
    layout: string;

    // GrapeCity
    originalMargins: _IPdfKitPageMargins;
}

interface _IPdfKitDocumentOptions extends _IPdfKitPageOptions {
    autoFirstPage?: boolean; // default 'true'
    bufferPages?: boolean;
    compress?: boolean;
    info?: _IPdfKitDocumentInfo;
    pdfVersion?: _PdfKitVersion; // default '1.3'

    // GrapeCity, a reference to the PDFSecurity class.
    security?: {
        new(document: typeof PDFDocument, options: _IPdfKitDocumentOptions);
    },

    userPassword?: string;
    ownerPassword?: string;
    permissions?: {
        printing?: _PdfKitPrintPermission;
        modifying?: boolean;
        copying?: boolean;
        annotating?: boolean;
        fillingForms?: boolean;
        contentAccessibility?: boolean;
        documentAssembly?: boolean;
    }

    // GrapeCity
    pageAdding?: (document: _IPdfKitDocument, options: _IPdfKitPageOptions) => void;
    pageAdded?: (document: _IPdfKitDocument, pageIndex: number) => void;
}

interface _IPdfKitDocumentInfo {
    Author?: string;
    CreationDate?: Date;
    Keywords?: string;
    ModDate?: Date;
    Subject?: string;
    Title?: string;
}

interface _IPdfKitPageMargins {
    bottom: number;
    left: number;
    right: number;
    top: number;
}

interface _IPdfKitTextOptions {
    align?: string; // "left", "center", "right", "justify".
    lineBreak?: boolean; // set to false to disable line wrapping all together
    width?: number; // the width that text should be wrapped to (by default, the page width minus the left and right margin)
    height?: number; // the maximum height that text should be clipped to
    ellipsis?: any; // the character to display at the end of the text when it is too long. Set to true to use the default character.
    columns?: number; // the number of columns to flow the text into
    columnGap?: number; // the amount of space between each column(1 / 4 inch by default)
    indent?: number; // the amount in PDF points(72 per inch) to indent each paragraph of text
    paragraphGap?: number; // the amount of space between each paragraph of text
    lineGap?: number; // the amount of space between each line of text
    wordSpacing?: number; // the amount of space between each word in the text
    characterSpacing?: number; // the amount of space between each character in the text
    fill?: boolean; // whether to fill the text(true by default)
    stroke?: boolean; // whether to stroke the text
    link?: string; // a URL to link this text to(shortcut to create an annotation)
    underline?: boolean; // whether to underline the text
    strike?: boolean; // whether to strike out the text
    continued?: boolean; // whether the text segment will be followed immediately by another segment.Useful for changing styling in the middle of a paragraph.
}

interface _IPdfKitDashOptions {
    phase?: number;
    space?: number;
}

interface _IPdfKitMeasurementTextOptions extends _IPdfKitTextOptions {
    // GrapeCity
    includeLastLineExternalLeading?: boolean; // default: true
}

interface _IPdfKitWidthOfStringOptions {
    characterSpacing?: number;
}

interface _IPdfKitImage {
    width: number;
    height: number;
}

// Neither width or height provided - image is rendered at full size
// width provided but not height - image is scaled proportionally to fit in the provided width
// height provided but not width - image is scaled proportionally to fit in the provided height
// Both width and height provided - image is stretched to the dimensions provided
// scale factor provided - image is scaled proportionally by the provided scale factor
// fit array provided - image is scaled proportionally to fit within the passed width and height
interface _IPdfKitImageOptions {
    width?: number;
    height?: number;
    scale?: number;
    fit?: number[];
    align?: string; // 'left' (default) | 'center' | 'right'
    valign?: string; // 'top' (default) | 'center' | 'bottom'
}

interface _IPdfKitGradient {
    stop(pos: number, color, opacity?: number): _IPdfKitGradient;
}

interface _IPdfKitOrigin {
    origin?: number[];
}

// GrapeCity
interface _IPdfKitTextSize {
    width?: number;
    height?: number;
    charCount?: number;
}

// GrapeCity
interface _IPdfKitFontBBox {
    llx: number,
    lly: number,
    urx: number,
    ury: number
}

type _PdfKitPrintPermission = 'lowResolution' | 'highResolution';
type _PdfKitVersion = '1.3' | '1.4' | '1.5' | '1.6' | '1.7' | '1.7ext3';


    module wijmo.pdf {
    export declare var __c1pdfkitIsModule;

declare var localExports;
declare var localModule;
declare var localDefine;
declare var global;
declare var localRequire;
declare var Symbol;
(function (f) {
  if (typeof localExports === "object" && typeof localModule !== "undefined") {
    localModule.localExports = f();

  } else if (typeof localDefine === "function" && localDefine.amd) {
    localDefine([], f);
  } else {
    var g;

    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }

    g.PDFDocument = f();
  }
})(function () {
  return function () {
    function r(e, n, t) {
      function o(i, f?) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof localRequire && localRequire;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a: any = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }

          var p = n[i] = {
            localExports: {}
          };
          e[i][0].call(p.localExports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.localExports, r, e, n, t);
        }

        return n[i].localExports;
      }

      for (var u = "function" == typeof localRequire && localRequire, i = 0; i < t.length; i++) {
        o(t[i]);
      }

      return o;
    }

    return r;
  }()({
    1: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {

          var r = localRequire('restructure');

          var _Object$getOwnPropertyDescriptor = localRequire('@babel/runtime-corejs2/core-js/object/get-own-property-descriptor');

          var _Object$freeze = localRequire('@babel/runtime-corejs2/core-js/object/freeze');

          var _Object$keys = localRequire('@babel/runtime-corejs2/core-js/object/keys');

          var _Object$defineProperty = localRequire('@babel/runtime-corejs2/core-js/object/define-property');

          var _Map = localRequire('@babel/runtime-corejs2/core-js/map');

          var _Array$isArray = localRequire('@babel/runtime-corejs2/core-js/array/is-array');

          var _String$fromCodePoint = localRequire('@babel/runtime-corejs2/core-js/string/from-code-point');

          var _Array$from = localRequire('@babel/runtime-corejs2/core-js/array/from');

          var _Set = localRequire('@babel/runtime-corejs2/core-js/set');

          var unicode = localRequire('unicode-properties');
          var cloneDeep = localRequire('clone');

          var _Promise = localRequire('@babel/runtime-corejs2/core-js/promise');

          var fontkit: any = {};
          fontkit.logErrors = false;
          var formats = [];

          fontkit.registerFormat = function (format) {
            formats.push(format);
          };

          fontkit.create = function (buffer, postscriptName) {
            for (var i = 0; i < formats.length; i++) {
              var format = formats[i];

              if (format.probe(buffer)) {
                var font = new format(new r.DecodeStream(buffer));

                if (postscriptName) {
                  return font.getFont(postscriptName);
                }

                return font;
              }
            }

            throw new Error('Unknown font format');
          };

          fontkit.defaultLanguage = 'en';

          fontkit.setDefaultLanguage = function (lang) {
            if (lang === void 0) {
              lang = 'en';
            }

            fontkit.defaultLanguage = lang;
          };

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps?) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          function _unsupportedIterableToArray(o, minLen?) {
            if (!o) return;
            if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === 'Object' && o.constructor) n = o.constructor.name;
            if (n === 'Map' || n === 'Set') return (<any>Array).from(o);
            if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }

          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;

            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }

            return arr2;
          }

          function _createForOfIteratorHelperLoose(o, allowArrayLike?) {
            var it;

            if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
              if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === 'number') {
                if (it) o = it;
                var i = 0;
                return function () {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                };
              }

              throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
            }

            it = o[Symbol.iterator]();
            return it.next.bind(it);
          }

          function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
            var desc: any = {};
            Object.keys(descriptor).forEach(function (key) {
              desc[key] = descriptor[key];
            });
            desc.enumerable = !!desc.enumerable;
            desc.configurable = !!desc.configurable;

            if ('value' in desc || desc.initializer) {
              desc.writable = true;
            }

            desc = decorators.slice().reverse().reduce(function (desc, decorator) {
              return decorator(target, property, desc) || desc;
            }, desc);

            if (context && desc.initializer !== void 0) {
              desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
              desc.initializer = undefined;
            }

            if (desc.initializer === void 0) {
              Object.defineProperty(target, property, desc);
              desc = null;
            }

            return desc;
          }

          function cache(target, key, descriptor) {
            if (descriptor.get) {
              var get = descriptor.get;

              descriptor.get = function () {
                var value = get.call(this);

                _Object$defineProperty(this, key, {
                  value: value
                });

                return value;
              };
            } else if (typeof descriptor.value === 'function') {
              var fn = descriptor.value;
              return {
                get: function get() {
                  var cache = new _Map();

                  function memoized() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }

                    var key = args.length > 0 ? args[0] : 'value';

                    if (cache.has(key)) {
                      return cache.get(key);
                    }

                    var result = fn.apply(this, args);
                    cache.set(key, result);
                    return result;
                  }

                  _Object$defineProperty(this, key, {
                    value: memoized
                  });

                  return memoized;
                }
              };
            }
          }

          var SubHeader = new r.Struct({
            firstCode: r.uint16,
            entryCount: r.uint16,
            idDelta: r.int16,
            idRangeOffset: r.uint16
          });
          var CmapGroup = new r.Struct({
            startCharCode: r.uint32,
            endCharCode: r.uint32,
            glyphID: r.uint32
          });
          var UnicodeValueRange = new r.Struct({
            startUnicodeValue: r.uint24,
            additionalCount: r.uint8
          });
          var UVSMapping = new r.Struct({
            unicodeValue: r.uint24,
            glyphID: r.uint16
          });
          var DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);
          var NonDefaultUVS = new r.Array(UVSMapping, r.uint32);
          var VarSelectorRecord = new r.Struct({
            varSelector: r.uint24,
            defaultUVS: new r.Pointer(r.uint32, DefaultUVS, {
              type: 'parent'
            }),
            nonDefaultUVS: new r.Pointer(r.uint32, NonDefaultUVS, {
              type: 'parent'
            })
          });
          var CmapSubtable = new r.VersionedStruct(r.uint16, {
            0: {
              length: r.uint16,
              language: r.uint16,
              codeMap: new r.LazyArray(r.uint8, 256)
            },
            2: {
              length: r.uint16,
              language: r.uint16,
              subHeaderKeys: new r.Array(r.uint16, 256),
              subHeaderCount: function subHeaderCount(t) {
                return Math.max.apply(Math, t.subHeaderKeys);
              },
              subHeaders: new r.LazyArray(SubHeader, 'subHeaderCount'),
              glyphIndexArray: new r.LazyArray(r.uint16, 'subHeaderCount')
            },
            4: {
              length: r.uint16,
              language: r.uint16,
              segCountX2: r.uint16,
              segCount: function segCount(t) {
                return t.segCountX2 >> 1;
              },
              searchRange: r.uint16,
              entrySelector: r.uint16,
              rangeShift: r.uint16,
              endCode: new r.LazyArray(r.uint16, 'segCount'),
              reservedPad: new r.Reserved(r.uint16),
              startCode: new r.LazyArray(r.uint16, 'segCount'),
              idDelta: new r.LazyArray(r.int16, 'segCount'),
              idRangeOffset: new r.LazyArray(r.uint16, 'segCount'),
              glyphIndexArray: new r.LazyArray(r.uint16, function (t) {
                return (t.length - t._currentOffset) / 2;
              })
            },
            6: {
              length: r.uint16,
              language: r.uint16,
              firstCode: r.uint16,
              entryCount: r.uint16,
              glyphIndices: new r.LazyArray(r.uint16, 'entryCount')
            },
            8: {
              reserved: new r.Reserved(r.uint16),
              length: r.uint32,
              language: r.uint16,
              is32: new r.LazyArray(r.uint8, 8192),
              nGroups: r.uint32,
              groups: new r.LazyArray(CmapGroup, 'nGroups')
            },
            10: {
              reserved: new r.Reserved(r.uint16),
              length: r.uint32,
              language: r.uint32,
              firstCode: r.uint32,
              entryCount: r.uint32,
              glyphIndices: new r.LazyArray(r.uint16, 'numChars')
            },
            12: {
              reserved: new r.Reserved(r.uint16),
              length: r.uint32,
              language: r.uint32,
              nGroups: r.uint32,
              groups: new r.LazyArray(CmapGroup, 'nGroups')
            },
            13: {
              reserved: new r.Reserved(r.uint16),
              length: r.uint32,
              language: r.uint32,
              nGroups: r.uint32,
              groups: new r.LazyArray(CmapGroup, 'nGroups')
            },
            14: {
              length: r.uint32,
              numRecords: r.uint32,
              varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')
            }
          });
          var CmapEntry = new r.Struct({
            platformID: r.uint16,
            encodingID: r.uint16,
            table: new r.Pointer(r.uint32, CmapSubtable, {
              type: 'parent',
              lazy: true
            })
          });
          var cmap = new r.Struct({
            version: r.uint16,
            numSubtables: r.uint16,
            tables: new r.Array(CmapEntry, 'numSubtables')
          });
          var head = new r.Struct({
            version: r.int32,
            revision: r.int32,
            checkSumAdjustment: r.uint32,
            magicNumber: r.uint32,
            flags: r.uint16,
            unitsPerEm: r.uint16,
            created: new r.Array(r.int32, 2),
            modified: new r.Array(r.int32, 2),
            xMin: r.int16,
            yMin: r.int16,
            xMax: r.int16,
            yMax: r.int16,
            macStyle: new r.Bitfield(r.uint16, ['bold', 'italic', 'underline', 'outline', 'shadow', 'condensed', 'extended']),
            lowestRecPPEM: r.uint16,
            fontDirectionHint: r.int16,
            indexToLocFormat: r.int16,
            glyphDataFormat: r.int16
          });
          var hhea = new r.Struct({
            version: r.int32,
            ascent: r.int16,
            descent: r.int16,
            lineGap: r.int16,
            advanceWidthMax: r.uint16,
            minLeftSideBearing: r.int16,
            minRightSideBearing: r.int16,
            xMaxExtent: r.int16,
            caretSlopeRise: r.int16,
            caretSlopeRun: r.int16,
            caretOffset: r.int16,
            reserved: new r.Reserved(r.int16, 4),
            metricDataFormat: r.int16,
            numberOfMetrics: r.uint16
          });
          var HmtxEntry = new r.Struct({
            advance: r.uint16,
            bearing: r.int16
          });
          var hmtx = new r.Struct({
            metrics: new r.LazyArray(HmtxEntry, function (t) {
              return t.parent.hhea.numberOfMetrics;
            }),
            bearings: new r.LazyArray(r.int16, function (t) {
              return t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics;
            })
          });
          var maxp = new r.Struct({
            version: r.int32,
            numGlyphs: r.uint16,
            maxPoints: r.uint16,
            maxContours: r.uint16,
            maxComponentPoints: r.uint16,
            maxComponentContours: r.uint16,
            maxZones: r.uint16,
            maxTwilightPoints: r.uint16,
            maxStorage: r.uint16,
            maxFunctionDefs: r.uint16,
            maxInstructionDefs: r.uint16,
            maxStackElements: r.uint16,
            maxSizeOfInstructions: r.uint16,
            maxComponentElements: r.uint16,
            maxComponentDepth: r.uint16
          });

          function getEncoding(platformID, encodingID, languageID) {
            if (languageID === void 0) {
              languageID = 0;
            }

            if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {
              return MAC_LANGUAGE_ENCODINGS[languageID];
            }

            return ENCODINGS[platformID][encodingID];
          }

          var ENCODINGS = [['utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be'], ['macroman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8', 'macgreek', 'maccyrillic', 'symbol', 'Devanagari', 'Gurmukhi', 'Gujarati', 'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese', 'Burmese', 'Khmer', 'macthai', 'Laotian', 'Georgian', 'Armenian', 'gb-2312-80', 'Tibetan', 'Mongolian', 'Geez', 'maccenteuro', 'Vietnamese', 'Sindhi'], ['ascii'], ['symbol', 'utf16be', 'shift-jis', 'gb18030', 'big5', 'wansung', 'johab', null, null, null, 'utf16be']];
          var MAC_LANGUAGE_ENCODINGS = {
            15: 'maciceland',
            17: 'macturkish',
            18: 'maccroatian',
            24: 'maccenteuro',
            25: 'maccenteuro',
            26: 'maccenteuro',
            27: 'maccenteuro',
            28: 'maccenteuro',
            30: 'maciceland',
            37: 'macromania',
            38: 'maccenteuro',
            39: 'maccenteuro',
            40: 'maccenteuro',
            143: 'macinuit',
            146: 'macgaelic'
          };
          var LANGUAGES = [[], {
            0: 'en',
            30: 'fo',
            60: 'ks',
            90: 'rw',
            1: 'fr',
            31: 'fa',
            61: 'ku',
            91: 'rn',
            2: 'de',
            32: 'ru',
            62: 'sd',
            92: 'ny',
            3: 'it',
            33: 'zh',
            63: 'bo',
            93: 'mg',
            4: 'nl',
            34: 'nl-BE',
            64: 'ne',
            94: 'eo',
            5: 'sv',
            35: 'ga',
            65: 'sa',
            128: 'cy',
            6: 'es',
            36: 'sq',
            66: 'mr',
            129: 'eu',
            7: 'da',
            37: 'ro',
            67: 'bn',
            130: 'ca',
            8: 'pt',
            38: 'cz',
            68: 'as',
            131: 'la',
            9: 'no',
            39: 'sk',
            69: 'gu',
            132: 'qu',
            10: 'he',
            40: 'si',
            70: 'pa',
            133: 'gn',
            11: 'ja',
            41: 'yi',
            71: 'or',
            134: 'ay',
            12: 'ar',
            42: 'sr',
            72: 'ml',
            135: 'tt',
            13: 'fi',
            43: 'mk',
            73: 'kn',
            136: 'ug',
            14: 'el',
            44: 'bg',
            74: 'ta',
            137: 'dz',
            15: 'is',
            45: 'uk',
            75: 'te',
            138: 'jv',
            16: 'mt',
            46: 'be',
            76: 'si',
            139: 'su',
            17: 'tr',
            47: 'uz',
            77: 'my',
            140: 'gl',
            18: 'hr',
            48: 'kk',
            78: 'km',
            141: 'af',
            19: 'zh-Hant',
            49: 'az-Cyrl',
            79: 'lo',
            142: 'br',
            20: 'ur',
            50: 'az-Arab',
            80: 'vi',
            143: 'iu',
            21: 'hi',
            51: 'hy',
            81: 'id',
            144: 'gd',
            22: 'th',
            52: 'ka',
            82: 'tl',
            145: 'gv',
            23: 'ko',
            53: 'mo',
            83: 'ms',
            146: 'ga',
            24: 'lt',
            54: 'ky',
            84: 'ms-Arab',
            147: 'to',
            25: 'pl',
            55: 'tg',
            85: 'am',
            148: 'el-polyton',
            26: 'hu',
            56: 'tk',
            86: 'ti',
            149: 'kl',
            27: 'es',
            57: 'mn-CN',
            87: 'om',
            150: 'az',
            28: 'lv',
            58: 'mn',
            88: 'so',
            151: 'nn',
            29: 'se',
            59: 'ps',
            89: 'sw'
          }, [], {
            1078: 'af',
            16393: 'en-IN',
            1159: 'rw',
            1074: 'tn',
            1052: 'sq',
            6153: 'en-IE',
            1089: 'sw',
            1115: 'si',
            1156: 'gsw',
            8201: 'en-JM',
            1111: 'kok',
            1051: 'sk',
            1118: 'am',
            17417: 'en-MY',
            1042: 'ko',
            1060: 'sl',
            5121: 'ar-DZ',
            5129: 'en-NZ',
            1088: 'ky',
            11274: 'es-AR',
            15361: 'ar-BH',
            13321: 'en-PH',
            1108: 'lo',
            16394: 'es-BO',
            3073: 'ar',
            18441: 'en-SG',
            1062: 'lv',
            13322: 'es-CL',
            2049: 'ar-IQ',
            7177: 'en-ZA',
            1063: 'lt',
            9226: 'es-CO',
            11265: 'ar-JO',
            11273: 'en-TT',
            2094: 'dsb',
            5130: 'es-CR',
            13313: 'ar-KW',
            2057: 'en-GB',
            1134: 'lb',
            7178: 'es-DO',
            12289: 'ar-LB',
            1033: 'en',
            1071: 'mk',
            12298: 'es-EC',
            4097: 'ar-LY',
            12297: 'en-ZW',
            2110: 'ms-BN',
            17418: 'es-SV',
            6145: 'ary',
            1061: 'et',
            1086: 'ms',
            4106: 'es-GT',
            8193: 'ar-OM',
            1080: 'fo',
            1100: 'ml',
            18442: 'es-HN',
            16385: 'ar-QA',
            1124: 'fil',
            1082: 'mt',
            2058: 'es-MX',
            1025: 'ar-SA',
            1035: 'fi',
            1153: 'mi',
            19466: 'es-NI',
            10241: 'ar-SY',
            2060: 'fr-BE',
            1146: 'arn',
            6154: 'es-PA',
            7169: 'aeb',
            3084: 'fr-CA',
            1102: 'mr',
            15370: 'es-PY',
            14337: 'ar-AE',
            1036: 'fr',
            1148: 'moh',
            10250: 'es-PE',
            9217: 'ar-YE',
            5132: 'fr-LU',
            1104: 'mn',
            20490: 'es-PR',
            1067: 'hy',
            6156: 'fr-MC',
            2128: 'mn-CN',
            3082: 'es',
            1101: 'as',
            4108: 'fr-CH',
            1121: 'ne',
            1034: 'es',
            2092: 'az-Cyrl',
            1122: 'fy',
            1044: 'nb',
            21514: 'es-US',
            1068: 'az',
            1110: 'gl',
            2068: 'nn',
            14346: 'es-UY',
            1133: 'ba',
            1079: 'ka',
            1154: 'oc',
            8202: 'es-VE',
            1069: 'eu',
            3079: 'de-AT',
            1096: 'or',
            2077: 'sv-FI',
            1059: 'be',
            1031: 'de',
            1123: 'ps',
            1053: 'sv',
            2117: 'bn',
            5127: 'de-LI',
            1045: 'pl',
            1114: 'syr',
            1093: 'bn-IN',
            4103: 'de-LU',
            1046: 'pt',
            1064: 'tg',
            8218: 'bs-Cyrl',
            2055: 'de-CH',
            2070: 'pt-PT',
            2143: 'tzm',
            5146: 'bs',
            1032: 'el',
            1094: 'pa',
            1097: 'ta',
            1150: 'br',
            1135: 'kl',
            1131: 'qu-BO',
            1092: 'tt',
            1026: 'bg',
            1095: 'gu',
            2155: 'qu-EC',
            1098: 'te',
            1027: 'ca',
            1128: 'ha',
            3179: 'qu',
            1054: 'th',
            3076: 'zh-HK',
            1037: 'he',
            1048: 'ro',
            1105: 'bo',
            5124: 'zh-MO',
            1081: 'hi',
            1047: 'rm',
            1055: 'tr',
            2052: 'zh',
            1038: 'hu',
            1049: 'ru',
            1090: 'tk',
            4100: 'zh-SG',
            1039: 'is',
            9275: 'smn',
            1152: 'ug',
            1028: 'zh-TW',
            1136: 'ig',
            4155: 'smj-NO',
            1058: 'uk',
            1155: 'co',
            1057: 'id',
            5179: 'smj',
            1070: 'hsb',
            1050: 'hr',
            1117: 'iu',
            3131: 'se-FI',
            1056: 'ur',
            4122: 'hr-BA',
            2141: 'iu-Latn',
            1083: 'se',
            2115: 'uz-Cyrl',
            1029: 'cs',
            2108: 'ga',
            2107: 'se-SE',
            1091: 'uz',
            1030: 'da',
            1076: 'xh',
            8251: 'sms',
            1066: 'vi',
            1164: 'prs',
            1077: 'zu',
            6203: 'sma-NO',
            1106: 'cy',
            1125: 'dv',
            1040: 'it',
            7227: 'sms',
            1160: 'wo',
            2067: 'nl-BE',
            2064: 'it-CH',
            1103: 'sa',
            1157: 'sah',
            1043: 'nl',
            1041: 'ja',
            7194: 'sr-Cyrl-BA',
            1144: 'ii',
            3081: 'en-AU',
            1099: 'kn',
            3098: 'sr',
            1130: 'yo',
            10249: 'en-BZ',
            1087: 'kk',
            6170: 'sr-Latn-BA',
            4105: 'en-CA',
            1107: 'km',
            2074: 'sr-Latn',
            9225: 'en-029',
            1158: 'quc',
            1132: 'nso'
          }];
          var NameRecord = new r.Struct({
            platformID: r.uint16,
            encodingID: r.uint16,
            languageID: r.uint16,
            nameID: r.uint16,
            length: r.uint16,
            string: new r.Pointer(r.uint16, new r.String('length', function (t) {
              return getEncoding(t.platformID, t.encodingID, t.languageID);
            }), {
              type: 'parent',
              relativeTo: function relativeTo(ctx) {
                return ctx.parent.stringOffset;
              },
              allowNull: false
            })
          });
          var LangTagRecord = new r.Struct({
            length: r.uint16,
            tag: new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {
              type: 'parent',
              relativeTo: function relativeTo(ctx) {
                return ctx.stringOffset;
              }
            })
          });
          var NameTable = new r.VersionedStruct(r.uint16, {
            0: {
              count: r.uint16,
              stringOffset: r.uint16,
              records: new r.Array(NameRecord, 'count')
            },
            1: {
              count: r.uint16,
              stringOffset: r.uint16,
              records: new r.Array(NameRecord, 'count'),
              langTagCount: r.uint16,
              langTags: new r.Array(LangTagRecord, 'langTagCount')
            }
          });
          var NAMES = ['copyright', 'fontFamily', 'fontSubfamily', 'uniqueSubfamily', 'fullName', 'version', 'postscriptName', 'trademark', 'manufacturer', 'designer', 'description', 'vendorURL', 'designerURL', 'license', 'licenseURL', null, 'preferredFamily', 'preferredSubfamily', 'compatibleFull', 'sampleText', 'postscriptCIDFontName', 'wwsFamilyName', 'wwsSubfamilyName'];

          NameTable.process = function (stream) {
            var records = {};

            for (var _iterator = _createForOfIteratorHelperLoose(this.records), _step; !(_step = _iterator()).done;) {
              var record = _step.value;
              var language = LANGUAGES[record.platformID][record.languageID];

              if (language == null && this.langTags != null && record.languageID >= 32768) {
                language = this.langTags[record.languageID - 32768].tag;
              }

              if (language == null) {
                language = record.platformID + '-' + record.languageID;
              }

              var key = record.nameID >= 256 ? 'fontFeatures' : NAMES[record.nameID] || record.nameID;

              if (records[key] == null) {
                records[key] = {};
              }

              var obj = records[key];

              if (record.nameID >= 256) {
                obj = obj[record.nameID] || (obj[record.nameID] = {});
              }

              if (typeof record.string === 'string' || typeof obj[language] !== 'string') {
                obj[language] = record.string;
              }
            }

            this.records = records;
          };

          NameTable.preEncode = function () {
            if (_Array$isArray(this.records)) return;
            this.version = 0;
            var records = [];

            for (var key in this.records) {
              var val = this.records[key];
              if (key === 'fontFeatures') continue;
              records.push({
                platformID: 3,
                encodingID: 1,
                languageID: 1033,
                nameID: NAMES.indexOf(key),
                length: Buffer.byteLength(val.en, 'utf16le'),
                string: val.en
              });

              if (key === 'postscriptName') {
                records.push({
                  platformID: 1,
                  encodingID: 0,
                  languageID: 0,
                  nameID: NAMES.indexOf(key),
                  length: val.en.length,
                  string: val.en
                });
              }
            }

            this.records = records;
            this.count = records.length;
            this.stringOffset = NameTable.size(this, null, false);
          };

          var OS2 = new r.VersionedStruct(r.uint16, {
            header: {
              xAvgCharWidth: r.int16,
              usWeightClass: r.uint16,
              usWidthClass: r.uint16,
              fsType: new r.Bitfield(r.uint16, [null, 'noEmbedding', 'viewOnly', 'editable', null, null, null, null, 'noSubsetting', 'bitmapOnly']),
              ySubscriptXSize: r.int16,
              ySubscriptYSize: r.int16,
              ySubscriptXOffset: r.int16,
              ySubscriptYOffset: r.int16,
              ySuperscriptXSize: r.int16,
              ySuperscriptYSize: r.int16,
              ySuperscriptXOffset: r.int16,
              ySuperscriptYOffset: r.int16,
              yStrikeoutSize: r.int16,
              yStrikeoutPosition: r.int16,
              sFamilyClass: r.int16,
              panose: new r.Array(r.uint8, 10),
              ulCharRange: new r.Array(r.uint32, 4),
              vendorID: new r.String(4),
              fsSelection: new r.Bitfield(r.uint16, ['italic', 'underscore', 'negative', 'outlined', 'strikeout', 'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique']),
              usFirstCharIndex: r.uint16,
              usLastCharIndex: r.uint16
            },
            0: {},
            1: {
              typoAscender: r.int16,
              typoDescender: r.int16,
              typoLineGap: r.int16,
              winAscent: r.uint16,
              winDescent: r.uint16,
              codePageRange: new r.Array(r.uint32, 2)
            },
            2: {
              typoAscender: r.int16,
              typoDescender: r.int16,
              typoLineGap: r.int16,
              winAscent: r.uint16,
              winDescent: r.uint16,
              codePageRange: new r.Array(r.uint32, 2),
              xHeight: r.int16,
              capHeight: r.int16,
              defaultChar: r.uint16,
              breakChar: r.uint16,
              maxContent: r.uint16
            },
            5: {
              typoAscender: r.int16,
              typoDescender: r.int16,
              typoLineGap: r.int16,
              winAscent: r.uint16,
              winDescent: r.uint16,
              codePageRange: new r.Array(r.uint32, 2),
              xHeight: r.int16,
              capHeight: r.int16,
              defaultChar: r.uint16,
              breakChar: r.uint16,
              maxContent: r.uint16,
              usLowerOpticalPointSize: r.uint16,
              usUpperOpticalPointSize: r.uint16
            }
          });
          var versions = OS2.versions;
          versions[3] = versions[4] = versions[2];
          var post = new r.VersionedStruct(r.fixed32, {
            header: {
              italicAngle: r.fixed32,
              underlinePosition: r.int16,
              underlineThickness: r.int16,
              isFixedPitch: r.uint32,
              minMemType42: r.uint32,
              maxMemType42: r.uint32,
              minMemType1: r.uint32,
              maxMemType1: r.uint32
            },
            1: {},
            2: {
              numberOfGlyphs: r.uint16,
              glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),
              names: new r.Array(new r.String(r.uint8))
            },
            2.5: {
              numberOfGlyphs: r.uint16,
              offsets: new r.Array(r.uint8, 'numberOfGlyphs')
            },
            3: {},
            4: {
              map: new r.Array(r.uint32, function (t) {
                return t.parent.maxp.numGlyphs;
              })
            }
          });
          var cvt = new r.Struct({
            controlValues: new r.Array(r.int16)
          });
          var fpgm = new r.Struct({
            instructions: new r.Array(r.uint8)
          });
          var loca = new r.VersionedStruct('head.indexToLocFormat', {
            0: {
              offsets: new r.Array(r.uint16)
            },
            1: {
              offsets: new r.Array(r.uint32)
            }
          });

          loca.process = function () {
            if (this.version === 0) {
              for (var i = 0; i < this.offsets.length; i++) {
                this.offsets[i] <<= 1;
              }
            }
          };

          loca.preEncode = function () {
            if (this.version === 0) {
              for (var i = 0; i < this.offsets.length; i++) {
                this.offsets[i] >>>= 1;
              }
            }
          };

          var prep = new r.Struct({
            controlValueProgram: new r.Array(r.uint8)
          });
          var glyf = new r.Array(new r.Buffer());
          var tables: any = {};
          tables.cmap = cmap;
          tables.head = head;
          tables.hhea = hhea;
          tables.hmtx = hmtx;
          tables.maxp = maxp;
          tables.name = NameTable;
          tables['OS/2'] = OS2;
          tables.post = post;
          tables.fpgm = fpgm;
          tables.loca = loca;
          tables.prep = prep;
          tables['cvt '] = cvt;
          tables.glyf = glyf;
          var TableEntry = new r.Struct({
            tag: new r.String(4),
            checkSum: r.uint32,
            offset: new r.Pointer(r.uint32, 'void', {
              type: 'global'
            }),
            length: r.uint32
          });
          var Directory = new r.Struct({
            tag: new r.String(4),
            numTables: r.uint16,
            searchRange: r.uint16,
            entrySelector: r.uint16,
            rangeShift: r.uint16,
            tables: new r.Array(TableEntry, 'numTables')
          });

          Directory.process = function () {
            var tables = {};

            for (var _iterator = _createForOfIteratorHelperLoose(this.tables), _step; !(_step = _iterator()).done;) {
              var table = _step.value;
              tables[table.tag] = table;
            }

            this.tables = tables;
          };

          Directory.preEncode = function (stream) {
            var tables$1 = [];

            for (var tag in this.tables) {
              var table = this.tables[tag];

              if (table) {
                tables$1.push({
                  tag: tag,
                  checkSum: 0,
                  offset: new r.VoidPointer(tables[tag], table),
                  length: tables[tag].size(table)
                });
              }
            }

            this.tag = 'true';
            this.numTables = tables$1.length;
            this.tables = tables$1;
            var maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
            var maxPowerOf2 = Math.pow(2, maxExponentFor2);
            this.searchRange = maxPowerOf2 * 16;
            this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
            this.rangeShift = this.numTables * 16 - this.searchRange;
          };

          function binarySearch(arr, cmp) {
            var min = 0;
            var max = arr.length - 1;

            while (min <= max) {
              var mid = min + max >> 1;
              var res = cmp(arr[mid]);

              if (res < 0) {
                max = mid - 1;
              } else if (res > 0) {
                min = mid + 1;
              } else {
                return mid;
              }
            }

            return -1;
          }

          function range(index, end) {
            var range = [];

            while (index < end) {
              range.push(index++);
            }

            return range;
          }

          var _class;

          try {
            var iconv = localRequire('iconv-lite');
          } catch (err) { }

          var CmapProcessor = (_class = function () {
            function CmapProcessor(cmapTable) {
              this.encoding = null;
              this.cmap = this.findSubtable(cmapTable, [[3, 10], [0, 6], [0, 4], [3, 1], [0, 3], [0, 2], [0, 1], [0, 0]]);

              if (!this.cmap && iconv) {
                for (var _iterator = _createForOfIteratorHelperLoose(cmapTable.tables), _step; !(_step = _iterator()).done;) {
                  var cmap = _step.value;
                  var encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);

                  if (iconv.encodingExists(encoding)) {
                    this.cmap = cmap.table;
                    this.encoding = encoding;
                  }
                }
              }

              if (!this.cmap) {
                throw new Error('Could not find a supported cmap table');
              }

              this.uvs = this.findSubtable(cmapTable, [[0, 5]]);

              if (this.uvs && this.uvs.version !== 14) {
                this.uvs = null;
              }
            }

            var _proto = CmapProcessor.prototype;

            _proto.findSubtable = function findSubtable(cmapTable, pairs) {
              for (var _iterator2 = _createForOfIteratorHelperLoose(pairs), _step2; !(_step2 = _iterator2()).done;) {
                var _step2$value = _step2.value,
                  platformID = _step2$value[0],
                  encodingID = _step2$value[1];

                for (var _iterator3 = _createForOfIteratorHelperLoose(cmapTable.tables), _step3; !(_step3 = _iterator3()).done;) {
                  var cmap = _step3.value;

                  if (cmap.platformID === platformID && cmap.encodingID === encodingID) {
                    return cmap.table;
                  }
                }
              }

              return null;
            };

            _proto.lookup = function lookup(codepoint, variationSelector) {
              if (this.encoding) {
                var buf = iconv.encode(_String$fromCodePoint(codepoint), this.encoding);
                codepoint = 0;

                for (var i = 0; i < buf.length; i++) {
                  codepoint = codepoint << 8 | buf[i];
                }
              } else if (variationSelector) {
                var gid = this.getVariationSelector(codepoint, variationSelector);

                if (gid) {
                  return gid;
                }
              }

              var cmap = this.cmap;

              switch (cmap.version) {
                case 0:
                  return cmap.codeMap.get(codepoint) || 0;

                case 4:
                  {
                    var min = 0;
                    var max = cmap.segCount - 1;

                    while (min <= max) {
                      var mid = min + max >> 1;

                      if (codepoint < cmap.startCode.get(mid)) {
                        max = mid - 1;
                      } else if (codepoint > cmap.endCode.get(mid)) {
                        min = mid + 1;
                      } else {
                        var rangeOffset = cmap.idRangeOffset.get(mid);

                        var _gid = void 0;

                        if (rangeOffset === 0) {
                          _gid = codepoint + cmap.idDelta.get(mid);
                        } else {
                          var index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
                          _gid = cmap.glyphIndexArray.get(index) || 0;

                          if (_gid !== 0) {
                            _gid += cmap.idDelta.get(mid);
                          }
                        }

                        return _gid & 65535;
                      }
                    }

                    return 0;
                  }

                case 8:
                  throw new Error('TODO: cmap format 8');

                case 6:
                case 10:
                  return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;

                case 12:
                case 13:
                  {
                    var _min = 0;

                    var _max = cmap.nGroups - 1;

                    while (_min <= _max) {
                      var _mid = _min + _max >> 1;

                      var group = cmap.groups.get(_mid);

                      if (codepoint < group.startCharCode) {
                        _max = _mid - 1;
                      } else if (codepoint > group.endCharCode) {
                        _min = _mid + 1;
                      } else {
                        if (cmap.version === 12) {
                          return group.glyphID + (codepoint - group.startCharCode);
                        } else {
                          return group.glyphID;
                        }
                      }
                    }

                    return 0;
                  }

                case 14:
                  throw new Error('TODO: cmap format 14');

                default:
                  throw new Error('Unknown cmap format ' + cmap.version);
              }
            };

            _proto.getVariationSelector = function getVariationSelector(codepoint, variationSelector) {
              if (!this.uvs) {
                return 0;
              }

              var selectors = this.uvs.varSelectors.toArray();
              var i = binarySearch(selectors, function (x) {
                return variationSelector - x.varSelector;
              });
              var sel = selectors[i];

              if (i !== -1 && sel.defaultUVS) {
                i = binarySearch(sel.defaultUVS, function (x) {
                  return codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0;
                });
              }

              if (i !== -1 && sel.nonDefaultUVS) {
                i = binarySearch(sel.nonDefaultUVS, function (x) {
                  return codepoint - x.unicodeValue;
                });

                if (i !== -1) {
                  return sel.nonDefaultUVS[i].glyphID;
                }
              }

              return 0;
            };

            _proto.getCharacterSet = function getCharacterSet() {
              var cmap = this.cmap;

              switch (cmap.version) {
                case 0:
                  return range(0, cmap.codeMap.length);

                case 4:
                  {
                    var res = [];
                    var endCodes = cmap.endCode.toArray();

                    for (var i = 0; i < endCodes.length; i++) {
                      var tail = endCodes[i] + 1;
                      var start = cmap.startCode.get(i);
                      res.push.apply(res, range(start, tail));
                    }

                    return res;
                  }

                case 8:
                  throw new Error('TODO: cmap format 8');

                case 6:
                case 10:
                  return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);

                case 12:
                case 13:
                  {
                    var _res = [];

                    for (var _iterator4 = _createForOfIteratorHelperLoose(cmap.groups.toArray()), _step4; !(_step4 = _iterator4()).done;) {
                      var group = _step4.value;

                      _res.push.apply(_res, range(group.startCharCode, group.endCharCode + 1));
                    }

                    return _res;
                  }

                case 14:
                  throw new Error('TODO: cmap format 14');

                default:
                  throw new Error('Unknown cmap format ' + cmap.version);
              }
            };

            _proto.codePointsForGlyph = function codePointsForGlyph(gid) {
              var cmap = this.cmap;

              switch (cmap.version) {
                case 0:
                  {
                    var res = [];

                    for (var i = 0; i < 256; i++) {
                      if (cmap.codeMap.get(i) === gid) {
                        res.push(i);
                      }
                    }

                    return res;
                  }

                case 4:
                  {
                    var _res2 = [];

                    for (var _i = 0; _i < cmap.segCount; _i++) {
                      var end = cmap.endCode.get(_i);
                      var start = cmap.startCode.get(_i);
                      var rangeOffset = cmap.idRangeOffset.get(_i);
                      var delta = cmap.idDelta.get(_i);

                      for (var c = start; c <= end; c++) {
                        var g = 0;

                        if (rangeOffset === 0) {
                          g = c + delta;
                        } else {
                          var index = rangeOffset / 2 + (c - start) - (cmap.segCount - _i);
                          g = cmap.glyphIndexArray.get(index) || 0;

                          if (g !== 0) {
                            g += delta;
                          }
                        }

                        if (g === gid) {
                          _res2.push(c);
                        }
                      }
                    }

                    return _res2;
                  }

                case 12:
                  {
                    var _res3 = [];

                    for (var _iterator5 = _createForOfIteratorHelperLoose(cmap.groups.toArray()), _step5; !(_step5 = _iterator5()).done;) {
                      var group = _step5.value;

                      if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {
                        _res3.push(group.startCharCode + (gid - group.glyphID));
                      }
                    }

                    return _res3;
                  }

                case 13:
                  {
                    var _res4 = [];

                    for (var _iterator6 = _createForOfIteratorHelperLoose(cmap.groups.toArray()), _step6; !(_step6 = _iterator6()).done;) {
                      var _group = _step6.value;

                      if (gid === _group.glyphID) {
                        _res4.push.apply(_res4, range(_group.startCharCode, _group.endCharCode + 1));
                      }
                    }

                    return _res4;
                  }

                default:
                  throw new Error('Unknown cmap format ' + cmap.version);
              }
            };

            return CmapProcessor;
          }(), (_applyDecoratedDescriptor(_class.prototype, 'getCharacterSet', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'getCharacterSet'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'codePointsForGlyph', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'codePointsForGlyph'), _class.prototype)), _class);

          var UnicodeLayoutEngine = function () {
            function UnicodeLayoutEngine(font) {
              this.font = font;
            }

            var _proto = UnicodeLayoutEngine.prototype;

            _proto.positionGlyphs = function positionGlyphs(glyphs, positions) {
              var clusterStart = 0;
              var clusterEnd = 0;

              for (var index = 0; index < glyphs.length; index++) {
                var glyph = glyphs[index];

                if (glyph.isMark) {
                  clusterEnd = index;
                } else {
                  if (clusterStart !== clusterEnd) {
                    this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                  }

                  clusterStart = clusterEnd = index;
                }
              }

              if (clusterStart !== clusterEnd) {
                this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
              }

              return positions;
            };

            _proto.positionCluster = function positionCluster(glyphs, positions, clusterStart, clusterEnd) {
              var base = glyphs[clusterStart];
              var baseBox = base.cbox.copy();

              if (base.codePoints.length > 1) {
                baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
              }

              var xOffset = -positions[clusterStart].xAdvance;
              var yOffset = 0;
              var yGap = this.font.unitsPerEm / 16;

              for (var index = clusterStart + 1; index <= clusterEnd; index++) {
                var mark = glyphs[index];
                var markBox = mark.cbox;
                var position = positions[index];
                var combiningClass = this.getCombiningClass(mark.codePoints[0]);

                if (combiningClass !== 'Not_Reordered') {
                  position.xOffset = position.yOffset = 0;

                  switch (combiningClass) {
                    case 'Double_Above':
                    case 'Double_Below':
                      position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
                      break;

                    case 'Attached_Below_Left':
                    case 'Below_Left':
                    case 'Above_Left':
                      position.xOffset += baseBox.minX - markBox.minX;
                      break;

                    case 'Attached_Above_Right':
                    case 'Below_Right':
                    case 'Above_Right':
                      position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
                      break;

                    default:
                      position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
                  }

                  switch (combiningClass) {
                    case 'Double_Below':
                    case 'Below_Left':
                    case 'Below':
                    case 'Below_Right':
                    case 'Attached_Below_Left':
                    case 'Attached_Below':
                      if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {
                        baseBox.minY += yGap;
                      }

                      position.yOffset = -baseBox.minY - markBox.maxY;
                      baseBox.minY += markBox.height;
                      break;

                    case 'Double_Above':
                    case 'Above_Left':
                    case 'Above':
                    case 'Above_Right':
                    case 'Attached_Above':
                    case 'Attached_Above_Right':
                      if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {
                        baseBox.maxY += yGap;
                      }

                      position.yOffset = baseBox.maxY - markBox.minY;
                      baseBox.maxY += markBox.height;
                      break;
                  }

                  position.xAdvance = position.yAdvance = 0;
                  position.xOffset += xOffset;
                  position.yOffset += yOffset;
                } else {
                  xOffset -= position.xAdvance;
                  yOffset -= position.yAdvance;
                }
              }

              return;
            };

            _proto.getCombiningClass = function getCombiningClass(codePoint) {
              var combiningClass = unicode.getCombiningClass(codePoint);

              if ((codePoint & ~255) === 3584) {
                if (combiningClass === 'Not_Reordered') {
                  switch (codePoint) {
                    case 3633:
                    case 3636:
                    case 3637:
                    case 3638:
                    case 3639:
                    case 3655:
                    case 3660:
                    case 3645:
                    case 3662:
                      return 'Above_Right';

                    case 3761:
                    case 3764:
                    case 3765:
                    case 3766:
                    case 3767:
                    case 3771:
                    case 3788:
                    case 3789:
                      return 'Above';

                    case 3772:
                      return 'Below';
                  }
                } else if (codePoint === 3642) {
                  return 'Below_Right';
                }
              }

              switch (combiningClass) {
                case 'CCC10':
                case 'CCC11':
                case 'CCC12':
                case 'CCC13':
                case 'CCC14':
                case 'CCC15':
                case 'CCC16':
                case 'CCC17':
                case 'CCC18':
                case 'CCC20':
                case 'CCC22':
                  return 'Below';

                case 'CCC23':
                  return 'Attached_Above';

                case 'CCC24':
                  return 'Above_Right';

                case 'CCC25':
                case 'CCC19':
                  return 'Above_Left';

                case 'CCC26':
                  return 'Above';

                case 'CCC21':
                  break;

                case 'CCC27':
                case 'CCC28':
                case 'CCC30':
                case 'CCC31':
                case 'CCC33':
                case 'CCC34':
                case 'CCC35':
                case 'CCC36':
                  return 'Above';

                case 'CCC29':
                case 'CCC32':
                  return 'Below';

                case 'CCC103':
                  return 'Below_Right';

                case 'CCC107':
                  return 'Above_Right';

                case 'CCC118':
                  return 'Below';

                case 'CCC122':
                  return 'Above';

                case 'CCC129':
                case 'CCC132':
                  return 'Below';

                case 'CCC130':
                  return 'Above';
              }

              return combiningClass;
            };

            return UnicodeLayoutEngine;
          }();

          var BBox = function () {
            function BBox(minX?, minY?, maxX?, maxY?): void {
              if (minX === void 0) {
                minX = Infinity;
              }

              if (minY === void 0) {
                minY = Infinity;
              }

              if (maxX === void 0) {
                maxX = -Infinity;
              }

              if (maxY === void 0) {
                maxY = -Infinity;
              }

              this.minX = minX;
              this.minY = minY;
              this.maxX = maxX;
              this.maxY = maxY;
            }

            var _proto = BBox.prototype;

            _proto.addPoint = function addPoint(x, y) {
              if (Math.abs(x) !== Infinity) {
                if (x < this.minX) {
                  this.minX = x;
                }

                if (x > this.maxX) {
                  this.maxX = x;
                }
              }

              if (Math.abs(y) !== Infinity) {
                if (y < this.minY) {
                  this.minY = y;
                }

                if (y > this.maxY) {
                  this.maxY = y;
                }
              }
            };

            _proto.copy = function copy() {
              return new BBox(this.minX, this.minY, this.maxX, this.maxY);
            };

            _createClass(BBox, [{
              key: 'width',
              get: function get() {
                return this.maxX - this.minX;
              }
            }, {
              key: 'height',
              get: function get() {
                return this.maxY - this.minY;
              }
            }]);

            return BBox;
          }();

          var UNICODE_SCRIPTS = {
            Caucasian_Albanian: 'aghb',
            Arabic: 'arab',
            Imperial_Aramaic: 'armi',
            Armenian: 'armn',
            Avestan: 'avst',
            Balinese: 'bali',
            Bamum: 'bamu',
            Bassa_Vah: 'bass',
            Batak: 'batk',
            Bengali: ['bng2', 'beng'],
            Bopomofo: 'bopo',
            Brahmi: 'brah',
            Braille: 'brai',
            Buginese: 'bugi',
            Buhid: 'buhd',
            Chakma: 'cakm',
            Canadian_Aboriginal: 'cans',
            Carian: 'cari',
            Cham: 'cham',
            Cherokee: 'cher',
            Coptic: 'copt',
            Cypriot: 'cprt',
            Cyrillic: 'cyrl',
            Devanagari: ['dev2', 'deva'],
            Deseret: 'dsrt',
            Duployan: 'dupl',
            Egyptian_Hieroglyphs: 'egyp',
            Elbasan: 'elba',
            Ethiopic: 'ethi',
            Georgian: 'geor',
            Glagolitic: 'glag',
            Gothic: 'goth',
            Grantha: 'gran',
            Greek: 'grek',
            Gujarati: ['gjr2', 'gujr'],
            Gurmukhi: ['gur2', 'guru'],
            Hangul: 'hang',
            Han: 'hani',
            Hanunoo: 'hano',
            Hebrew: 'hebr',
            Hiragana: 'hira',
            Pahawh_Hmong: 'hmng',
            Katakana_Or_Hiragana: 'hrkt',
            Old_Italic: 'ital',
            Javanese: 'java',
            Kayah_Li: 'kali',
            Katakana: 'kana',
            Kharoshthi: 'khar',
            Khmer: 'khmr',
            Khojki: 'khoj',
            Kannada: ['knd2', 'knda'],
            Kaithi: 'kthi',
            Tai_Tham: 'lana',
            Lao: 'lao ',
            Latin: 'latn',
            Lepcha: 'lepc',
            Limbu: 'limb',
            Linear_A: 'lina',
            Linear_B: 'linb',
            Lisu: 'lisu',
            Lycian: 'lyci',
            Lydian: 'lydi',
            Mahajani: 'mahj',
            Mandaic: 'mand',
            Manichaean: 'mani',
            Mende_Kikakui: 'mend',
            Meroitic_Cursive: 'merc',
            Meroitic_Hieroglyphs: 'mero',
            Malayalam: ['mlm2', 'mlym'],
            Modi: 'modi',
            Mongolian: 'mong',
            Mro: 'mroo',
            Meetei_Mayek: 'mtei',
            Myanmar: ['mym2', 'mymr'],
            Old_North_Arabian: 'narb',
            Nabataean: 'nbat',
            Nko: 'nko ',
            Ogham: 'ogam',
            Ol_Chiki: 'olck',
            Old_Turkic: 'orkh',
            Oriya: ['ory2', 'orya'],
            Osmanya: 'osma',
            Palmyrene: 'palm',
            Pau_Cin_Hau: 'pauc',
            Old_Permic: 'perm',
            Phags_Pa: 'phag',
            Inscriptional_Pahlavi: 'phli',
            Psalter_Pahlavi: 'phlp',
            Phoenician: 'phnx',
            Miao: 'plrd',
            Inscriptional_Parthian: 'prti',
            Rejang: 'rjng',
            Runic: 'runr',
            Samaritan: 'samr',
            Old_South_Arabian: 'sarb',
            Saurashtra: 'saur',
            Shavian: 'shaw',
            Sharada: 'shrd',
            Siddham: 'sidd',
            Khudawadi: 'sind',
            Sinhala: 'sinh',
            Sora_Sompeng: 'sora',
            Sundanese: 'sund',
            Syloti_Nagri: 'sylo',
            Syriac: 'syrc',
            Tagbanwa: 'tagb',
            Takri: 'takr',
            Tai_Le: 'tale',
            New_Tai_Lue: 'talu',
            Tamil: ['tml2', 'taml'],
            Tai_Viet: 'tavt',
            Telugu: ['tel2', 'telu'],
            Tifinagh: 'tfng',
            Tagalog: 'tglg',
            Thaana: 'thaa',
            Thai: 'thai',
            Tibetan: 'tibt',
            Tirhuta: 'tirh',
            Ugaritic: 'ugar',
            Vai: 'vai ',
            Warang_Citi: 'wara',
            Old_Persian: 'xpeo',
            Cuneiform: 'xsux',
            Yi: 'yi  ',
            Inherited: 'zinh',
            Common: 'zyyy',
            Unknown: 'zzzz'
          };

          for (var script in UNICODE_SCRIPTS) {
            var tag = UNICODE_SCRIPTS[script];

            if (_Array$isArray(tag)) {
              for (var _iterator = _createForOfIteratorHelperLoose(tag), _step; !(_step = _iterator()).done;) {
                var t = _step.value;
              }
            }
          }

          function forString(string) {
            var len = string.length;
            var idx = 0;

            while (idx < len) {
              var code = string.charCodeAt(idx++);

              if (55296 <= code && code <= 56319 && idx < len) {
                var next = string.charCodeAt(idx);

                if (56320 <= next && next <= 57343) {
                  idx++;
                  code = ((code & 1023) << 10) + (next & 1023) + 65536;
                }
              }

              var _script = unicode.getScript(code);

              if (_script !== 'Common' && _script !== 'Inherited' && _script !== 'Unknown') {
                return UNICODE_SCRIPTS[_script];
              }
            }

            return UNICODE_SCRIPTS.Unknown;
          }

          function forCodePoints(codePoints) {
            for (var i = 0; i < codePoints.length; i++) {
              var codePoint = codePoints[i];

              var _script2 = unicode.getScript(codePoint);

              if (_script2 !== 'Common' && _script2 !== 'Inherited' && _script2 !== 'Unknown') {
                return UNICODE_SCRIPTS[_script2];
              }
            }

            return UNICODE_SCRIPTS.Unknown;
          }

          var RTL = {
            arab: true,
            hebr: true,
            syrc: true,
            thaa: true,
            cprt: true,
            khar: true,
            phnx: true,
            'nko ': true,
            lydi: true,
            avst: true,
            armi: true,
            phli: true,
            prti: true,
            sarb: true,
            orkh: true,
            samr: true,
            mand: true,
            merc: true,
            mero: true,
            mani: true,
            mend: true,
            nbat: true,
            narb: true,
            palm: true,
            phlp: true
          };

          function direction(script) {
            if (RTL[script]) {
              return 'rtl';
            }

            return 'ltr';
          }

          var GlyphRun = function () {
            function GlyphRun(glyphs, features, script, language, direction$1) {
              this.glyphs = glyphs;
              this.positions = null;
              this.script = script;
              this.language = language || null;
              this.direction = direction$1 || direction(script);
              this.features = {};

              if (_Array$isArray(features)) {
                for (var _iterator = _createForOfIteratorHelperLoose(features), _step; !(_step = _iterator()).done;) {
                  var tag = _step.value;
                  this.features[tag] = true;
                }
              } else if (typeof features === 'object') {
                this.features = features;
              }
            }

            _createClass(GlyphRun, [{
              key: 'advanceWidth',
              get: function get() {
                var width = 0;

                for (var _iterator2 = _createForOfIteratorHelperLoose(this.positions), _step2; !(_step2 = _iterator2()).done;) {
                  var position = _step2.value;
                  width += position.xAdvance;
                }

                return width;
              }
            }, {
              key: 'advanceHeight',
              get: function get() {
                var height = 0;

                for (var _iterator3 = _createForOfIteratorHelperLoose(this.positions), _step3; !(_step3 = _iterator3()).done;) {
                  var position = _step3.value;
                  height += position.yAdvance;
                }

                return height;
              }
            }, {
              key: 'bbox',
              get: function get() {
                var bbox = new BBox();
                var x = 0;
                var y = 0;

                for (var index = 0; index < this.glyphs.length; index++) {
                  var glyph = this.glyphs[index];
                  var p = this.positions[index];
                  var b = glyph.bbox;
                  bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
                  bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
                  x += p.xAdvance;
                  y += p.yAdvance;
                }

                return bbox;
              }
            }]);

            return GlyphRun;
          }();

          var GlyphPosition = function GlyphPosition(xAdvance, yAdvance?, xOffset?, yOffset?): void {
            if (xAdvance === void 0) {
              xAdvance = 0;
            }

            if (yAdvance === void 0) {
              yAdvance = 0;
            }

            if (xOffset === void 0) {
              xOffset = 0;
            }

            if (yOffset === void 0) {
              yOffset = 0;
            }

            this.xAdvance = xAdvance;
            this.yAdvance = yAdvance;
            this.xOffset = xOffset;
            this.yOffset = yOffset;
          };

          var LayoutEngine = function () {
            function LayoutEngine(font) {
              this.font = font;
              this.unicodeLayoutEngine = null;
              this.kernProcessor = null;
            }

            var _proto = LayoutEngine.prototype;

            _proto.layout = function layout(string, features, script, language, direction) {
              if (typeof features === 'string') {
                direction = language;
                language = script;
                script = features;
                features = [];
              }

              if (typeof string === 'string') {
                if (script == null) {
                  script = forString(string);
                }

                var glyphs = this.font.glyphsForString(string);
              } else {
                if (script == null) {
                  var codePoints = [];

                  for (var _iterator = _createForOfIteratorHelperLoose(string), _step; !(_step = _iterator()).done;) {
                    var glyph = _step.value;
                    codePoints.push.apply(codePoints, glyph.codePoints);
                  }

                  script = forCodePoints(codePoints);
                }

                var glyphs = string;
              }

              var glyphRun = new GlyphRun(glyphs, features, script, language, direction);

              if (glyphs.length === 0) {
                glyphRun.positions = [];
                return glyphRun;
              }

              if (this.engine && this.engine.setup) {
                this.engine.setup(glyphRun);
              }

              this.substitute(glyphRun);
              this.position(glyphRun);
              this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);

              if (this.engine && this.engine.cleanup) {
                this.engine.cleanup();
              }

              return glyphRun;
            };

            _proto.substitute = function substitute(glyphRun) {
              if (this.engine && this.engine.substitute) {
                this.engine.substitute(glyphRun);
              }
            };

            _proto.position = function position(glyphRun) {
              glyphRun.positions = glyphRun.glyphs.map(function (glyph) {
                return new GlyphPosition(glyph.advanceWidth);
              });
              var positioned = null;

              if (this.engine && this.engine.position) {
                positioned = this.engine.position(glyphRun);
              }

              if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
                if (!this.unicodeLayoutEngine) {
                  this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);
                }

                this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
              }
            };

            _proto.hideDefaultIgnorables = function hideDefaultIgnorables(glyphs, positions) {
              var space = this.font.glyphForCodePoint(32);

              for (var i = 0; i < glyphs.length; i++) {
                if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
                  glyphs[i] = space;
                  positions[i].xAdvance = 0;
                  positions[i].yAdvance = 0;
                }
              }
            };

            _proto.isDefaultIgnorable = function isDefaultIgnorable(ch) {
              var plane = ch >> 16;

              if (plane === 0) {
                switch (ch >> 8) {
                  case 0:
                    return ch === 173;

                  case 3:
                    return ch === 847;

                  case 6:
                    return ch === 1564;

                  case 23:
                    return 6068 <= ch && ch <= 6069;

                  case 24:
                    return 6155 <= ch && ch <= 6158;

                  case 32:
                    return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;

                  case 254:
                    return 65024 <= ch && ch <= 65039 || ch === 65279;

                  case 255:
                    return 65520 <= ch && ch <= 65528;

                  default:
                    return false;
                }
              } else {
                switch (plane) {
                  case 1:
                    return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;

                  case 14:
                    return 917504 <= ch && ch <= 921599;

                  default:
                    return false;
                }
              }
            };

            _proto.getAvailableFeatures = function getAvailableFeatures(script, language) {
              var features = [];

              if (this.engine) {
                features.push.apply(features, this.engine.getAvailableFeatures(script, language));
              }

              if (this.font.kern && features.indexOf('kern') === -1) {
                features.push('kern');
              }

              return features;
            };

            _proto.stringsForGlyph = function stringsForGlyph(gid) {
              var result = new _Set();

              var codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);

              for (var _iterator2 = _createForOfIteratorHelperLoose(codePoints), _step2; !(_step2 = _iterator2()).done;) {
                var codePoint = _step2.value;
                result.add(_String$fromCodePoint(codePoint));
              }

              if (this.engine && this.engine.stringsForGlyph) {
                for (var _iterator3 = _createForOfIteratorHelperLoose(this.engine.stringsForGlyph(gid)), _step3; !(_step3 = _iterator3()).done;) {
                  var string = _step3.value;
                  result.add(string);
                }
              }

              return _Array$from(result);
            };

            return LayoutEngine;
          }();

          var SVG_COMMANDS = {
            moveTo: 'M',
            lineTo: 'L',
            quadraticCurveTo: 'Q',
            bezierCurveTo: 'C',
            closePath: 'Z'
          };

          var Path = function () {
            function Path() {
              this.commands = [];
              this._bbox = null;
              this._cbox = null;
            }

            var _proto = Path.prototype;

            _proto.toFunction = function toFunction() {
              var _this = this;

              return function (ctx) {
                _this.commands.forEach(function (c) {
                  return ctx[c.command].apply(ctx, c.args);
                });
              };
            };

            _proto.toSVG = function toSVG() {
              var cmds = this.commands.map(function (c) {
                var args = c.args.map(function (arg) {
                  return Math.round(arg * 100) / 100;
                });
                return '' + SVG_COMMANDS[c.command] + args.join(' ');
              });
              return cmds.join('');
            };

            _proto.mapPoints = function mapPoints(fn) {
              var path = new Path();

              for (var _iterator = _createForOfIteratorHelperLoose(this.commands), _step; !(_step = _iterator()).done;) {
                var c = _step.value;
                var args = [];

                for (var i = 0; i < c.args.length; i += 2) {
                  var _fn = fn(c.args[i], c.args[i + 1]),
                    x = _fn[0],
                    y = _fn[1];

                  args.push(x, y);
                }

                path[c.command].apply(path, args);
              }

              return path;
            };

            _proto.transform = function transform(m0, m1, m2, m3, m4, m5) {
              return this.mapPoints(function (x, y) {
                x = m0 * x + m2 * y + m4;
                y = m1 * x + m3 * y + m5;
                return [x, y];
              });
            };

            _proto.translate = function translate(x, y) {
              return this.transform(1, 0, 0, 1, x, y);
            };

            _proto.rotate = function rotate(angle) {
              var cos = Math.cos(angle);
              var sin = Math.sin(angle);
              return this.transform(cos, sin, -sin, cos, 0, 0);
            };

            _proto.scale = function scale(scaleX, scaleY) {
              if (scaleY === void 0) {
                scaleY = scaleX;
              }

              return this.transform(scaleX, 0, 0, scaleY, 0, 0);
            };

            _createClass(Path, [{
              key: 'cbox',
              get: function get() {
                if (!this._cbox) {
                  var cbox = new BBox();

                  for (var _iterator2 = _createForOfIteratorHelperLoose(this.commands), _step2; !(_step2 = _iterator2()).done;) {
                    var command = _step2.value;

                    for (var i = 0; i < command.args.length; i += 2) {
                      cbox.addPoint(command.args[i], command.args[i + 1]);
                    }
                  }

                  this._cbox = _Object$freeze(cbox);
                }

                return this._cbox;
              }
            }, {
              key: 'bbox',
              get: function get() {
                if (this._bbox) {
                  return this._bbox;
                }

                var bbox = new BBox();
                var cx = 0,
                  cy = 0;

                var f = function f(t) {
                  return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
                };

                for (var _iterator3 = _createForOfIteratorHelperLoose(this.commands), _step3; !(_step3 = _iterator3()).done;) {
                  var c = _step3.value;

                  switch (c.command) {
                    case 'moveTo':
                    case 'lineTo':
                      var _c$args = c.args,
                        x = _c$args[0],
                        y = _c$args[1];
                      bbox.addPoint(x, y);
                      cx = x;
                      cy = y;
                      break;

                    case 'quadraticCurveTo':
                    case 'bezierCurveTo':
                      if (c.command === 'quadraticCurveTo') {
                        var _c$args2 = c.args,
                          qp1x = _c$args2[0],
                          qp1y = _c$args2[1],
                          p3x = _c$args2[2],
                          p3y = _c$args2[3];
                        var cp1x: any = cx + 2 / 3 * (qp1x - cx);
                        var cp1y: any = cy + 2 / 3 * (qp1y - cy);
                        var cp2x = p3x + 2 / 3 * (qp1x - p3x);
                        var cp2y = p3y + 2 / 3 * (qp1y - p3y);
                      } else {
                        var _c$args3 = c.args,
                          cp1x = _c$args3[0],
                          cp1y = _c$args3[1],
                          cp2x = _c$args3[2],
                          cp2y = _c$args3[3],
                          p3x = _c$args3[4],
                          p3y = _c$args3[5];
                      }

                      bbox.addPoint(p3x, p3y);
                      var p0 = [cx, cy];
                      var p1 = [cp1x, cp1y];
                      var p2 = [cp2x, cp2y];
                      var p3 = [p3x, p3y];

                      for (var i = 0; i <= 1; i++) {
                        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                        c = 3 * p1[i] - 3 * p0[i];

                        if (a === 0) {
                          if (b === 0) {
                            continue;
                          }

                          var t = -c / b;

                          if (0 < t && t < 1) {
                            if (i === 0) {
                              bbox.addPoint(f(t), bbox.maxY);
                            } else if (i === 1) {
                              bbox.addPoint(bbox.maxX, f(t));
                            }
                          }

                          continue;
                        }

                        var b2ac = Math.pow(b, 2) - 4 * c * a;

                        if (b2ac < 0) {
                          continue;
                        }

                        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);

                        if (0 < t1 && t1 < 1) {
                          if (i === 0) {
                            bbox.addPoint(f(t1), bbox.maxY);
                          } else if (i === 1) {
                            bbox.addPoint(bbox.maxX, f(t1));
                          }
                        }

                        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);

                        if (0 < t2 && t2 < 1) {
                          if (i === 0) {
                            bbox.addPoint(f(t2), bbox.maxY);
                          } else if (i === 1) {
                            bbox.addPoint(bbox.maxX, f(t2));
                          }
                        }
                      }

                      cx = p3x;
                      cy = p3y;
                      break;
                  }
                }

                return this._bbox = _Object$freeze(bbox);
              }
            }]);

            return Path;
          }();

          var _loop = function _loop() {
            var command = _arr[_i];

            Path.prototype[command] = function () {
              this._bbox = this._cbox = null;

              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              this.commands.push({
                command: command,
                args: args
              });
              return this;
            };
          };

          for (var _i = 0, _arr = ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath']; _i < _arr.length; _i++) {
            _loop();
          }

          var StandardNames = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

          var _class$1;

          var Glyph = (_class$1 = function () {
            function Glyph(id, codePoints, font) {
              this.id = id;
              this.codePoints = codePoints;
              this._font = font;
              this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
              this.isLigature = this.codePoints.length > 1;
            }

            var _proto = Glyph.prototype;

            _proto._getPath = function _getPath() {
              return new Path();
            };

            _proto._getCBox = function _getCBox() {
              return this.path.cbox;
            };

            _proto._getBBox = function _getBBox() {
              return this.path.bbox;
            };

            _proto._getTableMetrics = function _getTableMetrics(table) {
              if (this.id < table.metrics.length) {
                return table.metrics.get(this.id);
              }

              var metric = table.metrics.get(table.metrics.length - 1);
              var res = {
                advance: metric ? metric.advance : 0,
                bearing: table.bearings.get(this.id - table.metrics.length) || 0
              };
              return res;
            };

            _proto._getMetrics = function _getMetrics(cbox) {
              if (this._metrics) {
                return this._metrics;
              }

              var _this$_getTableMetric = this._getTableMetrics(this._font.hmtx),
                advanceWidth = _this$_getTableMetric.advance,
                leftBearing = _this$_getTableMetric.bearing;

              if (this._font.vmtx) {
                var _this$_getTableMetric2 = this._getTableMetrics(this._font.vmtx),
                  advanceHeight = _this$_getTableMetric2.advance,
                  topBearing = _this$_getTableMetric2.bearing;
              } else {
                var os2;

                if (typeof cbox === 'undefined' || cbox === null) {
                  cbox = this.cbox;
                }

                if ((os2 = this._font['OS/2']) && os2.version > 0) {
                  var advanceHeight: any = Math.abs(os2.typoAscender - os2.typoDescender);
                  var topBearing: any = os2.typoAscender - cbox.maxY;
                } else {
                  var hhea = this._font.hhea;
                  var advanceHeight: any = Math.abs(hhea.ascent - hhea.descent);
                  var topBearing: any = hhea.ascent - cbox.maxY;
                }
              }

              if (this._font._variationProcessor && this._font.HVAR) {
                advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
              }

              return this._metrics = {
                advanceWidth: advanceWidth,
                advanceHeight: advanceHeight,
                leftBearing: leftBearing,
                topBearing: topBearing
              };
            };

            _proto.getScaledPath = function getScaledPath(size) {
              var scale = 1 / this._font.unitsPerEm * size;
              return this.path.scale(scale);
            };

            _proto._getName = function _getName() {
              var post = this._font.post;

              if (!post) {
                return null;
              }

              switch (post.version) {
                case 1:
                  return StandardNames[this.id];

                case 2:
                  var id = post.glyphNameIndex[this.id];

                  if (id < StandardNames.length) {
                    return StandardNames[id];
                  }

                  return post.names[id - StandardNames.length];

                case 2.5:
                  return StandardNames[this.id + post.offsets[this.id]];

                case 4:
                  return String.fromCharCode(post.map[this.id]);
              }
            };

            _proto.render = function render(ctx, size) {
              ctx.save();
              var scale = 1 / this._font.head.unitsPerEm * size;
              ctx.scale(scale, scale);
              var fn = this.path.toFunction();
              fn(ctx);
              ctx.fill();
              ctx.restore();
            };

            _createClass(Glyph, [{
              key: 'cbox',
              get: function get() {
                return this._getCBox();
              }
            }, {
              key: 'bbox',
              get: function get() {
                return this._getBBox();
              }
            }, {
              key: 'path',
              get: function get() {
                return this._getPath();
              }
            }, {
              key: 'advanceWidth',
              get: function get() {
                return this._getMetrics().advanceWidth;
              }
            }, {
              key: 'advanceHeight',
              get: function get() {
                return this._getMetrics().advanceHeight;
              }
            }, {
              key: 'ligatureCaretPositions',
              get: function get() { }
            }, {
              key: 'name',
              get: function get() {
                return this._getName();
              }
            }]);

            return Glyph;
          }(), (_applyDecoratedDescriptor(_class$1.prototype, 'cbox', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'cbox'), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'bbox'), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, 'path', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'path'), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, 'advanceWidth', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'advanceWidth'), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, 'advanceHeight', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'advanceHeight'), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, 'name', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'name'), _class$1.prototype)), _class$1);
          var GlyfHeader = new r.Struct({
            numberOfContours: r.int16,
            xMin: r.int16,
            yMin: r.int16,
            xMax: r.int16,
            yMax: r.int16
          });
          var ON_CURVE = 1 << 0;
          var X_SHORT_VECTOR = 1 << 1;
          var Y_SHORT_VECTOR = 1 << 2;
          var REPEAT = 1 << 3;
          var SAME_X = 1 << 4;
          var SAME_Y = 1 << 5;
          var ARG_1_AND_2_ARE_WORDS = 1 << 0;
          var WE_HAVE_A_SCALE = 1 << 3;
          var MORE_COMPONENTS = 1 << 5;
          var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
          var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
          var WE_HAVE_INSTRUCTIONS = 1 << 8;

          var Point = function () {
            function Point(onCurve, endContour, x, y) {
              if (x === void 0) {
                x = 0;
              }

              if (y === void 0) {
                y = 0;
              }

              this.onCurve = onCurve;
              this.endContour = endContour;
              this.x = x;
              this.y = y;
            }

            var _proto = Point.prototype;

            _proto.copy = function copy() {
              return new Point(this.onCurve, this.endContour, this.x, this.y);
            };

            return Point;
          }();

          var Component = function Component(glyphID, dx, dy) {
            this.glyphID = glyphID;
            this.dx = dx;
            this.dy = dy;
            this.pos = 0;
            this.scaleX = this.scaleY = 1;
            this.scale01 = this.scale10 = 0;
          };

          var TTFGlyph = function (_Glyph) {
            _inheritsLoose(TTFGlyph, _Glyph);

            function TTFGlyph(a?, b?, c?): void {
              return _Glyph.apply(this, arguments) || this;
            }

            var _proto2 = TTFGlyph.prototype;

            _proto2._getCBox = function _getCBox(internal) {
              if (this._font._variationProcessor && !internal) {
                return this.path.cbox;
              }

              var stream = this._font._getTableStream('glyf');

              stream.pos += this._font.loca.offsets[this.id];
              var glyph = GlyfHeader.decode(stream);
              var cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
              return _Object$freeze(cbox);
            };

            _proto2._parseGlyphCoord = function _parseGlyphCoord(stream, prev, short, same) {
              if (short) {
                var val = stream.readUInt8();

                if (!same) {
                  val = -val;
                }

                val += prev;
              } else {
                if (same) {
                  var val = prev;
                } else {
                  var val = prev + stream.readInt16BE();
                }
              }

              return val;
            };

            _proto2._decode = function _decode() {
              var glyfPos = this._font.loca.offsets[this.id];
              var nextPos = this._font.loca.offsets[this.id + 1];

              if (glyfPos === nextPos) {
                return null;
              }

              var stream = this._font._getTableStream('glyf');

              stream.pos += glyfPos;
              var startPos = stream.pos;
              var glyph = GlyfHeader.decode(stream);

              if (glyph.numberOfContours > 0) {
                this._decodeSimple(glyph, stream);
              } else if (glyph.numberOfContours < 0) {
                this._decodeComposite(glyph, stream, startPos);
              }

              return glyph;
            };

            _proto2._decodeSimple = function _decodeSimple(glyph, stream) {
              glyph.points = [];
              var endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);
              glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);
              var flags = [];
              var numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;

              while (flags.length < numCoords) {
                var flag = stream.readUInt8();
                flags.push(flag);

                if (flag & REPEAT) {
                  var count = stream.readUInt8();

                  for (var j = 0; j < count; j++) {
                    flags.push(flag);
                  }
                }
              }

              for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                var point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
                glyph.points.push(point);
              }

              var px = 0;

              for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);
              }

              var py = 0;

              for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);
              }

              if (this._font._variationProcessor) {
                var points = glyph.points.slice();
                points.push.apply(points, this._getPhantomPoints(glyph));

                this._font._variationProcessor.transformPoints(this.id, points);

                glyph.phantomPoints = points.slice(-4);
              }

              return;
            };

            _proto2._decodeComposite = function _decodeComposite(glyph, stream, offset) {
              if (offset === void 0) {
                offset = 0;
              }

              glyph.components = [];
              var haveInstructions = false;
              var flags = MORE_COMPONENTS;

              while (flags & MORE_COMPONENTS) {
                flags = stream.readUInt16BE();
                var gPos = stream.pos - offset;
                var glyphID = stream.readUInt16BE();

                if (!haveInstructions) {
                  haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;
                }

                if (flags & ARG_1_AND_2_ARE_WORDS) {
                  var dx = stream.readInt16BE();
                  var dy = stream.readInt16BE();
                } else {
                  var dx = stream.readInt8();
                  var dy = stream.readInt8();
                }

                var component = new Component(glyphID, dx, dy);
                component.pos = gPos;

                if (flags & WE_HAVE_A_SCALE) {
                  component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                  component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                  component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                  component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                  component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                  component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                  component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                }

                glyph.components.push(component);
              }

              if (this._font._variationProcessor) {
                var points = [];

                for (var j = 0; j < glyph.components.length; j++) {
                  var component = glyph.components[j];
                  points.push(new Point(true, true, component.dx, component.dy));
                }

                points.push.apply(points, this._getPhantomPoints(glyph));

                this._font._variationProcessor.transformPoints(this.id, points);

                glyph.phantomPoints = points.splice(-4, 4);

                for (var i = 0; i < points.length; i++) {
                  var point = points[i];
                  glyph.components[i].dx = point.x;
                  glyph.components[i].dy = point.y;
                }
              }

              return haveInstructions;
            };

            _proto2._getPhantomPoints = function _getPhantomPoints(glyph) {
              var cbox = this._getCBox(true);

              if (this._metrics == null) {
                this._metrics = Glyph.prototype._getMetrics.call(this, cbox);
              }

              var _this$_metrics = this._metrics,
                advanceWidth = _this$_metrics.advanceWidth,
                advanceHeight = _this$_metrics.advanceHeight,
                leftBearing = _this$_metrics.leftBearing,
                topBearing = _this$_metrics.topBearing;
              return [new Point(false, true, glyph.xMin - leftBearing, 0), new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0), new Point(false, true, 0, glyph.yMax + topBearing), new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)];
            };

            _proto2._getContours = function _getContours() {
              var glyph = this._decode();

              if (!glyph) {
                return [];
              }

              var points = [];

              if (glyph.numberOfContours < 0) {
                for (var _iterator = _createForOfIteratorHelperLoose(glyph.components), _step; !(_step = _iterator()).done;) {
                  var component = _step.value;

                  var _contours = this._font.getGlyph(component.glyphID)._getContours();

                  for (var i = 0; i < _contours.length; i++) {
                    var contour = _contours[i];

                    for (var j = 0; j < contour.length; j++) {
                      var _point = contour[j];
                      var x = _point.x * component.scaleX + _point.y * component.scale01 + component.dx;
                      var y = _point.y * component.scaleY + _point.x * component.scale10 + component.dy;
                      points.push(new Point(_point.onCurve, _point.endContour, x, y));
                    }
                  }
                }
              } else {
                points = glyph.points || [];
              }

              if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
                this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
                this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
                this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
                this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
              }

              var contours = [];
              var cur = [];

              for (var k = 0; k < points.length; k++) {
                var point = points[k];
                cur.push(point);

                if (point.endContour) {
                  contours.push(cur);
                  cur = [];
                }
              }

              return contours;
            };

            _proto2._getMetrics = function _getMetrics() {
              if (this._metrics) {
                return this._metrics;
              }

              var cbox = this._getCBox(true);

              _Glyph.prototype._getMetrics.call(this, cbox);

              if (this._font._variationProcessor && !this._font.HVAR) {
                this.path;
              }

              return this._metrics;
            };

            _proto2._getPath = function _getPath() {
              var contours = this._getContours();

              var path = new Path();

              for (var i = 0; i < contours.length; i++) {
                var contour = contours[i];
                var firstPt = contour[0];
                var lastPt = contour[contour.length - 1];
                var start = 0;

                if (firstPt.onCurve) {
                  var curvePt = null;
                  start = 1;
                } else {
                  if (lastPt.onCurve) {
                    firstPt = lastPt;
                  } else {
                    firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
                  }

                  var curvePt = firstPt;
                }

                path.moveTo(firstPt.x, firstPt.y);

                for (var j = start; j < contour.length; j++) {
                  var pt = contour[j];
                  var prevPt = j === 0 ? firstPt : contour[j - 1];

                  if (prevPt.onCurve && pt.onCurve) {
                    path.lineTo(pt.x, pt.y);
                  } else if (prevPt.onCurve && !pt.onCurve) {
                    var curvePt = pt;
                  } else if (!prevPt.onCurve && !pt.onCurve) {
                    var midX = (prevPt.x + pt.x) / 2;
                    var midY = (prevPt.y + pt.y) / 2;
                    path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
                    var curvePt = pt;
                  } else if (!prevPt.onCurve && pt.onCurve) {
                    path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                    var curvePt = null;
                  } else {
                    throw new Error('Unknown TTF path state');
                  }
                }

                if (curvePt) {
                  path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
                }

                path.closePath();
              }

              return path;
            };

            return TTFGlyph;
          }(Glyph);

          var resolved = _Promise.resolve();

          var Subset = function () {
            function Subset(font) {
              this.font = font;
              this.glyphs = [];
              this.mapping = {};
              this.includeGlyph(0);
            }

            var _proto = Subset.prototype;

            _proto.includeGlyph = function includeGlyph(glyph) {
              if (typeof glyph === 'object') {
                glyph = glyph.id;
              }

              if (this.mapping[glyph] == null) {
                this.glyphs.push(glyph);
                this.mapping[glyph] = this.glyphs.length - 1;
              }

              return this.mapping[glyph];
            };

            _proto.encodeStream = function encodeStream() {
              var _this = this;

              var s = new r.EncodeStream();
              resolved.then(function () {
                _this.encode(s);

                return s.end();
              });
              return s;
            };

            return Subset;
          }();

          var ON_CURVE$1 = 1 << 0;
          var X_SHORT_VECTOR$1 = 1 << 1;
          var Y_SHORT_VECTOR$1 = 1 << 2;
          var REPEAT$1 = 1 << 3;
          var SAME_X$1 = 1 << 4;
          var SAME_Y$1 = 1 << 5;

          var Point$1 = function () {
            function Point() { }

            (<any>Point).size = function size(val) {
              return val >= 0 && val <= 255 ? 1 : 2;
            };

            (<any>Point).encode = function encode(stream, value) {
              if (value >= 0 && value <= 255) {
                stream.writeUInt8(value);
              } else {
                stream.writeInt16BE(value);
              }
            };

            return Point;
          }();

          var Glyf = new r.Struct({
            numberOfContours: r.int16,
            xMin: r.int16,
            yMin: r.int16,
            xMax: r.int16,
            yMax: r.int16,
            endPtsOfContours: new r.Array(r.uint16, 'numberOfContours'),
            instructions: new r.Array(r.uint8, r.uint16),
            flags: new r.Array(r.uint8, 0),
            xPoints: new r.Array(Point$1, 0),
            yPoints: new r.Array(Point$1, 0)
          });

          var TTFGlyphEncoder = function () {
            function TTFGlyphEncoder() { }

            var _proto = TTFGlyphEncoder.prototype;

            _proto.encodeSimple = function encodeSimple(path, instructions) {
              if (instructions === void 0) {
                instructions = [];
              }

              var endPtsOfContours = [];
              var xPoints = [];
              var yPoints = [];
              var flags = [];
              var same = 0;
              var lastX = 0,
                lastY = 0,
                lastFlag = 0;
              var pointCount = 0;

              for (var i = 0; i < path.commands.length; i++) {
                var c = path.commands[i];

                for (var j = 0; j < c.args.length; j += 2) {
                  var x = c.args[j];
                  var y = c.args[j + 1];
                  var flag = 0;

                  if (c.command === 'quadraticCurveTo' && j === 2) {
                    var next = path.commands[i + 1];

                    if (next && next.command === 'quadraticCurveTo') {
                      var midX = (lastX + next.args[0]) / 2;
                      var midY = (lastY + next.args[1]) / 2;

                      if (x === midX && y === midY) {
                        continue;
                      }
                    }
                  }

                  if (!(c.command === 'quadraticCurveTo' && j === 0)) {
                    flag |= ON_CURVE$1;
                  }

                  flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR$1, SAME_X$1);
                  flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR$1, SAME_Y$1);

                  if (flag === lastFlag && same < 255) {
                    flags[flags.length - 1] |= REPEAT$1;
                    same++;
                  } else {
                    if (same > 0) {
                      flags.push(same);
                      same = 0;
                    }

                    flags.push(flag);
                    lastFlag = flag;
                  }

                  lastX = x;
                  lastY = y;
                  pointCount++;
                }

                if (c.command === 'closePath') {
                  endPtsOfContours.push(pointCount - 1);
                }
              }

              if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') {
                endPtsOfContours.push(pointCount - 1);
              }

              var bbox = path.bbox;
              var glyf = {
                numberOfContours: endPtsOfContours.length,
                xMin: bbox.minX,
                yMin: bbox.minY,
                xMax: bbox.maxX,
                yMax: bbox.maxY,
                endPtsOfContours: endPtsOfContours,
                instructions: instructions,
                flags: flags,
                xPoints: xPoints,
                yPoints: yPoints
              };
              var size = Glyf.size(glyf);
              var tail = 4 - size % 4;
              var stream = new r.EncodeStream(size + tail);
              Glyf.encode(stream, glyf);

              if (tail !== 0) {
                stream.fill(0, tail);
              }

              return stream.buffer;
            };

            _proto._encodePoint = function _encodePoint(value, last, points, flag, shortFlag, sameFlag) {
              var diff = value - last;

              if (value === last) {
                flag |= sameFlag;
              } else {
                if (-255 <= diff && diff <= 255) {
                  flag |= shortFlag;

                  if (diff < 0) {
                    diff = -diff;
                  } else {
                    flag |= sameFlag;
                  }
                }

                points.push(diff);
              }

              return flag;
            };

            return TTFGlyphEncoder;
          }();

          var TTFSubset = function (_Subset) {
            _inheritsLoose(TTFSubset, _Subset);

            function TTFSubset(font): void {
              var _this;

              _this = _Subset.call(this, font) || this;
              _this.glyphEncoder = new TTFGlyphEncoder();
              return _this;
            }

            var _proto = TTFSubset.prototype;

            _proto._addGlyph = function _addGlyph(gid) {
              var glyph = this.font.getGlyph(gid);

              var glyf = glyph._decode();

              var curOffset = this.font.loca.offsets[gid];
              var nextOffset = this.font.loca.offsets[gid + 1];

              var stream = this.font._getTableStream('glyf');

              stream.pos += curOffset;
              var buffer = stream.readBuffer(nextOffset - curOffset);

              if (glyf && glyf.numberOfContours < 0) {
                buffer = new Buffer(buffer);

                for (var _iterator = _createForOfIteratorHelperLoose(glyf.components), _step; !(_step = _iterator()).done;) {
                  var component = _step.value;
                  gid = this.includeGlyph(component.glyphID);
                  buffer.writeUInt16BE(gid, component.pos);
                }
              } else if (glyf && this.font._variationProcessor) {
                buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
              }

              this.glyf.push(buffer);
              this.loca.offsets.push(this.offset);
              this.hmtx.metrics.push({
                advance: glyph.advanceWidth,
                bearing: glyph._getMetrics().leftBearing
              });
              this.offset += buffer.length;
              return this.glyf.length - 1;
            };

            _proto.encode = function encode(stream) {
              this.glyf = [];
              this.offset = 0;
              this.loca = {
                offsets: [],
                version: this.font.loca.version
              };
              this.hmtx = {
                metrics: [],
                bearings: []
              };
              var i = 0;

              while (i < this.glyphs.length) {
                this._addGlyph(this.glyphs[i++]);
              }

              var maxp = cloneDeep(this.font.maxp);
              maxp.numGlyphs = this.glyf.length;
              this.loca.offsets.push(this.offset);
              var head = cloneDeep(this.font.head);
              head.indexToLocFormat = this.loca.version;
              var hhea = cloneDeep(this.font.hhea);
              hhea.numberOfMetrics = this.hmtx.metrics.length;
              Directory.encode(stream, {
                tables: {
                  head: head,
                  hhea: hhea,
                  loca: this.loca,
                  maxp: maxp,
                  'cvt ': this.font['cvt '],
                  prep: this.font.prep,
                  glyf: this.glyf,
                  hmtx: this.hmtx,
                  fpgm: this.font.fpgm
                }
              });
            };

            return TTFSubset;
          }(Subset);

          var _class$2;

          var TTFFont = (_class$2 = function () {
            (<any>TTFFont).probe = function probe(buffer) {
              var format = buffer.toString('ascii', 0, 4);
              return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);
            };

            function TTFFont(stream, variationCoords) {
              if (variationCoords === void 0) {
                variationCoords = null;
              }

              this.defaultLanguage = null;
              this.stream = stream;
              this.variationCoords = variationCoords;
              this._directoryPos = this.stream.pos;
              this._tables = {};
              this._glyphs = {};

              this._decodeDirectory();

              for (var tag in this.directory.tables) {
                var table = this.directory.tables[tag];

                if (tables[tag] && table.length > 0) {
                  _Object$defineProperty(this, tag, {
                    get: this._getTable.bind(this, table)
                  });
                }
              }
            }

            var _proto = TTFFont.prototype;

            _proto.setDefaultLanguage = function setDefaultLanguage(lang) {
              if (lang === void 0) {
                lang = null;
              }

              this.defaultLanguage = lang;
            };

            _proto._getTable = function _getTable(table) {
              if (!(table.tag in this._tables)) {
                try {
                  this._tables[table.tag] = this._decodeTable(table);
                } catch (e) {
                  if (fontkit.logErrors) {
                    console.error('Error decoding table ' + table.tag);
                    console.error(e.stack);
                  }
                }
              }

              return this._tables[table.tag];
            };

            _proto._getTableStream = function _getTableStream(tag) {
              var table = this.directory.tables[tag];

              if (table) {
                this.stream.pos = table.offset;
                return this.stream;
              }

              return null;
            };

            _proto._decodeDirectory = function _decodeDirectory() {
              return this.directory = Directory.decode(this.stream, {
                _startOffset: 0
              });
            };

            _proto._decodeTable = function _decodeTable(table) {
              var pos = this.stream.pos;

              var stream = this._getTableStream(table.tag);

              var result = tables[table.tag].decode(stream, this, table.length);
              this.stream.pos = pos;
              return result;
            };

            _proto.getName = function getName(key, lang) {
              if (lang === void 0) {
                lang = this.defaultLanguage || fontkit.defaultLanguage;
              }

              var record = this.name && this.name.records[key];

              if (record) {
                return record[lang] || record[this.defaultLanguage] || record[fontkit.defaultLanguage] || record['en'] || record[_Object$keys(record)[0]] || null;
              }

              return null;
            };

            _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {
              return !!this._cmapProcessor.lookup(codePoint);
            };

            _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {
              return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
            };

            _proto.glyphsForString = function glyphsForString(string) {
              var glyphs = [];
              var len = string.length;
              var idx = 0;
              var last = -1;
              var state = -1;

              while (idx <= len) {
                var code = 0;
                var nextState = 0;

                if (idx < len) {
                  code = string.charCodeAt(idx++);

                  if (55296 <= code && code <= 56319 && idx < len) {
                    var next = string.charCodeAt(idx);

                    if (56320 <= next && next <= 57343) {
                      idx++;
                      code = ((code & 1023) << 10) + (next & 1023) + 65536;
                    }
                  }

                  nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
                } else {
                  idx++;
                }

                if (state === 0 && nextState === 1) {
                  glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [last, code]));
                } else if (state === 0 && nextState === 0) {
                  glyphs.push(this.glyphForCodePoint(last));
                }

                last = code;
                state = nextState;
              }

              return glyphs;
            };

            _proto.layout = function layout(string, userFeatures, script, language, direction) {
              return this._layoutEngine.layout(string, userFeatures, script, language, direction);
            };

            _proto.stringsForGlyph = function stringsForGlyph(gid) {
              return this._layoutEngine.stringsForGlyph(gid);
            };

            _proto.getAvailableFeatures = function getAvailableFeatures(script, language) {
              return this._layoutEngine.getAvailableFeatures(script, language);
            };

            _proto._getBaseGlyph = function _getBaseGlyph(glyph, characters) {
              if (characters === void 0) {
                characters = [];
              }

              if (!this._glyphs[glyph]) {
                if (this.directory.tables.glyf) {
                  this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);
                }
              }

              return this._glyphs[glyph] || null;
            };

            _proto.getGlyph = function getGlyph(glyph, characters) {
              if (characters === void 0) {
                characters = [];
              }

              if (!this._glyphs[glyph]) {
                this._getBaseGlyph(glyph, characters);
              }

              return this._glyphs[glyph] || null;
            };

            _proto.createSubset = function createSubset() {
              return new TTFSubset(this);
            };

            _proto.getVariation = function getVariation(settings) {
              if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) {
                throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');
              }

              if (typeof settings === 'string') {
                settings = this.namedVariations[settings];
              }

              if (typeof settings !== 'object') {
                throw new Error('Variation settings must be either a variation name or settings object.');
              }

              var coords = this.fvar.axis.map(function (axis, i) {
                var axisTag = axis.axisTag.trim();

                if (axisTag in settings) {
                  return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
                } else {
                  return axis.defaultValue;
                }
              });
              var stream = new r.DecodeStream(this.stream.buffer);
              stream.pos = this._directoryPos;
              var font = new TTFFont(stream, coords);
              font._tables = this._tables;
              return font;
            };

            _proto.getFont = function getFont(name) {
              return this.getVariation(name);
            };

            _createClass(TTFFont, [{
              key: 'postscriptName',
              get: function get() {
                return this.getName('postscriptName');
              }
            }, {
              key: 'fullName',
              get: function get() {
                return this.getName('fullName');
              }
            }, {
              key: 'familyName',
              get: function get() {
                return this.getName('fontFamily');
              }
            }, {
              key: 'subfamilyName',
              get: function get() {
                return this.getName('fontSubfamily');
              }
            }, {
              key: 'copyright',
              get: function get() {
                return this.getName('copyright');
              }
            }, {
              key: 'version',
              get: function get() {
                return this.getName('version');
              }
            }, {
              key: 'ascent',
              get: function get() {
                return this.hhea.ascent;
              }
            }, {
              key: 'descent',
              get: function get() {
                return this.hhea.descent;
              }
            }, {
              key: 'lineGap',
              get: function get() {
                return this.hhea.lineGap;
              }
            }, {
              key: 'underlinePosition',
              get: function get() {
                return this.post.underlinePosition;
              }
            }, {
              key: 'underlineThickness',
              get: function get() {
                return this.post.underlineThickness;
              }
            }, {
              key: 'italicAngle',
              get: function get() {
                return this.post.italicAngle;
              }
            }, {
              key: 'capHeight',
              get: function get() {
                var os2 = this['OS/2'];
                return os2 ? os2.capHeight : this.ascent;
              }
            }, {
              key: 'xHeight',
              get: function get() {
                var os2 = this['OS/2'];
                return os2 ? os2.xHeight : 0;
              }
            }, {
              key: 'numGlyphs',
              get: function get() {
                return this.maxp.numGlyphs;
              }
            }, {
              key: 'unitsPerEm',
              get: function get() {
                return this.head.unitsPerEm;
              }
            }, {
              key: 'bbox',
              get: function get() {
                return _Object$freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
              }
            }, {
              key: '_cmapProcessor',
              get: function get() {
                return new CmapProcessor(this.cmap);
              }
            }, {
              key: 'characterSet',
              get: function get() {
                return this._cmapProcessor.getCharacterSet();
              }
            }, {
              key: '_layoutEngine',
              get: function get() {
                return new LayoutEngine(this);
              }
            }, {
              key: 'availableFeatures',
              get: function get() {
                return this._layoutEngine.getAvailableFeatures();
              }
            }, {
              key: 'variationAxes',
              get: function get() {
                var res = {};

                if (!this.fvar) {
                  return res;
                }

                for (var _iterator = _createForOfIteratorHelperLoose(this.fvar.axis), _step; !(_step = _iterator()).done;) {
                  var axis = _step.value;
                  res[axis.axisTag.trim()] = {
                    name: axis.name.en,
                    min: axis.minValue,
                    default: axis.defaultValue,
                    max: axis.maxValue
                  };
                }

                return res;
              }
            }, {
              key: 'namedVariations',
              get: function get() {
                var res = {};

                if (!this.fvar) {
                  return res;
                }

                for (var _iterator2 = _createForOfIteratorHelperLoose(this.fvar.instance), _step2; !(_step2 = _iterator2()).done;) {
                  var instance = _step2.value;
                  var settings = {};

                  for (var i = 0; i < this.fvar.axis.length; i++) {
                    var axis = this.fvar.axis[i];
                    settings[axis.axisTag.trim()] = instance.coord[i];
                  }

                  res[instance.name.en] = settings;
                }

                return res;
              }
            }, {
              key: '_variationProcessor',
              get: function get() {
                return null;
              }
            }]);

            return TTFFont;
          }(), (_applyDecoratedDescriptor(_class$2.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, 'bbox'), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, '_cmapProcessor', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, '_cmapProcessor'), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, 'characterSet', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, 'characterSet'), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, '_layoutEngine', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, '_layoutEngine'), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, 'variationAxes', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, 'variationAxes'), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, 'namedVariations', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, 'namedVariations'), _class$2.prototype), _applyDecoratedDescriptor(_class$2.prototype, '_variationProcessor', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, '_variationProcessor'), _class$2.prototype)), _class$2);
          var TTCHeader = new r.VersionedStruct(r.uint32, {
            65536: {
              numFonts: r.uint32,
              offsets: new r.Array(r.uint32, 'numFonts')
            },
            131072: {
              numFonts: r.uint32,
              offsets: new r.Array(r.uint32, 'numFonts'),
              dsigTag: r.uint32,
              dsigLength: r.uint32,
              dsigOffset: r.uint32
            }
          });

          var TrueTypeCollection = function () {
            (<any>TrueTypeCollection).probe = function probe(buffer) {
              return buffer.toString('ascii', 0, 4) === 'ttcf';
            };

            function TrueTypeCollection(stream) {
              this.stream = stream;

              if (stream.readString(4) !== 'ttcf') {
                throw new Error('Not a TrueType collection');
              }

              this.header = TTCHeader.decode(stream);
            }

            var _proto = TrueTypeCollection.prototype;

            _proto.getFont = function getFont(name) {
              for (var _iterator = _createForOfIteratorHelperLoose(this.header.offsets), _step; !(_step = _iterator()).done;) {
                var offset = _step.value;
                var stream = new r.DecodeStream(this.stream.buffer);
                stream.pos = offset;
                var font = new TTFFont(stream);

                if (font.postscriptName === name) {
                  return font;
                }
              }

              return null;
            };

            _createClass(TrueTypeCollection, [{
              key: 'fonts',
              get: function get() {
                var fonts = [];

                for (var _iterator2 = _createForOfIteratorHelperLoose(this.header.offsets), _step2; !(_step2 = _iterator2()).done;) {
                  var offset = _step2.value;
                  var stream = new r.DecodeStream(this.stream.buffer);
                  stream.pos = offset;
                  fonts.push(new TTFFont(stream));
                }

                return fonts;
              }
            }]);

            return TrueTypeCollection;
          }();

          var DFontName = new r.String(r.uint8);
          var DFontData = new r.Struct({
            len: r.uint32,
            buf: new r.Buffer('len')
          });
          var Ref = new r.Struct({
            id: r.uint16,
            nameOffset: r.int16,
            attr: r.uint8,
            dataOffset: r.uint24,
            handle: r.uint32
          });
          var Type = new r.Struct({
            name: new r.String(4),
            maxTypeIndex: r.uint16,
            refList: new r.Pointer(r.uint16, new r.Array(Ref, function (t) {
              return t.maxTypeIndex + 1;
            }), {
              type: 'parent'
            })
          });
          var TypeList = new r.Struct({
            length: r.uint16,
            types: new r.Array(Type, function (t) {
              return t.length + 1;
            })
          });
          var DFontMap = new r.Struct({
            reserved: new r.Reserved(r.uint8, 24),
            typeList: new r.Pointer(r.uint16, TypeList),
            nameListOffset: new r.Pointer(r.uint16, 'void')
          });
          var DFontHeader = new r.Struct({
            dataOffset: r.uint32,
            map: new r.Pointer(r.uint32, DFontMap),
            dataLength: r.uint32,
            mapLength: r.uint32
          });

          var DFont = function () {
            (<any>DFont).probe = function probe(buffer) {
              var stream = new r.DecodeStream(buffer);

              try {
                var header = DFontHeader.decode(stream);
              } catch (e) {
                return false;
              }

              for (var _iterator = _createForOfIteratorHelperLoose(header.map.typeList.types), _step; !(_step = _iterator()).done;) {
                var type = _step.value;

                if (type.name === 'sfnt') {
                  return true;
                }
              }

              return false;
            };

            function DFont(stream) {
              this.stream = stream;
              this.header = DFontHeader.decode(this.stream);

              for (var _iterator2 = _createForOfIteratorHelperLoose(this.header.map.typeList.types), _step2; !(_step2 = _iterator2()).done;) {
                var type = _step2.value;

                for (var _iterator3 = _createForOfIteratorHelperLoose(type.refList), _step3; !(_step3 = _iterator3()).done;) {
                  var ref = _step3.value;

                  if (ref.nameOffset >= 0) {
                    this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
                    ref.name = DFontName.decode(this.stream);
                  } else {
                    ref.name = null;
                  }
                }

                if (type.name === 'sfnt') {
                  this.sfnt = type;
                }
              }
            }

            var _proto = DFont.prototype;

            _proto.getFont = function getFont(name) {
              if (!this.sfnt) {
                return null;
              }

              for (var _iterator4 = _createForOfIteratorHelperLoose(this.sfnt.refList), _step4; !(_step4 = _iterator4()).done;) {
                var ref = _step4.value;
                var pos = this.header.dataOffset + ref.dataOffset + 4;
                var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                var font = new TTFFont(stream);

                if (font.postscriptName === name) {
                  return font;
                }
              }

              return null;
            };

            _createClass(DFont, [{
              key: 'fonts',
              get: function get() {
                var fonts = [];

                for (var _iterator5 = _createForOfIteratorHelperLoose(this.sfnt.refList), _step5; !(_step5 = _iterator5()).done;) {
                  var ref = _step5.value;
                  var pos = this.header.dataOffset + ref.dataOffset + 4;
                  var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                  fonts.push(new TTFFont(stream));
                }

                return fonts;
              }
            }]);

            return DFont;
          }();

          fontkit.registerFormat(TTFFont);
          fontkit.registerFormat(TrueTypeCollection);
          fontkit.registerFormat(DFont);
          localModule.localExports = fontkit;
        }).call(this);
      }).call(this, localRequire("buffer").Buffer);
    }, {
      "@babel/runtime-corejs2/core-js/array/from": 2,
      "@babel/runtime-corejs2/core-js/array/is-array": 3,
      "@babel/runtime-corejs2/core-js/map": 4,
      "@babel/runtime-corejs2/core-js/object/define-property": 5,
      "@babel/runtime-corejs2/core-js/object/freeze": 6,
      "@babel/runtime-corejs2/core-js/object/get-own-property-descriptor": 7,
      "@babel/runtime-corejs2/core-js/object/keys": 8,
      "@babel/runtime-corejs2/core-js/promise": 9,
      "@babel/runtime-corejs2/core-js/set": 10,
      "@babel/runtime-corejs2/core-js/string/from-code-point": 11,
      "buffer": 152,
      "clone": 123,
      "iconv-lite": 151,
      "restructure": 251,
      "unicode-properties": 125
    }],
    2: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/array/from");
    }, {
      "core-js/library/fn/array/from": 12
    }],
    3: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/array/is-array");
    }, {
      "core-js/library/fn/array/is-array": 13
    }],
    4: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/map");
    }, {
      "core-js/library/fn/map": 14
    }],
    5: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/object/define-property");
    }, {
      "core-js/library/fn/object/define-property": 15
    }],
    6: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/object/freeze");
    }, {
      "core-js/library/fn/object/freeze": 16
    }],
    7: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/object/get-own-property-descriptor");
    }, {
      "core-js/library/fn/object/get-own-property-descriptor": 17
    }],
    8: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/object/keys");
    }, {
      "core-js/library/fn/object/keys": 18
    }],
    9: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/promise");
    }, {
      "core-js/library/fn/promise": 19
    }],
    10: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/set");
    }, {
      "core-js/library/fn/set": 20
    }],
    11: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/string/from-code-point");
    }, {
      "core-js/library/fn/string/from-code-point": 21
    }],
    12: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.string.iterator');
      localRequire('../../modules/es6.array.from');
      localModule.localExports = localRequire('../../modules/_core').Array.from;
    }, {
      "../../modules/_core": 36,
      "../../modules/es6.array.from": 100,
      "../../modules/es6.string.iterator": 112
    }],
    13: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.array.is-array');
      localModule.localExports = localRequire('../../modules/_core').Array.isArray;
    }, {
      "../../modules/_core": 36,
      "../../modules/es6.array.is-array": 101
    }],
    14: [function (localRequire, localModule, localExports) {
      localRequire('../modules/es6.object.to-string');
      localRequire('../modules/es6.string.iterator');
      localRequire('../modules/web.dom.iterable');
      localRequire('../modules/es6.map');
      localRequire('../modules/es7.map.to-json');
      localRequire('../modules/es7.map.of');
      localRequire('../modules/es7.map.from');
      localModule.localExports = localRequire('../modules/_core').Map;
    }, {
      "../modules/_core": 36,
      "../modules/es6.map": 103,
      "../modules/es6.object.to-string": 108,
      "../modules/es6.string.iterator": 112,
      "../modules/es7.map.from": 113,
      "../modules/es7.map.of": 114,
      "../modules/es7.map.to-json": 115,
      "../modules/web.dom.iterable": 121
    }],
    15: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.object.define-property');
      var $Object = localRequire('../../modules/_core').Object;

      localModule.localExports = function defineProperty(it, key, desc) {
        return $Object.defineProperty(it, key, desc);
      };
    }, {
      "../../modules/_core": 36,
      "../../modules/es6.object.define-property": 104
    }],
    16: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.object.freeze');
      localModule.localExports = localRequire('../../modules/_core').Object.freeze;
    }, {
      "../../modules/_core": 36,
      "../../modules/es6.object.freeze": 105
    }],
    17: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.object.get-own-property-descriptor');
      var $Object = localRequire('../../modules/_core').Object;

      localModule.localExports = function getOwnPropertyDescriptor(it, key) {
        return $Object.getOwnPropertyDescriptor(it, key);
      };
    }, {
      "../../modules/_core": 36,
      "../../modules/es6.object.get-own-property-descriptor": 106
    }],
    18: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.object.keys');
      localModule.localExports = localRequire('../../modules/_core').Object.keys;
    }, {
      "../../modules/_core": 36,
      "../../modules/es6.object.keys": 107
    }],
    19: [function (localRequire, localModule, localExports) {
      localRequire('../modules/es6.object.to-string');
      localRequire('../modules/es6.string.iterator');
      localRequire('../modules/web.dom.iterable');
      localRequire('../modules/es6.promise');
      localRequire('../modules/es7.promise.finally');
      localRequire('../modules/es7.promise.try');
      localModule.localExports = localRequire('../modules/_core').Promise;
    }, {
      "../modules/_core": 36,
      "../modules/es6.object.to-string": 108,
      "../modules/es6.promise": 109,
      "../modules/es6.string.iterator": 112,
      "../modules/es7.promise.finally": 116,
      "../modules/es7.promise.try": 117,
      "../modules/web.dom.iterable": 121
    }],
    20: [function (localRequire, localModule, localExports) {
      localRequire('../modules/es6.object.to-string');
      localRequire('../modules/es6.string.iterator');
      localRequire('../modules/web.dom.iterable');
      localRequire('../modules/es6.set');
      localRequire('../modules/es7.set.to-json');
      localRequire('../modules/es7.set.of');
      localRequire('../modules/es7.set.from');
      localModule.localExports = localRequire('../modules/_core').Set;
    }, {
      "../modules/_core": 36,
      "../modules/es6.object.to-string": 108,
      "../modules/es6.set": 110,
      "../modules/es6.string.iterator": 112,
      "../modules/es7.set.from": 118,
      "../modules/es7.set.of": 119,
      "../modules/es7.set.to-json": 120,
      "../modules/web.dom.iterable": 121
    }],
    21: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.string.from-code-point');
      localModule.localExports = localRequire('../../modules/_core').String.fromCodePoint;
    }, {
      "../../modules/_core": 36,
      "../../modules/es6.string.from-code-point": 111
    }],
    22: [function (localRequire, localModule, localExports) {
      localModule.localExports = function (it) {
        if (typeof it != 'function') throw TypeError(it + ' is not a function!');
        return it;
      };
    }, {}],
    23: [function (localRequire, localModule, localExports) {
      localModule.localExports = function () {
        /* empty */
      };
    }, {}],
    24: [function (localRequire, localModule, localExports) {
      localModule.localExports = function (it, Constructor, name, forbiddenField) {
        if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
          throw TypeError(name + ': incorrect invocation!');
        }

        return it;
      };
    }, {}],
    25: [function (localRequire, localModule, localExports) {
      var isObject = localRequire('./_is-object');

      localModule.localExports = function (it) {
        if (!isObject(it)) throw TypeError(it + ' is not an object!');
        return it;
      };
    }, {
      "./_is-object": 55
    }],
    26: [function (localRequire, localModule, localExports) {
      var forOf = localRequire('./_for-of');

      localModule.localExports = function (iter, ITERATOR) {
        var result = [];
        forOf(iter, false, result.push, result, ITERATOR);
        return result;
      };
    }, {
      "./_for-of": 45
    }],
    27: [function (localRequire, localModule, localExports) {
      // false -> Array#indexOf
      // true  -> Array#includes
      var toIObject = localRequire('./_to-iobject');
      var toLength = localRequire('./_to-length');
      var toAbsoluteIndex = localRequire('./_to-absolute-index');

      localModule.localExports = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          var O = toIObject($this);
          var length = toLength(O.length);
          var index = toAbsoluteIndex(fromIndex, length);
          var value; // Array#includes uses SameValueZero equality algorithm
          // eslint-disable-next-line no-self-compare

          if (IS_INCLUDES && el != el) while (length > index) {
            value = O[index++]; // eslint-disable-next-line no-self-compare

            if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
          } else for (; length > index; index++) {
            if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
          }
          return !IS_INCLUDES && -1;
        };
      };
    }, {
      "./_to-absolute-index": 89,
      "./_to-iobject": 91,
      "./_to-length": 92
    }],
    28: [function (localRequire, localModule, localExports) {
      // 0 -> Array#forEach
      // 1 -> Array#map
      // 2 -> Array#filter
      // 3 -> Array#some
      // 4 -> Array#every
      // 5 -> Array#find
      // 6 -> Array#findIndex
      var ctx = localRequire('./_ctx');
      var IObject = localRequire('./_iobject');
      var toObject = localRequire('./_to-object');
      var toLength = localRequire('./_to-length');
      var asc = localRequire('./_array-species-create');

      localModule.localExports = function (TYPE, $create) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        var create = $create || asc;
        return function ($this, callbackfn, that) {
          var O = toObject($this);
          var self = IObject(O);
          var f = ctx(callbackfn, that, 3);
          var length = toLength(self.length);
          var index = 0;
          var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
          var val, res;

          for (; length > index; index++) {
            if (NO_HOLES || index in self) {
              val = self[index];
              res = f(val, index, O);

              if (TYPE) {
                if (IS_MAP) result[index] = res; // map
                else if (res) switch (TYPE) {
                  case 3:
                    return true;
                  // some

                  case 5:
                    return val;
                  // find

                  case 6:
                    return index;
                  // findIndex

                  case 2:
                    result.push(val);
                  // filter
                } else if (IS_EVERY) return false; // every
              }
            }
          }

          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
        };
      };
    }, {
      "./_array-species-create": 30,
      "./_ctx": 38,
      "./_iobject": 52,
      "./_to-length": 92,
      "./_to-object": 93
    }],
    29: [function (localRequire, localModule, localExports) {
      var isObject = localRequire('./_is-object');
      var isArray = localRequire('./_is-array');
      var SPECIES = localRequire('./_wks')('species');

      localModule.localExports = function (original) {
        var C;

        if (isArray(original)) {
          C = original.constructor; // cross-realm fallback

          if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

          if (isObject(C)) {
            C = C[SPECIES];
            if (C === null) C = undefined;
          }
        }

        return C === undefined ? Array : C;
      };
    }, {
      "./_is-array": 54,
      "./_is-object": 55,
      "./_wks": 98
    }],
    30: [function (localRequire, localModule, localExports) {
      // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
      var speciesConstructor = localRequire('./_array-species-constructor');

      localModule.localExports = function (original, length) {
        return new (speciesConstructor(original))(length);
      };
    }, {
      "./_array-species-constructor": 29
    }],
    31: [function (localRequire, localModule, localExports) {
      // getting tag from 19.1.3.6 Object.prototype.toString()
      var cof = localRequire('./_cof');
      var TAG = localRequire('./_wks')('toStringTag'); // ES3 wrong here

      var ARG = cof(function () {
        return arguments;
      }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

      var tryGet = function tryGet(it, key) {
        try {
          return it[key];
        } catch (e) {
          /* empty */
        }
      };

      localModule.localExports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
          : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
            : ARG ? cof(O) // ES3 arguments fallback
              : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
      };
    }, {
      "./_cof": 32,
      "./_wks": 98
    }],
    32: [function (localRequire, localModule, localExports) {
      var toString = {}.toString;

      localModule.localExports = function (it) {
        return toString.call(it).slice(8, -1);
      };
    }, {}],
    33: [function (localRequire, localModule, localExports) {

      var dP = localRequire('./_object-dp').f;
      var create = localRequire('./_object-create');
      var redefineAll = localRequire('./_redefine-all');
      var ctx = localRequire('./_ctx');
      var anInstance = localRequire('./_an-instance');
      var forOf = localRequire('./_for-of');
      var $iterDefine = localRequire('./_iter-define');
      var step = localRequire('./_iter-step');
      var setSpecies = localRequire('./_set-species');
      var DESCRIPTORS = localRequire('./_descriptors');
      var fastKey = localRequire('./_meta').fastKey;
      var validate = localRequire('./_validate-collection');
      var SIZE = DESCRIPTORS ? '_s' : 'size';

      var getEntry = function getEntry(that, key) {
        // fast case
        var index = fastKey(key);
        var entry;
        if (index !== 'F') return that._i[index]; // frozen object case

        for (entry = that._f; entry; entry = entry.n) {
          if (entry.k == key) return entry;
        }
      };

      localModule.localExports = {
        getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
          var C = wrapper(function (that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._t = NAME; // collection type

            that._i = create(null); // index

            that._f = undefined; // first entry

            that._l = undefined; // last entry

            that[SIZE] = 0; // size

            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
          });
          redefineAll(C.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function clear() {
              for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
                entry.r = true;
                if (entry.p) entry.p = entry.p.n = undefined;
                delete data[entry.i];
              }

              that._f = that._l = undefined;
              that[SIZE] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            'delete': function _delete(key) {
              var that = validate(this, NAME);
              var entry = getEntry(that, key);

              if (entry) {
                var next = entry.n;
                var prev = entry.p;
                delete that._i[entry.i];
                entry.r = true;
                if (prev) prev.n = next;
                if (next) next.p = prev;
                if (that._f == entry) that._f = next;
                if (that._l == entry) that._l = prev;
                that[SIZE]--;
              }

              return !!entry;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function forEach(callbackfn
              /* , that = undefined */
            ) {
              validate(this, NAME);
              var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
              var entry;

              while (entry = entry ? entry.n : this._f) {
                f(entry.v, entry.k, this); // revert to the last existing entry

                while (entry && entry.r) {
                  entry = entry.p;
                }
              }
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function has(key) {
              return !!getEntry(validate(this, NAME), key);
            }
          });
          if (DESCRIPTORS) dP(C.prototype, 'size', {
            get: function get() {
              return validate(this, NAME)[SIZE];
            }
          });
          return C;
        },
        def: function def(that, key, value) {
          var entry = getEntry(that, key);
          var prev, index; // change existing entry

          if (entry) {
            entry.v = value; // create new entry
          } else {
            that._l = entry = {
              i: index = fastKey(key, true),
              // <- index
              k: key,
              // <- key
              v: value,
              // <- value
              p: prev = that._l,
              // <- previous entry
              n: undefined,
              // <- next entry
              r: false // <- removed

            };
            if (!that._f) that._f = entry;
            if (prev) prev.n = entry;
            that[SIZE]++; // add to index

            if (index !== 'F') that._i[index] = entry;
          }

          return that;
        },
        getEntry: getEntry,
        setStrong: function setStrong(C, NAME, IS_MAP) {
          // add .keys, .values, .entries, [@@iterator]
          // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
          $iterDefine(C, NAME, function (iterated, kind) {
            this._t = validate(iterated, NAME); // target

            this._k = kind; // kind

            this._l = undefined; // previous
          }, function () {
            var that = this;
            var kind = that._k;
            var entry = that._l; // revert to the last existing entry

            while (entry && entry.r) {
              entry = entry.p;
            } // get next entry


            if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
              // or finish the iteration
              that._t = undefined;
              return step(1);
            } // return step by kind


            if (kind == 'keys') return step(0, entry.k);
            if (kind == 'values') return step(0, entry.v);
            return step(0, [entry.k, entry.v]);
          }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

          setSpecies(NAME);
        }
      };
    }, {
      "./_an-instance": 24,
      "./_ctx": 38,
      "./_descriptors": 40,
      "./_for-of": 45,
      "./_iter-define": 58,
      "./_iter-step": 60,
      "./_meta": 63,
      "./_object-create": 66,
      "./_object-dp": 67,
      "./_redefine-all": 78,
      "./_set-species": 82,
      "./_validate-collection": 97
    }],
    34: [function (localRequire, localModule, localExports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var classof = localRequire('./_classof');
      var from = localRequire('./_array-from-iterable');

      localModule.localExports = function (NAME) {
        return function toJSON() {
          if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
          return from(this);
        };
      };
    }, {
      "./_array-from-iterable": 26,
      "./_classof": 31
    }],
    35: [function (localRequire, localModule, localExports) {

      var global = localRequire('./_global');
      var $export = localRequire('./_export');
      var meta = localRequire('./_meta');
      var fails = localRequire('./_fails');
      var hide = localRequire('./_hide');
      var redefineAll = localRequire('./_redefine-all');
      var forOf = localRequire('./_for-of');
      var anInstance = localRequire('./_an-instance');
      var isObject = localRequire('./_is-object');
      var setToStringTag = localRequire('./_set-to-string-tag');
      var dP = localRequire('./_object-dp').f;
      var each = localRequire('./_array-methods')(0);
      var DESCRIPTORS = localRequire('./_descriptors');

      localModule.localExports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
        var Base = global[NAME];
        var C = Base;
        var ADDER = IS_MAP ? 'set' : 'add';
        var proto = C && C.prototype;
        var O = {};

        if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
          new C().entries().next();
        }))) {
          // create collection constructor
          C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
          redefineAll(C.prototype, methods);
          meta.NEED = true;
        } else {
          C = wrapper(function (target, iterable) {
            anInstance(target, C, NAME, '_c');
            target._c = new Base();
            if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
          });
          each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
            var IS_ADDER = KEY == 'add' || KEY == 'set';
            if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
              anInstance(this, C, KEY);
              if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;

              var result = this._c[KEY](a === 0 ? 0 : a, b);

              return IS_ADDER ? this : result;
            });
          });
          IS_WEAK || dP(C.prototype, 'size', {
            get: function get() {
              return this._c.size;
            }
          });
        }

        setToStringTag(C, NAME);
        O[NAME] = C;
        $export($export.G + $export.W + $export.F, O);
        if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
        return C;
      };
    }, {
      "./_an-instance": 24,
      "./_array-methods": 28,
      "./_descriptors": 40,
      "./_export": 43,
      "./_fails": 44,
      "./_for-of": 45,
      "./_global": 46,
      "./_hide": 48,
      "./_is-object": 55,
      "./_meta": 63,
      "./_object-dp": 67,
      "./_redefine-all": 78,
      "./_set-to-string-tag": 83
    }],
    36: [function (localRequire, localModule, localExports) {
      var core = localModule.localExports = {
        version: '2.6.11'
      };
      //@ts-ignore
      if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
    }, {}],
    37: [function (localRequire, localModule, localExports) {

      var $defineProperty = localRequire('./_object-dp');
      var createDesc = localRequire('./_property-desc');

      localModule.localExports = function (object, index, value) {
        if (index in object) $defineProperty.f(object, index, createDesc(0, value)); else object[index] = value;
      };
    }, {
      "./_object-dp": 67,
      "./_property-desc": 77
    }],
    38: [function (localRequire, localModule, localExports) {
      // optional / simple context binding
      var aFunction = localRequire('./_a-function');

      localModule.localExports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;

        switch (length) {
          case 1:
            return function (a) {
              return fn.call(that, a);
            };

          case 2:
            return function (a, b) {
              return fn.call(that, a, b);
            };

          case 3:
            return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
        }

        return function ()
        /* ...args */ {
          return fn.apply(that, arguments);
        };
      };
    }, {
      "./_a-function": 22
    }],
    39: [function (localRequire, localModule, localExports) {
      // 7.2.1 RequireObjectCoercible(argument)
      localModule.localExports = function (it) {
        if (it == undefined) throw TypeError("Can't call method on  " + it);
        return it;
      };
    }, {}],
    40: [function (localRequire, localModule, localExports) {
      // Thank's IE8 for his funny defineProperty
      localModule.localExports = !localRequire('./_fails')(function () {
        return Object.defineProperty({}, 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "./_fails": 44
    }],
    41: [function (localRequire, localModule, localExports) {
      var isObject = localRequire('./_is-object');
      var document = localRequire('./_global').document; // typeof document.createElement is 'object' in old IE

      var is = isObject(document) && isObject(document.createElement);

      localModule.localExports = function (it) {
        return is ? document.createElement(it) : {};
      };
    }, {
      "./_global": 46,
      "./_is-object": 55
    }],
    42: [function (localRequire, localModule, localExports) {
      // IE 8- don't enum bug keys
      localModule.localExports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
    }, {}],
    43: [function (localRequire, localModule, localExports) {
      var global = localRequire('./_global');
      var core = localRequire('./_core');
      var ctx = localRequire('./_ctx');
      var hide = localRequire('./_hide');
      var has = localRequire('./_has');
      var PROTOTYPE = 'prototype';

      var $export = function $export(type, name, source) {
        var IS_FORCED = type & (<any>$export).F;
        var IS_GLOBAL = type & (<any>$export).G;
        var IS_STATIC = type & (<any>$export).S;
        var IS_PROTO = type & (<any>$export).P;
        var IS_BIND = type & (<any>$export).B;
        var IS_WRAP = type & (<any>$export).W;
        var localExports = IS_GLOBAL ? core : core[name] || (core[name] = {});
        var expProto = localExports[PROTOTYPE];
        var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
        var key, own, out;
        if (IS_GLOBAL) source = name;

        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined;
          if (own && has(localExports, key)) continue; // export native or passed

          out = own ? target[key] : source[key]; // prevent global pollution for namespaces

          localExports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
            : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
              : IS_WRAP && target[key] == out ? function (C) {
                var F = function F(a, b, c) {
                  if (this instanceof C) {
                    switch (arguments.length) {
                      case 0:
                        return new C();

                      case 1:
                        return new C(a);

                      case 2:
                        return new C(a, b);
                    }

                    return new C(a, b, c);
                  }

                  return C.apply(this, arguments);
                };

                F[PROTOTYPE] = C[PROTOTYPE];
                return F; // make static versions for prototype methods
              }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

          if (IS_PROTO) {
            (localExports.virtual || (localExports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

            if (type & (<any>$export).R && expProto && !expProto[key]) hide(expProto, key, out);
          }
        }
      }; // type bitmap


      (<any>$export).F = 1; // forced

      (<any>$export).G = 2; // global

      (<any>$export).S = 4; // static

      (<any>$export).P = 8; // proto

      (<any>$export).B = 16; // bind

      (<any>$export).W = 32; // wrap

      (<any>$export).U = 64; // safe

      (<any>$export).R = 128; // real proto method for `library`

      localModule.localExports = $export;
    }, {
      "./_core": 36,
      "./_ctx": 38,
      "./_global": 46,
      "./_has": 47,
      "./_hide": 48
    }],
    44: [function (localRequire, localModule, localExports) {
      localModule.localExports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
    }, {}],
    45: [function (localRequire, localModule, localExports) {
      var ctx = localRequire('./_ctx');
      var call = localRequire('./_iter-call');
      var isArrayIter = localRequire('./_is-array-iter');
      var anObject = localRequire('./_an-object');
      var toLength = localRequire('./_to-length');
      var getIterFn = localRequire('./core.get-iterator-method');
      var BREAK = {};
      var RETURN = {};

      var localExports: any = localModule.localExports = function (iterable, entries, fn, that, ITERATOR) {
        var iterFn = ITERATOR ? function () {
          return iterable;
        } : getIterFn(iterable);
        var f = ctx(fn, that, entries ? 2 : 1);
        var index = 0;
        var length, step, iterator, result;
        if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

        if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
          result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
          if (result === BREAK || result === RETURN) return result;
        } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
          result = call(iterator, f, step.value, entries);
          if (result === BREAK || result === RETURN) return result;
        }
      };

      localExports.BREAK = BREAK;
      localExports.RETURN = RETURN;
    }, {
      "./_an-object": 25,
      "./_ctx": 38,
      "./_is-array-iter": 53,
      "./_iter-call": 56,
      "./_to-length": 92,
      "./core.get-iterator-method": 99
    }],
    46: [function (localRequire, localModule, localExports) {
      // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
      var global = localModule.localExports = typeof window != 'undefined' && (<any>window).Math == Math ? window : typeof self != 'undefined' && (<any>self).Math == Math ? self // eslint-disable-next-line no-new-func
        : Function('return this')();
      //@ts-ignore
      if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
    }, {}],
    47: [function (localRequire, localModule, localExports) {
      var hasOwnProperty = {}.hasOwnProperty;

      localModule.localExports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };
    }, {}],
    48: [function (localRequire, localModule, localExports) {
      var dP = localRequire('./_object-dp');
      var createDesc = localRequire('./_property-desc');
      localModule.localExports = localRequire('./_descriptors') ? function (object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function (object, key, value) {
        object[key] = value;
        return object;
      };
    }, {
      "./_descriptors": 40,
      "./_object-dp": 67,
      "./_property-desc": 77
    }],
    49: [function (localRequire, localModule, localExports) {
      var document = localRequire('./_global').document;
      localModule.localExports = document && document.documentElement;
    }, {
      "./_global": 46
    }],
    50: [function (localRequire, localModule, localExports) {
      localModule.localExports = !localRequire('./_descriptors') && !localRequire('./_fails')(function () {
        return Object.defineProperty(localRequire('./_dom-create')('div'), 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "./_descriptors": 40,
      "./_dom-create": 41,
      "./_fails": 44
    }],
    51: [function (localRequire, localModule, localExports) {
      // fast apply, http://jsperf.lnkit.com/fast-apply/5
      localModule.localExports = function (fn, args, that) {
        var un = that === undefined;

        switch (args.length) {
          case 0:
            return un ? fn() : fn.call(that);

          case 1:
            return un ? fn(args[0]) : fn.call(that, args[0]);

          case 2:
            return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

          case 3:
            return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

          case 4:
            return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
        }

        return fn.apply(that, args);
      };
    }, {}],
    52: [function (localRequire, localModule, localExports) {
      // fallback for non-array-like ES3 and non-enumerable old V8 strings
      var cof = localRequire('./_cof'); // eslint-disable-next-line no-prototype-builtins

      localModule.localExports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
        return cof(it) == 'String' ? it.split('') : Object(it);
      };
    }, {
      "./_cof": 32
    }],
    53: [function (localRequire, localModule, localExports) {
      // check on default Array iterator
      var Iterators = localRequire('./_iterators');
      var ITERATOR = localRequire('./_wks')('iterator');
      var ArrayProto = Array.prototype;

      localModule.localExports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
      };
    }, {
      "./_iterators": 61,
      "./_wks": 98
    }],
    54: [function (localRequire, localModule, localExports) {
      // 7.2.2 IsArray(argument)
      var cof = localRequire('./_cof');

      localModule.localExports = Array.isArray || function isArray(arg) {
        return cof(arg) == 'Array';
      };
    }, {
      "./_cof": 32
    }],
    55: [function (localRequire, localModule, localExports) {
      localModule.localExports = function (it) {
        return typeof it === 'object' ? it !== null : typeof it === 'function';
      };
    }, {}],
    56: [function (localRequire, localModule, localExports) {
      // call something on iterator step with safe closing on error
      var anObject = localRequire('./_an-object');

      localModule.localExports = function (iterator, fn, value, entries) {
        try {
          return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
        } catch (e) {
          var ret = iterator['return'];
          if (ret !== undefined) anObject(ret.call(iterator));
          throw e;
        }
      };
    }, {
      "./_an-object": 25
    }],
    57: [function (localRequire, localModule, localExports) {

      var create = localRequire('./_object-create');
      var descriptor = localRequire('./_property-desc');
      var setToStringTag = localRequire('./_set-to-string-tag');
      var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

      localRequire('./_hide')(IteratorPrototype, localRequire('./_wks')('iterator'), function () {
        return this;
      });

      localModule.localExports = function (Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, {
          next: descriptor(1, next)
        });
        setToStringTag(Constructor, NAME + ' Iterator');
      };
    }, {
      "./_hide": 48,
      "./_object-create": 66,
      "./_property-desc": 77,
      "./_set-to-string-tag": 83,
      "./_wks": 98
    }],
    58: [function (localRequire, localModule, localExports) {

      var LIBRARY = localRequire('./_library');
      var $export = localRequire('./_export');
      var redefine = localRequire('./_redefine');
      var hide = localRequire('./_hide');
      var Iterators = localRequire('./_iterators');
      var $iterCreate = localRequire('./_iter-create');
      var setToStringTag = localRequire('./_set-to-string-tag');
      var getPrototypeOf = localRequire('./_object-gpo');
      var ITERATOR = localRequire('./_wks')('iterator');
      var BUGGY = !((<any>[]).keys && 'next' in (<any>[]).keys()); // Safari has buggy iterators w/o `next`

      var FF_ITERATOR = '@@iterator';
      var KEYS = 'keys';
      var VALUES = 'values';

      var returnThis = function returnThis() {
        return this;
      };

      localModule.localExports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);

        var getMethod = function getMethod(kind) {
          if (!BUGGY && kind in proto) return proto[kind];

          switch (kind) {
            case KEYS:
              return function keys() {
                return new Constructor(this, kind);
              };

            case VALUES:
              return function values() {
                return new Constructor(this, kind);
              };
          }

          return function entries() {
            return new Constructor(this, kind);
          };
        };

        var TAG = NAME + ' Iterator';
        var DEF_VALUES = DEFAULT == VALUES;
        var VALUES_BUG = false;
        var proto = Base.prototype;
        var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
        var $default = $native || getMethod(DEFAULT);
        var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
        var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
        var methods, key, IteratorPrototype; // Fix native

        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

          if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

            if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
          }
        } // fix Array#{values, @@iterator}.name in V8 / FF


        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;

          $default = function values() {
            return $native.call(this);
          };
        } // Define iterator


        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        } // Plug for library


        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;

        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED) for (key in methods) {
            if (!(key in proto)) redefine(proto, key, methods[key]);
          } else $export($export.P + $export.F * <any>(BUGGY || VALUES_BUG), NAME, methods);
        }

        return methods;
      };
    }, {
      "./_export": 43,
      "./_hide": 48,
      "./_iter-create": 57,
      "./_iterators": 61,
      "./_library": 62,
      "./_object-gpo": 70,
      "./_redefine": 79,
      "./_set-to-string-tag": 83,
      "./_wks": 98
    }],
    59: [function (localRequire, localModule, localExports) {
      var ITERATOR = localRequire('./_wks')('iterator');
      var SAFE_CLOSING = false;

      try {
        var riter = (<any>[7])[ITERATOR]();

        riter['return'] = function () {
          SAFE_CLOSING = true;
        }; // eslint-disable-next-line no-throw-literal


        (<any>Array).from(riter, function () {
          throw 2;
        });
      } catch (e) {
        /* empty */
      }

      localModule.localExports = function (exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING) return false;
        var safe = false;

        try {
          var arr: any = [7];
          var iter = arr[ITERATOR]();

          iter.next = function () {
            return {
              done: safe = true
            };
          };

          arr[ITERATOR] = function () {
            return iter;
          };

          exec(arr);
        } catch (e) {
          /* empty */
        }

        return safe;
      };
    }, {
      "./_wks": 98
    }],
    60: [function (localRequire, localModule, localExports) {
      localModule.localExports = function (done, value) {
        return {
          value: value,
          done: !!done
        };
      };
    }, {}],
    61: [function (localRequire, localModule, localExports) {
      localModule.localExports = {};
    }, {}],
    62: [function (localRequire, localModule, localExports) {
      localModule.localExports = true;
    }, {}],
    63: [function (localRequire, localModule, localExports) {
      var META = localRequire('./_uid')('meta');
      var isObject = localRequire('./_is-object');
      var has = localRequire('./_has');
      var setDesc = localRequire('./_object-dp').f;
      var id = 0;

      var isExtensible = Object.isExtensible || function () {
        return true;
      };

      var FREEZE = !localRequire('./_fails')(function () {
        return isExtensible(Object.preventExtensions({}));
      });

      var setMeta = function setMeta(it) {
        setDesc(it, META, {
          value: {
            i: 'O' + ++id,
            // object ID
            w: {} // weak collections IDs

          }
        });
      };

      var fastKey = function fastKey(it, create) {
        // return primitive with prefix
        if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return 'F'; // not necessary to add metadata

          if (!create) return 'E'; // add missing metadata

          setMeta(it); // return object ID
        }

        return it[META].i;
      };

      var getWeak = function getWeak(it, create) {
        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return true; // not necessary to add metadata

          if (!create) return false; // add missing metadata

          setMeta(it); // return hash weak collections IDs
        }

        return it[META].w;
      }; // add metadata on freeze-family methods calling


      var onFreeze = function onFreeze(it) {
        if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
        return it;
      };

      var meta = localModule.localExports = {
        KEY: META,
        NEED: false,
        fastKey: fastKey,
        getWeak: getWeak,
        onFreeze: onFreeze
      };
    }, {
      "./_fails": 44,
      "./_has": 47,
      "./_is-object": 55,
      "./_object-dp": 67,
      "./_uid": 95
    }],
    64: [function (localRequire, localModule, localExports) {
      var global = localRequire('./_global');
      var macrotask = localRequire('./_task').set;
      var Observer = global.MutationObserver || global.WebKitMutationObserver;
      var process = global.process;
      var Promise = global.Promise;
      var isNode = localRequire('./_cof')(process) == 'process';

      localModule.localExports = function () {
        var head, last, notify;

        var flush = function flush() {
          var parent, fn;
          if (isNode && (parent = process.domain)) parent.exit();

          while (head) {
            fn = head.fn;
            head = head.next;

            try {
              fn();
            } catch (e) {
              if (head) notify(); else last = undefined;
              throw e;
            }
          }

          last = undefined;
          if (parent) parent.enter();
        }; // Node.js


        if (isNode) {
          notify = function notify() {
            process.nextTick(flush);
          }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

        } else if (Observer && !(global.navigator && global.navigator.standalone)) {
          var toggle = true;
          var node: any = document.createTextNode('');
          new Observer(flush).observe(node, {
            characterData: true
          }); // eslint-disable-line no-new

          notify = function notify() {
            node.data = toggle = !toggle;
          }; // environments with maybe non-completely correct, but existent Promise

        } else if (Promise && Promise.resolve) {
          // Promise.resolve without an argument throws an error in LG WebOS 2
          var promise = Promise.resolve(undefined);

          notify = function notify() {
            promise.then(flush);
          }; // for other environments - macrotask based on:
          // - setImmediate
          // - MessageChannel
          // - window.postMessag
          // - onreadystatechange
          // - setTimeout

        } else {
          notify = function notify() {
            // strange IE + webpack dev server bug - use .call(global)
            macrotask.call(global, flush);
          };
        }

        return function (fn) {
          var task = {
            fn: fn,
            next: undefined
          };
          if (last) last.next = task;

          if (!head) {
            head = task;
            notify();
          }

          last = task;
        };
      };
    }, {
      "./_cof": 32,
      "./_global": 46,
      "./_task": 88
    }],
    65: [function (localRequire, localModule, localExports) {

      var aFunction = localRequire('./_a-function');

      function PromiseCapability(C) {
        var resolve, reject;
        this.promise = new C(function ($$resolve, $$reject) {
          if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aFunction(resolve);
        this.reject = aFunction(reject);
      }

      localModule.localExports.f = function (C) {
        return new PromiseCapability(C);
      };
    }, {
      "./_a-function": 22
    }],
    66: [function (localRequire, localModule, localExports) {
      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
      var anObject = localRequire('./_an-object');
      var dPs = localRequire('./_object-dps');
      var enumBugKeys = localRequire('./_enum-bug-keys');
      var IE_PROTO = localRequire('./_shared-key')('IE_PROTO');

      var Empty = function Empty() {
        /* empty */
      };

      var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

      var _createDict = function createDict() {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = localRequire('./_dom-create')('iframe');
        var i = enumBugKeys.length;
        var lt = '<';
        var gt = '>';
        var iframeDocument;
        iframe.style.display = 'none';
        localRequire('./_html').appendChild(iframe);
        iframe.src = 'javascript:'; // eslint-disable-line no-script-url
        // createDict = iframe.contentWindow.Object;
        // html.removeChild(iframe);

        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
        iframeDocument.close();
        _createDict = iframeDocument.F;

        while (i--) {
          delete _createDict[PROTOTYPE][enumBugKeys[i]];
        }

        return _createDict();
      };

      localModule.localExports = Object.create || function create(O, Properties) {
        var result;

        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

          result[IE_PROTO] = O;
        } else result = _createDict();

        return Properties === undefined ? result : dPs(result, Properties);
      };
    }, {
      "./_an-object": 25,
      "./_dom-create": 41,
      "./_enum-bug-keys": 42,
      "./_html": 49,
      "./_object-dps": 68,
      "./_shared-key": 84
    }],
    67: [function (localRequire, localModule, localExports) {
      var anObject = localRequire('./_an-object');
      var IE8_DOM_DEFINE = localRequire('./_ie8-dom-define');
      var toPrimitive = localRequire('./_to-primitive');
      var dP = Object.defineProperty;
      localExports.f = localRequire('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return dP(O, P, Attributes);
        } catch (e) {
          /* empty */
        }
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
      };
    }, {
      "./_an-object": 25,
      "./_descriptors": 40,
      "./_ie8-dom-define": 50,
      "./_to-primitive": 94
    }],
    68: [function (localRequire, localModule, localExports) {
      var dP = localRequire('./_object-dp');
      var anObject = localRequire('./_an-object');
      var getKeys = localRequire('./_object-keys');
      localModule.localExports = localRequire('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = getKeys(Properties);
        var length = keys.length;
        var i = 0;
        var P;

        while (length > i) {
          dP.f(O, P = keys[i++], Properties[P]);
        }

        return O;
      };
    }, {
      "./_an-object": 25,
      "./_descriptors": 40,
      "./_object-dp": 67,
      "./_object-keys": 72
    }],
    69: [function (localRequire, localModule, localExports) {
      var pIE = localRequire('./_object-pie');
      var createDesc = localRequire('./_property-desc');
      var toIObject = localRequire('./_to-iobject');
      var toPrimitive = localRequire('./_to-primitive');
      var has = localRequire('./_has');
      var IE8_DOM_DEFINE = localRequire('./_ie8-dom-define');
      var gOPD = Object.getOwnPropertyDescriptor;
      localExports.f = localRequire('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
        O = toIObject(O);
        P = toPrimitive(P, true);
        if (IE8_DOM_DEFINE) try {
          return gOPD(O, P);
        } catch (e) {
          /* empty */
        }
        if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
      };
    }, {
      "./_descriptors": 40,
      "./_has": 47,
      "./_ie8-dom-define": 50,
      "./_object-pie": 73,
      "./_property-desc": 77,
      "./_to-iobject": 91,
      "./_to-primitive": 94
    }],
    70: [function (localRequire, localModule, localExports) {
      // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
      var has = localRequire('./_has');
      var toObject = localRequire('./_to-object');
      var IE_PROTO = localRequire('./_shared-key')('IE_PROTO');
      var ObjectProto = Object.prototype;

      localModule.localExports = Object.getPrototypeOf || function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO)) return O[IE_PROTO];

        if (typeof O.constructor == 'function' && O instanceof O.constructor) {
          return O.constructor.prototype;
        }

        return O instanceof Object ? ObjectProto : null;
      };
    }, {
      "./_has": 47,
      "./_shared-key": 84,
      "./_to-object": 93
    }],
    71: [function (localRequire, localModule, localExports) {
      var has = localRequire('./_has');
      var toIObject = localRequire('./_to-iobject');
      var arrayIndexOf = localRequire('./_array-includes')(false);
      var IE_PROTO = localRequire('./_shared-key')('IE_PROTO');

      localModule.localExports = function (object, names) {
        var O = toIObject(object);
        var i = 0;
        var result = [];
        var key;

        for (key in O) {
          if (key != IE_PROTO) has(O, key) && result.push(key);
        } // Don't enum bug & hidden keys


        while (names.length > i) {
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        }

        return result;
      };
    }, {
      "./_array-includes": 27,
      "./_has": 47,
      "./_shared-key": 84,
      "./_to-iobject": 91
    }],
    72: [function (localRequire, localModule, localExports) {
      // 19.1.2.14 / 15.2.3.14 Object.keys(O)
      var $keys = localRequire('./_object-keys-internal');
      var enumBugKeys = localRequire('./_enum-bug-keys');

      localModule.localExports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
    }, {
      "./_enum-bug-keys": 42,
      "./_object-keys-internal": 71
    }],
    73: [function (localRequire, localModule, localExports) {
      localExports.f = {}.propertyIsEnumerable;
    }, {}],
    74: [function (localRequire, localModule, localExports) {
      // most Object methods by ES6 should accept primitives
      var $export = localRequire('./_export');
      var core = localRequire('./_core');
      var fails = localRequire('./_fails');

      localModule.localExports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY];
        var exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
          fn(1);
        }), 'Object', exp);
      };
    }, {
      "./_core": 36,
      "./_export": 43,
      "./_fails": 44
    }],
    75: [function (localRequire, localModule, localExports) {
      localModule.localExports = function (exec) {
        try {
          return {
            e: false,
            v: exec()
          };
        } catch (e) {
          return {
            e: true,
            v: e
          };
        }
      };
    }, {}],
    76: [function (localRequire, localModule, localExports) {
      var anObject = localRequire('./_an-object');
      var isObject = localRequire('./_is-object');
      var newPromiseCapability = localRequire('./_new-promise-capability');

      localModule.localExports = function (C, x) {
        anObject(C);
        if (isObject(x) && x.constructor === C) return x;
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
      };
    }, {
      "./_an-object": 25,
      "./_is-object": 55,
      "./_new-promise-capability": 65
    }],
    77: [function (localRequire, localModule, localExports) {
      localModule.localExports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value: value
        };
      };
    }, {}],
    78: [function (localRequire, localModule, localExports) {
      var hide = localRequire('./_hide');

      localModule.localExports = function (target, src, safe) {
        for (var key in src) {
          if (safe && target[key]) target[key] = src[key]; else hide(target, key, src[key]);
        }

        return target;
      };
    }, {
      "./_hide": 48
    }],
    79: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire('./_hide');
    }, {
      "./_hide": 48
    }],
    80: [function (localRequire, localModule, localExports) {

      var $export = localRequire('./_export');
      var aFunction = localRequire('./_a-function');
      var ctx = localRequire('./_ctx');
      var forOf = localRequire('./_for-of');

      localModule.localExports = function (COLLECTION) {
        $export($export.S, COLLECTION, {
          from: function from(source
            /* , mapFn, thisArg */
          ) {
            var mapFn = arguments[1];
            var mapping, A, n, cb;
            aFunction(this);
            mapping = mapFn !== undefined;
            if (mapping) aFunction(mapFn);
            if (source == undefined) return new this();
            A = [];

            if (mapping) {
              n = 0;
              cb = ctx(mapFn, arguments[2], 2);
              forOf(source, false, function (nextItem) {
                A.push(cb(nextItem, n++));
              });
            } else {
              forOf(source, false, A.push, A);
            }

            return new this(A);
          }
        });
      };
    }, {
      "./_a-function": 22,
      "./_ctx": 38,
      "./_export": 43,
      "./_for-of": 45
    }],
    81: [function (localRequire, localModule, localExports) {

      var $export = localRequire('./_export');

      localModule.localExports = function (COLLECTION) {
        $export($export.S, COLLECTION, {
          of: function of() {
            var length = arguments.length;
            var A = new Array(length);

            while (length--) {
              A[length] = arguments[length];
            }

            return new this(A);
          }
        });
      };
    }, {
      "./_export": 43
    }],
    82: [function (localRequire, localModule, localExports) {

      var global = localRequire('./_global');
      var core = localRequire('./_core');
      var dP = localRequire('./_object-dp');
      var DESCRIPTORS = localRequire('./_descriptors');
      var SPECIES = localRequire('./_wks')('species');

      localModule.localExports = function (KEY) {
        var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
        if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
          configurable: true,
          get: function get() {
            return this;
          }
        });
      };
    }, {
      "./_core": 36,
      "./_descriptors": 40,
      "./_global": 46,
      "./_object-dp": 67,
      "./_wks": 98
    }],
    83: [function (localRequire, localModule, localExports) {
      var def = localRequire('./_object-dp').f;
      var has = localRequire('./_has');
      var TAG = localRequire('./_wks')('toStringTag');

      localModule.localExports = function (it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
          configurable: true,
          value: tag
        });
      };
    }, {
      "./_has": 47,
      "./_object-dp": 67,
      "./_wks": 98
    }],
    84: [function (localRequire, localModule, localExports) {
      var shared = localRequire('./_shared')('keys');
      var uid = localRequire('./_uid');

      localModule.localExports = function (key) {
        return shared[key] || (shared[key] = uid(key));
      };
    }, {
      "./_shared": 85,
      "./_uid": 95
    }],
    85: [function (localRequire, localModule, localExports) {
      var core = localRequire('./_core');
      var global = localRequire('./_global');
      var SHARED = '__core-js_shared__';
      var store = global[SHARED] || (global[SHARED] = {});
      (localModule.localExports = function (key, value) {
        return store[key] || (store[key] = value !== undefined ? value : {});
      })('versions', []).push({
        version: core.version,
        mode: localRequire('./_library') ? 'pure' : 'global',
        copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
      });
    }, {
      "./_core": 36,
      "./_global": 46,
      "./_library": 62
    }],
    86: [function (localRequire, localModule, localExports) {
      // 7.3.20 SpeciesConstructor(O, defaultConstructor)
      var anObject = localRequire('./_an-object');
      var aFunction = localRequire('./_a-function');
      var SPECIES = localRequire('./_wks')('species');

      localModule.localExports = function (O, D) {
        var C = anObject(O).constructor;
        var S;
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
      };
    }, {
      "./_a-function": 22,
      "./_an-object": 25,
      "./_wks": 98
    }],
    87: [function (localRequire, localModule, localExports) {
      var toInteger = localRequire('./_to-integer');
      var defined = localRequire('./_defined'); // true  -> String#at
      // false -> String#codePointAt

      localModule.localExports = function (TO_STRING) {
        return function (that, pos) {
          var s = String(defined(that));
          var i = toInteger(pos);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
          a = s.charCodeAt(i);
          return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
        };
      };
    }, {
      "./_defined": 39,
      "./_to-integer": 90
    }],
    88: [function (localRequire, localModule, localExports) {
      var ctx = localRequire('./_ctx');
      var invoke = localRequire('./_invoke');
      var html = localRequire('./_html');
      var cel = localRequire('./_dom-create');
      var global = localRequire('./_global');
      var process = global.process;
      var setTask = global.setImmediate;
      var clearTask = global.clearImmediate;
      var MessageChannel = global.MessageChannel;
      var Dispatch = global.Dispatch;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = 'onreadystatechange';
      var defer, channel, port;

      var run = function run() {
        var id: any = +this; // eslint-disable-next-line no-prototype-builtins

        if (queue.hasOwnProperty(id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };

      var listener = function listener(event) {
        run.call(event.data);
      }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


      if (!setTask || !clearTask) {
        setTask = function setImmediate(fn) {
          var args = [];
          var i = 1;

          while (arguments.length > i) {
            args.push(arguments[i++]);
          }

          queue[++counter] = function () {
            // eslint-disable-next-line no-new-func
            invoke(typeof fn == 'function' ? fn : Function(fn), args);
          };

          defer(counter);
          return counter;
        };

        clearTask = function clearImmediate(id) {
          delete queue[id];
        }; // Node.js 0.8-


        if (localRequire('./_cof')(process) == 'process') {
          defer = function defer(id) {
            process.nextTick(ctx(run, id, 1));
          }; // Sphere (JS game engine) Dispatch API

        } else if (Dispatch && Dispatch.now) {
          defer = function defer(id) {
            Dispatch.now(ctx(run, id, 1));
          }; // Browsers with MessageChannel, includes WebWorkers

        } else if (MessageChannel) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = listener;
          defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
          // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
        } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
          defer = function defer(id) {
            global.postMessage(id + '', '*');
          };

          global.addEventListener('message', listener, false); // IE8-
        } else if (ONREADYSTATECHANGE in cel('script')) {
          defer = function defer(id) {
            html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
              html.removeChild(this);
              run.call(id);
            };
          }; // Rest old browsers

        } else {
          defer = function defer(id) {
            setTimeout(ctx(run, id, 1), 0);
          };
        }
      }

      localModule.localExports = {
        set: setTask,
        clear: clearTask
      };
    }, {
      "./_cof": 32,
      "./_ctx": 38,
      "./_dom-create": 41,
      "./_global": 46,
      "./_html": 49,
      "./_invoke": 51
    }],
    89: [function (localRequire, localModule, localExports) {
      var toInteger = localRequire('./_to-integer');
      var max = Math.max;
      var min = Math.min;

      localModule.localExports = function (index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
    }, {
      "./_to-integer": 90
    }],
    90: [function (localRequire, localModule, localExports) {
      // 7.1.4 ToInteger
      var ceil = Math.ceil;
      var floor = Math.floor;

      localModule.localExports = function (it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
    }, {}],
    91: [function (localRequire, localModule, localExports) {
      // to indexed object, toObject with fallback for non-array-like ES3 strings
      var IObject = localRequire('./_iobject');
      var defined = localRequire('./_defined');

      localModule.localExports = function (it) {
        return IObject(defined(it));
      };
    }, {
      "./_defined": 39,
      "./_iobject": 52
    }],
    92: [function (localRequire, localModule, localExports) {
      // 7.1.15 ToLength
      var toInteger = localRequire('./_to-integer');
      var min = Math.min;

      localModule.localExports = function (it) {
        return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
      };
    }, {
      "./_to-integer": 90
    }],
    93: [function (localRequire, localModule, localExports) {
      // 7.1.13 ToObject(argument)
      var defined = localRequire('./_defined');

      localModule.localExports = function (it) {
        return Object(defined(it));
      };
    }, {
      "./_defined": 39
    }],
    94: [function (localRequire, localModule, localExports) {
      // 7.1.1 ToPrimitive(input [, PreferredType])
      var isObject = localRequire('./_is-object'); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string

      localModule.localExports = function (it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
        if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }, {
      "./_is-object": 55
    }],
    95: [function (localRequire, localModule, localExports) {
      var id = 0;
      var px = Math.random();

      localModule.localExports = function (key) {
        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
      };
    }, {}],
    96: [function (localRequire, localModule, localExports) {
      var global = localRequire('./_global');
      var navigator = global.navigator;
      localModule.localExports = navigator && navigator.userAgent || '';
    }, {
      "./_global": 46
    }],
    97: [function (localRequire, localModule, localExports) {
      var isObject = localRequire('./_is-object');

      localModule.localExports = function (it, TYPE) {
        if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
        return it;
      };
    }, {
      "./_is-object": 55
    }],
    98: [function (localRequire, localModule, localExports) {
      var store = localRequire('./_shared')('wks');
      var uid = localRequire('./_uid');
      var Symbol = localRequire('./_global').Symbol;
      var USE_SYMBOL = typeof Symbol == 'function';

      var $exports: any = localModule.localExports = function (name) {
        return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
      };

      $exports.store = store;
    }, {
      "./_global": 46,
      "./_shared": 85,
      "./_uid": 95
    }],
    99: [function (localRequire, localModule, localExports) {
      var classof = localRequire('./_classof');
      var ITERATOR = localRequire('./_wks')('iterator');
      var Iterators = localRequire('./_iterators');

      localModule.localExports = localRequire('./_core').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
      };
    }, {
      "./_classof": 31,
      "./_core": 36,
      "./_iterators": 61,
      "./_wks": 98
    }],
    100: [function (localRequire, localModule, localExports) {

      var ctx = localRequire('./_ctx');
      var $export = localRequire('./_export');
      var toObject = localRequire('./_to-object');
      var call = localRequire('./_iter-call');
      var isArrayIter = localRequire('./_is-array-iter');
      var toLength = localRequire('./_to-length');
      var createProperty = localRequire('./_create-property');
      var getIterFn = localRequire('./core.get-iterator-method');
      $export($export.S + $export.F * <any>!localRequire('./_iter-detect')(function (iter) {
      }), 'Array', {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function from(arrayLike
          /* , mapfn = undefined, thisArg = undefined */
        ) {
          var O = toObject(arrayLike);
          var C = typeof this == 'function' ? this : Array;
          var aLen = arguments.length;
          var mapfn = aLen > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var index = 0;
          var iterFn = getIterFn(O);
          var length, result, step, iterator;
          if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

          if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
            for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
              createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
            }
          } else {
            length = toLength(O.length);

            for (result = new C(length); length > index; index++) {
              createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
            }
          }

          result.length = index;
          return result;
        }
      });
    }, {
      "./_create-property": 37,
      "./_ctx": 38,
      "./_export": 43,
      "./_is-array-iter": 53,
      "./_iter-call": 56,
      "./_iter-detect": 59,
      "./_to-length": 92,
      "./_to-object": 93,
      "./core.get-iterator-method": 99
    }],
    101: [function (localRequire, localModule, localExports) {
      // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
      var $export = localRequire('./_export');
      $export($export.S, 'Array', {
        isArray: localRequire('./_is-array')
      });
    }, {
      "./_export": 43,
      "./_is-array": 54
    }],
    102: [function (localRequire, localModule, localExports) {

      var addToUnscopables = localRequire('./_add-to-unscopables');
      var step = localRequire('./_iter-step');
      var Iterators = localRequire('./_iterators');
      var toIObject = localRequire('./_to-iobject'); // 22.1.3.4 Array.prototype.entries()
      // 22.1.3.13 Array.prototype.keys()
      // 22.1.3.29 Array.prototype.values()
      // 22.1.3.30 Array.prototype[@@iterator]()

      localModule.localExports = localRequire('./_iter-define')(Array, 'Array', function (iterated, kind) {
        this._t = toIObject(iterated); // target

        this._i = 0; // next index

        this._k = kind; // kind
        // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
      }, function () {
        var O = this._t;
        var kind = this._k;
        var index = this._i++;

        if (!O || index >= O.length) {
          this._t = undefined;
          return step(1);
        }

        if (kind == 'keys') return step(0, index);
        if (kind == 'values') return step(0, O[index]);
        return step(0, [index, O[index]]);
      }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

      Iterators.Arguments = Iterators.Array;
      addToUnscopables('keys');
      addToUnscopables('values');
      addToUnscopables('entries');
    }, {
      "./_add-to-unscopables": 23,
      "./_iter-define": 58,
      "./_iter-step": 60,
      "./_iterators": 61,
      "./_to-iobject": 91
    }],
    103: [function (localRequire, localModule, localExports) {

      var strong = localRequire('./_collection-strong');
      var validate = localRequire('./_validate-collection');
      var MAP = 'Map'; // 23.1 Map Objects

      localModule.localExports = localRequire('./_collection')(MAP, function (get) {
        return function Map() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function get(key) {
          var entry = strong.getEntry(validate(this, MAP), key);
          return entry && entry.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function set(key, value) {
          return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
        }
      }, strong, true);
    }, {
      "./_collection": 35,
      "./_collection-strong": 33,
      "./_validate-collection": 97
    }],
    104: [function (localRequire, localModule, localExports) {
      var $export = localRequire('./_export'); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)

      $export($export.S + $export.F * <any>!localRequire('./_descriptors'), 'Object', {
        defineProperty: localRequire('./_object-dp').f
      });
    }, {
      "./_descriptors": 40,
      "./_export": 43,
      "./_object-dp": 67
    }],
    105: [function (localRequire, localModule, localExports) {
      // 19.1.2.5 Object.freeze(O)
      var isObject = localRequire('./_is-object');
      var meta = localRequire('./_meta').onFreeze;
      localRequire('./_object-sap')('freeze', function ($freeze) {
        return function freeze(it) {
          return $freeze && isObject(it) ? $freeze(meta(it)) : it;
        };
      });
    }, {
      "./_is-object": 55,
      "./_meta": 63,
      "./_object-sap": 74
    }],
    106: [function (localRequire, localModule, localExports) {
      // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      var toIObject = localRequire('./_to-iobject');
      var $getOwnPropertyDescriptor = localRequire('./_object-gopd').f;
      localRequire('./_object-sap')('getOwnPropertyDescriptor', function () {
        return function getOwnPropertyDescriptor(it, key) {
          return $getOwnPropertyDescriptor(toIObject(it), key);
        };
      });
    }, {
      "./_object-gopd": 69,
      "./_object-sap": 74,
      "./_to-iobject": 91
    }],
    107: [function (localRequire, localModule, localExports) {
      // 19.1.2.14 Object.keys(O)
      var toObject = localRequire('./_to-object');
      var $keys = localRequire('./_object-keys');
      localRequire('./_object-sap')('keys', function () {
        return function keys(it) {
          return $keys(toObject(it));
        };
      });
    }, {
      "./_object-keys": 72,
      "./_object-sap": 74,
      "./_to-object": 93
    }],
    108: [function (localRequire, localModule, localExports) { }, {}],
    109: [function (localRequire, localModule, localExports) {

      var LIBRARY = localRequire('./_library');
      var global = localRequire('./_global');
      var ctx = localRequire('./_ctx');
      var classof = localRequire('./_classof');
      var $export = localRequire('./_export');
      var isObject = localRequire('./_is-object');
      var aFunction = localRequire('./_a-function');
      var anInstance = localRequire('./_an-instance');
      var forOf = localRequire('./_for-of');
      var speciesConstructor = localRequire('./_species-constructor');
      var task = localRequire('./_task').set;
      var microtask = localRequire('./_microtask')();
      var newPromiseCapabilityModule = localRequire('./_new-promise-capability');
      var perform = localRequire('./_perform');
      var userAgent = localRequire('./_user-agent');
      var promiseResolve = localRequire('./_promise-resolve');
      var PROMISE = 'Promise';
      var TypeError = global.TypeError;
      var process = global.process;
      var versions = process && process.versions;
      var v8 = versions && versions.v8 || '';
      var $Promise = global[PROMISE];
      var isNode = classof(process) == 'process';

      var empty = function empty() {
        /* empty */
      };

      var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
      var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
      var USE_NATIVE = !!function () {
        try {
          // correct subclassing with @@species support
          var promise = $Promise.resolve(1);

          var FakePromise = (promise.constructor = {})[localRequire('./_wks')('species')] = function (exec) {
            exec(empty, empty);
          }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test

          //@ts-ignore
          return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
            // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
            // we can't detect it synchronously, so just check versions
            && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
        } catch (e) {
          /* empty */
        }
      }(); // helpers

      var isThenable = function isThenable(it) {
        var then;
        return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
      };

      var notify = function notify(promise, isReject) {
        if (promise._n) return;
        promise._n = true;
        var chain = promise._c;
        microtask(function () {
          var value = promise._v;
          var ok = promise._s == 1;
          var i = 0;

          var run = function run(reaction) {
            var handler = ok ? reaction.ok : reaction.fail;
            var resolve = reaction.resolve;
            var reject = reaction.reject;
            var domain = reaction.domain;
            var result, then, exited;

            try {
              if (handler) {
                if (!ok) {
                  if (promise._h == 2) onHandleUnhandled(promise);
                  promise._h = 1;
                }

                if (handler === true) result = value; else {
                  if (domain) domain.enter();
                  result = handler(value); // may throw

                  if (domain) {
                    domain.exit();
                    exited = true;
                  }
                }

                if (result === reaction.promise) {
                  reject(TypeError('Promise-chain cycle'));
                } else if (then = isThenable(result)) {
                  then.call(result, resolve, reject);
                } else resolve(result);
              } else reject(value);
            } catch (e) {
              if (domain && !exited) domain.exit();
              reject(e);
            }
          };

          while (chain.length > i) {
            run(chain[i++]);
          } // variable length - can't use forEach


          promise._c = [];
          promise._n = false;
          if (isReject && !promise._h) onUnhandled(promise);
        });
      };

      var onUnhandled = function onUnhandled(promise) {
        task.call(global, function () {
          var value = promise._v;
          var unhandled = isUnhandled(promise);
          var result, handler, console;

          if (unhandled) {
            result = perform(function () {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

            promise._h = isNode || isUnhandled(promise) ? 2 : 1;
          }

          promise._a = undefined;
          if (unhandled && result.e) throw result.v;
        });
      };

      var isUnhandled = function isUnhandled(promise) {
        return promise._h !== 1 && (promise._a || promise._c).length === 0;
      };

      var onHandleUnhandled = function onHandleUnhandled(promise) {
        task.call(global, function () {
          var handler;

          if (isNode) {
            process.emit('rejectionHandled', promise);
          } else if (handler = global.onrejectionhandled) {
            handler({
              promise: promise,
              reason: promise._v
            });
          }
        });
      };

      var $reject = function $reject(value) {
        var promise = this;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap

        promise._v = value;
        promise._s = 2;
        if (!promise._a) promise._a = promise._c.slice();
        notify(promise, true);
      };

      var $resolve = function $resolve(value) {
        var promise = this;
        var then;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap

        try {
          if (promise === value) throw TypeError("Promise can't be resolved itself");

          if (then = isThenable(value)) {
            microtask(function () {
              var wrapper = {
                _w: promise,
                _d: false
              }; // wrap

              try {
                then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
              } catch (e) {
                $reject.call(wrapper, e);
              }
            });
          } else {
            promise._v = value;
            promise._s = 1;
            notify(promise, false);
          }
        } catch (e) {
          $reject.call({
            _w: promise,
            _d: false
          }, e); // wrap
        }
      }; // constructor polyfill


      if (!USE_NATIVE) {
        // 25.4.3.1 Promise(executor)
        $Promise = function Promise(executor) {
          anInstance(this, $Promise, PROMISE, '_h');
          aFunction(executor);
          Internal.call(this);

          try {
            executor(ctx($resolve, this, 1), ctx($reject, this, 1));
          } catch (err) {
            $reject.call(this, err);
          }
        }; // eslint-disable-next-line no-unused-vars


        Internal = function Promise(executor) {
          this._c = []; // <- awaiting reactions

          this._a = undefined; // <- checked in isUnhandled reactions

          this._s = 0; // <- state

          this._d = false; // <- done

          this._v = undefined; // <- value

          this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

          this._n = false; // <- notify
        };

        Internal.prototype = localRequire('./_redefine-all')($Promise.prototype, {
          // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
          then: function then(onFulfilled, onRejected) {
            var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
            reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
            reaction.fail = typeof onRejected == 'function' && onRejected;
            reaction.domain = isNode ? process.domain : undefined;

            this._c.push(reaction);

            if (this._a) this._a.push(reaction);
            if (this._s) notify(this, false);
            return reaction.promise;
          },
          // 25.4.5.1 Promise.prototype.catch(onRejected)
          'catch': function _catch(onRejected) {
            return this.then(undefined, onRejected);
          }
        });

        OwnPromiseCapability = function OwnPromiseCapability() {
          var promise = new Internal();
          this.promise = promise;
          this.resolve = ctx($resolve, promise, 1);
          this.reject = ctx($reject, promise, 1);
        };

        newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
          return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
        };
      }

      $export($export.G + $export.W + $export.F * <any>!USE_NATIVE, {
        Promise: $Promise
      });
      localRequire('./_set-to-string-tag')($Promise, PROMISE);
      localRequire('./_set-species')(PROMISE);
      Wrapper = localRequire('./_core')[PROMISE]; // statics

      $export($export.S + $export.F * <any>!USE_NATIVE, PROMISE, {
        // 25.4.4.5 Promise.reject(r)
        reject: function reject(r) {
          var capability = newPromiseCapability(this);
          var $$reject = capability.reject;
          $$reject(r);
          return capability.promise;
        }
      });
      $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function resolve(x) {
          return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
        }
      });
      $export($export.S + $export.F * <any>!(USE_NATIVE && localRequire('./_iter-detect')(function (iter) {
        $Promise.all(iter)['catch'](empty);
      })), PROMISE, {
        // 25.4.4.1 Promise.all(iterable)
        all: function all(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function () {
            var values = [];
            var index = 0;
            var remaining = 1;
            forOf(iterable, false, function (promise) {
              var $index = index++;
              var alreadyCalled = false;
              values.push(undefined);
              remaining++;
              C.resolve(promise).then(function (value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[$index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.e) reject(result.v);
          return capability.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function race(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var reject = capability.reject;
          var result = perform(function () {
            forOf(iterable, false, function (promise) {
              C.resolve(promise).then(capability.resolve, reject);
            });
          });
          if (result.e) reject(result.v);
          return capability.promise;
        }
      });
    }, {
      "./_a-function": 22,
      "./_an-instance": 24,
      "./_classof": 31,
      "./_core": 36,
      "./_ctx": 38,
      "./_export": 43,
      "./_for-of": 45,
      "./_global": 46,
      "./_is-object": 55,
      "./_iter-detect": 59,
      "./_library": 62,
      "./_microtask": 64,
      "./_new-promise-capability": 65,
      "./_perform": 75,
      "./_promise-resolve": 76,
      "./_redefine-all": 78,
      "./_set-species": 82,
      "./_set-to-string-tag": 83,
      "./_species-constructor": 86,
      "./_task": 88,
      "./_user-agent": 96,
      "./_wks": 98
    }],
    110: [function (localRequire, localModule, localExports) {

      var strong = localRequire('./_collection-strong');
      var validate = localRequire('./_validate-collection');
      var SET = 'Set'; // 23.2 Set Objects

      localModule.localExports = localRequire('./_collection')(SET, function (get) {
        return function Set() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.2.3.1 Set.prototype.add(value)
        add: function add(value) {
          return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
        }
      }, strong);
    }, {
      "./_collection": 35,
      "./_collection-strong": 33,
      "./_validate-collection": 97
    }],
    111: [function (localRequire, localModule, localExports) {
      var $export = localRequire('./_export');
      var toAbsoluteIndex = localRequire('./_to-absolute-index');
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = (<any>String).fromCodePoint; // length should be 1, old FF problem

      $export($export.S + $export.F * <any>(!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
        // 21.1.2.2 String.fromCodePoint(...codePoints)
        fromCodePoint: function fromCodePoint(x) {
          // eslint-disable-line no-unused-vars
          var res = [];
          var aLen = arguments.length;
          var i = 0;
          var code;

          while (aLen > i) {
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
            res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
          }

          return res.join('');
        }
      });
    }, {
      "./_export": 43,
      "./_to-absolute-index": 89
    }],
    112: [function (localRequire, localModule, localExports) {

      var $at = localRequire('./_string-at')(true); // 21.1.3.27 String.prototype[@@iterator]()

      localRequire('./_iter-define')(String, 'String', function (iterated) {
        this._t = String(iterated); // target

        this._i = 0; // next index
        // 21.1.5.2.1 %StringIteratorPrototype%.next()
      }, function () {
        var O = this._t;
        var index = this._i;
        var point;
        if (index >= O.length) return {
          value: undefined,
          done: true
        };
        point = $at(O, index);
        this._i += point.length;
        return {
          value: point,
          done: false
        };
      });
    }, {
      "./_iter-define": 58,
      "./_string-at": 87
    }],
    113: [function (localRequire, localModule, localExports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
      localRequire('./_set-collection-from')('Map');
    }, {
      "./_set-collection-from": 80
    }],
    114: [function (localRequire, localModule, localExports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
      localRequire('./_set-collection-of')('Map');
    }, {
      "./_set-collection-of": 81
    }],
    115: [function (localRequire, localModule, localExports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var $export = localRequire('./_export');
      $export($export.P + $export.R, 'Map', {
        toJSON: localRequire('./_collection-to-json')('Map')
      });
    }, {
      "./_collection-to-json": 34,
      "./_export": 43
    }],
    116: [function (localRequire, localModule, localExports) {

      var $export = localRequire('./_export');
      var core = localRequire('./_core');
      var global = localRequire('./_global');
      var speciesConstructor = localRequire('./_species-constructor');
      var promiseResolve = localRequire('./_promise-resolve');
      $export($export.P + $export.R, 'Promise', {
        'finally': function _finally(onFinally) {
          var C = speciesConstructor(this, core.Promise || global.Promise);
          var isFunction = typeof onFinally == 'function';
          return this.then(isFunction ? function (x) {
            return promiseResolve(C, onFinally()).then(function () {
              return x;
            });
          } : onFinally, isFunction ? function (e) {
            return promiseResolve(C, onFinally()).then(function () {
              throw e;
            });
          } : onFinally);
        }
      });
    }, {
      "./_core": 36,
      "./_export": 43,
      "./_global": 46,
      "./_promise-resolve": 76,
      "./_species-constructor": 86
    }],
    117: [function (localRequire, localModule, localExports) {

      var $export = localRequire('./_export');
      var newPromiseCapability = localRequire('./_new-promise-capability');
      var perform = localRequire('./_perform');
      $export($export.S, 'Promise', {
        'try': function _try(callbackfn) {
          var promiseCapability = newPromiseCapability.f(this);
          var result = perform(callbackfn);
          (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
          return promiseCapability.promise;
        }
      });
    }, {
      "./_export": 43,
      "./_new-promise-capability": 65,
      "./_perform": 75
    }],
    118: [function (localRequire, localModule, localExports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
      localRequire('./_set-collection-from')('Set');
    }, {
      "./_set-collection-from": 80
    }],
    119: [function (localRequire, localModule, localExports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
      localRequire('./_set-collection-of')('Set');
    }, {
      "./_set-collection-of": 81
    }],
    120: [function (localRequire, localModule, localExports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var $export = localRequire('./_export');
      $export($export.P + $export.R, 'Set', {
        toJSON: localRequire('./_collection-to-json')('Set')
      });
    }, {
      "./_collection-to-json": 34,
      "./_export": 43
    }],
    121: [function (localRequire, localModule, localExports) {
      localRequire('./es6.array.iterator');
      var global = localRequire('./_global');
      var hide = localRequire('./_hide');
      var Iterators = localRequire('./_iterators');
      var TO_STRING_TAG = localRequire('./_wks')('toStringTag');
      var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');

      for (var i = 0; i < DOMIterables.length; i++) {
        var NAME = DOMIterables[i];
        var Collection = global[NAME];
        var proto = Collection && Collection.prototype;
        if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
        Iterators[NAME] = Iterators.Array;
      }
    }, {
      "./_global": 46,
      "./_hide": 48,
      "./_iterators": 61,
      "./_wks": 98,
      "./es6.array.iterator": 102
    }],
    122: [function (localRequire, localModule, localExports) {

      localExports.byteLength = byteLength;
      localExports.toByteArray = toByteArray;
      localExports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      } // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications


      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;

      function getLens(b64) {
        var len = b64.length;

        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        } // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42


        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      } // base64 is 4/3 + up to two characters of the original data


      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i;

        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        return arr;
      }

      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
      }

      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];

        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }

        return output.join('');
      }

      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3
        // go through the array every three bytes, we'll deal with trailing stuff later

        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        } // pad the end with zeros, but make sure to not forget the extra bytes


        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
        }

        return parts.join('');
      }
    }, {}],
    123: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {
          var clone = function () {
            /**
             * Clones (copies) an Object using deep copying.
             *
             * This function supports circular references by default, but if you are certain
             * there are no circular references in your object, you can save some CPU time
             * by calling clone(obj, false).
             *
             * Caution: if `circular` is false and `parent` contains circular references,
             * your program may enter an infinite loop and crash.
             *
             * @param `parent` - the object to be cloned
             * @param `circular` - set to true if the object to be cloned may contain
             *    circular references. (optional - true by default)
             * @param `depth` - set to a number if the object is only to be cloned to
             *    a particular depth. (optional - defaults to Infinity)
             * @param `prototype` - sets the prototype to be used when cloning an object.
             *    (optional - defaults to parent prototype).
            */

            function clone(parent, circular, depth, prototype) {
              var filter;

              if (typeof circular === 'object') {
                depth = circular.depth;
                prototype = circular.prototype;
                filter = circular.filter;
                circular = circular.circular;
              } // maintain two arrays for circular references, where corresponding parents
              // and children have the same index


              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != 'undefined';
              if (typeof circular == 'undefined') circular = true;
              if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren

              function _clone(parent, depth) {
                // cloning null always returns null
                if (parent === null) return null;
                if (depth == 0) return parent;
                var child;
                var proto;

                if (typeof parent != 'object') {
                  return parent;
                }

                if ((<any>clone).__isArray(parent)) {
                  child = [];
                } else if ((<any>clone).__isRegExp(parent)) {
                  child = new RegExp(parent.source, __getRegExpFlags(parent));
                  if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                } else if ((<any>clone).__isDate(parent)) {
                  child = new Date(parent.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent)) {
                  if (Buffer.allocUnsafe) {
                    // Node.js >= 4.5.0
                    child = Buffer.allocUnsafe(parent.length);
                  } else {
                    // Older Node.js versions
                    child = new Buffer(parent.length);
                  }

                  parent.copy(child);
                  return child;
                } else {
                  if (typeof prototype == 'undefined') {
                    proto = Object.getPrototypeOf(parent);
                    child = Object.create(proto);
                  } else {
                    child = Object.create(prototype);
                    proto = prototype;
                  }
                }

                if (circular) {
                  var index = allParents.indexOf(parent);

                  if (index != -1) {
                    return allChildren[index];
                  }

                  allParents.push(parent);
                  allChildren.push(child);
                }

                for (var i in parent) {
                  var attrs;

                  if (proto) {
                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                  }

                  if (attrs && attrs.set == null) {
                    continue;
                  }

                  child[i] = _clone(parent[i], depth - 1);
                }

                return child;
              }

              return _clone(parent, depth);
            }
            /**
             * Simple flat clone using prototype, accepts only objects, usefull for property
             * override on FLAT configuration object (no nested props).
             *
             * USE WITH CAUTION! This may not behave as you wish if you do not know how this
             * works.
             */


            (<any>clone).clonePrototype = function clonePrototype(parent) {
              if (parent === null) return null;

              var c = function c() { };

              c.prototype = parent;
              return new c();
            }; // private utility functions


            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }
            (<any>clone).__objToStr = __objToStr;

            function __isDate(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Date]';
            }
            (<any>clone).__isDate = __isDate;

            function __isArray(o) {
              return typeof o === 'object' && __objToStr(o) === '[object Array]';
            }
            (<any>clone).__isArray = __isArray;

            function __isRegExp(o) {
              return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
            }
            (<any>clone).__isRegExp = __isRegExp;

            function __getRegExpFlags(re) {
              var flags = '';
              if (re.global) flags += 'g';
              if (re.ignoreCase) flags += 'i';
              if (re.multiline) flags += 'm';
              return flags;
            }
            (<any>clone).__getRegExpFlags = __getRegExpFlags;
            return clone;
          }();

          if (typeof localModule === 'object' && localModule.localExports) {
            localModule.localExports = clone;
          }
        }).call(this);
      }).call(this, localRequire("buffer").Buffer);
    }, {
      "buffer": 152
    }],
    124: [function (localRequire, localModule, localExports) {
      var TINF_OK = 0;
      var TINF_DATA_ERROR = -3;

      function Tree() {
        this.table = new Uint16Array(16);
        /* table of code length counts */

        this.trans = new Uint16Array(288);
        /* code -> symbol translation table */
      }

      function Data(source, dest) {
        this.source = source;
        this.sourceIndex = 0;
        this.tag = 0;
        this.bitcount = 0;
        this.dest = dest;
        this.destLen = 0;
        this.ltree = new Tree();
        /* dynamic length/symbol tree */

        this.dtree = new Tree();
        /* dynamic distance tree */
      }
      /* --------------------------------------------------- *
       * -- uninitialized global data (static structures) -- *
       * --------------------------------------------------- */


      var sltree = new Tree();
      var sdtree = new Tree();
      /* extra bits and base tables for length codes */

      var length_bits = new Uint8Array(30);
      var length_base = new Uint16Array(30);
      /* extra bits and base tables for distance codes */

      var dist_bits = new Uint8Array(30);
      var dist_base = new Uint16Array(30);
      /* special ordering of code length codes */

      var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      /* used by tinf_decode_trees, avoids allocations every call */

      var code_tree = new Tree();
      var lengths = new Uint8Array(288 + 32);
      /* ----------------------- *
       * -- utility functions -- *
       * ----------------------- */

      /* build extra bits and base tables */

      function tinf_build_bits_base(bits, base, delta, first) {
        var i, sum;
        /* build bits table */

        for (i = 0; i < delta; ++i) {
          bits[i] = 0;
        }

        for (i = 0; i < 30 - delta; ++i) {
          bits[i + delta] = i / delta | 0;
        }
        /* build base table */


        for (sum = first, i = 0; i < 30; ++i) {
          base[i] = sum;
          sum += 1 << bits[i];
        }
      }
      /* build the fixed huffman trees */


      function tinf_build_fixed_trees(lt, dt) {
        var i;
        /* build fixed length tree */

        for (i = 0; i < 7; ++i) {
          lt.table[i] = 0;
        }

        lt.table[7] = 24;
        lt.table[8] = 152;
        lt.table[9] = 112;

        for (i = 0; i < 24; ++i) {
          lt.trans[i] = 256 + i;
        }

        for (i = 0; i < 144; ++i) {
          lt.trans[24 + i] = i;
        }

        for (i = 0; i < 8; ++i) {
          lt.trans[24 + 144 + i] = 280 + i;
        }

        for (i = 0; i < 112; ++i) {
          lt.trans[24 + 144 + 8 + i] = 144 + i;
        }
        /* build fixed distance tree */


        for (i = 0; i < 5; ++i) {
          dt.table[i] = 0;
        }

        dt.table[5] = 32;

        for (i = 0; i < 32; ++i) {
          dt.trans[i] = i;
        }
      }
      /* given an array of code lengths, build a tree */


      var offs = new Uint16Array(16);

      function tinf_build_tree(t, lengths, off, num) {
        var i, sum;
        /* clear code length count table */

        for (i = 0; i < 16; ++i) {
          t.table[i] = 0;
        }
        /* scan symbol lengths, and sum code length counts */


        for (i = 0; i < num; ++i) {
          t.table[lengths[off + i]]++;
        }

        t.table[0] = 0;
        /* compute offset table for distribution sort */

        for (sum = 0, i = 0; i < 16; ++i) {
          offs[i] = sum;
          sum += t.table[i];
        }
        /* create code->symbol translation table (symbols sorted by code) */


        for (i = 0; i < num; ++i) {
          if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
        }
      }
      /* ---------------------- *
       * -- decode functions -- *
       * ---------------------- */

      /* get one bit from source stream */


      function tinf_getbit(d) {
        /* check if tag is empty */
        if (!d.bitcount--) {
          /* load next tag */
          d.tag = d.source[d.sourceIndex++];
          d.bitcount = 7;
        }
        /* shift bit out of tag */


        var bit = d.tag & 1;
        d.tag >>>= 1;
        return bit;
      }
      /* read a num bit value from a stream and add base */


      function tinf_read_bits(d, num, base) {
        if (!num) return base;

        while (d.bitcount < 24) {
          d.tag |= d.source[d.sourceIndex++] << d.bitcount;
          d.bitcount += 8;
        }

        var val = d.tag & 0xffff >>> 16 - num;
        d.tag >>>= num;
        d.bitcount -= num;
        return val + base;
      }
      /* given a data stream and a tree, decode a symbol */


      function tinf_decode_symbol(d, t) {
        while (d.bitcount < 24) {
          d.tag |= d.source[d.sourceIndex++] << d.bitcount;
          d.bitcount += 8;
        }

        var sum = 0,
          cur = 0,
          len = 0;
        var tag = d.tag;
        /* get more bits while code value is above sum */

        do {
          cur = 2 * cur + (tag & 1);
          tag >>>= 1;
          ++len;
          sum += t.table[len];
          cur -= t.table[len];
        } while (cur >= 0);

        d.tag = tag;
        d.bitcount -= len;
        return t.trans[sum + cur];
      }
      /* given a data stream, decode dynamic trees from it */


      function tinf_decode_trees(d, lt, dt) {
        var hlit, hdist, hclen;
        var i, num, length;
        /* get 5 bits HLIT (257-286) */

        hlit = tinf_read_bits(d, 5, 257);
        /* get 5 bits HDIST (1-32) */

        hdist = tinf_read_bits(d, 5, 1);
        /* get 4 bits HCLEN (4-19) */

        hclen = tinf_read_bits(d, 4, 4);

        for (i = 0; i < 19; ++i) {
          lengths[i] = 0;
        }
        /* read code lengths for code length alphabet */


        for (i = 0; i < hclen; ++i) {
          /* get 3 bits code length (0-7) */
          var clen = tinf_read_bits(d, 3, 0);
          lengths[clcidx[i]] = clen;
        }
        /* build code length tree */


        tinf_build_tree(code_tree, lengths, 0, 19);
        /* decode code lengths for the dynamic trees */

        for (num = 0; num < hlit + hdist;) {
          var sym = tinf_decode_symbol(d, code_tree);

          switch (sym) {
            case 16:
              /* copy previous code length 3-6 times (read 2 bits) */
              var prev = lengths[num - 1];

              for (length = tinf_read_bits(d, 2, 3); length; --length) {
                lengths[num++] = prev;
              }

              break;

            case 17:
              /* repeat code length 0 for 3-10 times (read 3 bits) */
              for (length = tinf_read_bits(d, 3, 3); length; --length) {
                lengths[num++] = 0;
              }

              break;

            case 18:
              /* repeat code length 0 for 11-138 times (read 7 bits) */
              for (length = tinf_read_bits(d, 7, 11); length; --length) {
                lengths[num++] = 0;
              }

              break;

            default:
              /* values 0-15 represent the actual code lengths */
              lengths[num++] = sym;
              break;
          }
        }
        /* build dynamic trees */


        tinf_build_tree(lt, lengths, 0, hlit);
        tinf_build_tree(dt, lengths, hlit, hdist);
      }
      /* ----------------------------- *
       * -- block inflate functions -- *
       * ----------------------------- */

      /* given a stream and two trees, inflate a block of data */


      function tinf_inflate_block_data(d, lt, dt) {
        while (1) {
          var sym = tinf_decode_symbol(d, lt);
          /* check for end of block */

          if (sym === 256) {
            return TINF_OK;
          }

          if (sym < 256) {
            d.dest[d.destLen++] = sym;
          } else {
            var length, dist, offs;
            var i;
            sym -= 257;
            /* possibly get more bits from length code */

            length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
            dist = tinf_decode_symbol(d, dt);
            /* possibly get more bits from distance code */

            offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
            /* copy match */

            for (i = offs; i < offs + length; ++i) {
              d.dest[d.destLen++] = d.dest[i];
            }
          }
        }
      }
      /* inflate an uncompressed block of data */


      function tinf_inflate_uncompressed_block(d) {
        var length, invlength;
        var i;
        /* unread from bitbuffer */

        while (d.bitcount > 8) {
          d.sourceIndex--;
          d.bitcount -= 8;
        }
        /* get length */


        length = d.source[d.sourceIndex + 1];
        length = 256 * length + d.source[d.sourceIndex];
        /* get one's complement of length */

        invlength = d.source[d.sourceIndex + 3];
        invlength = 256 * invlength + d.source[d.sourceIndex + 2];
        /* check length */

        if (length !== (~invlength & 0x0000ffff)) return TINF_DATA_ERROR;
        d.sourceIndex += 4;
        /* copy block */

        for (i = length; i; --i) {
          d.dest[d.destLen++] = d.source[d.sourceIndex++];
        }
        /* make sure we start next block on a byte boundary */


        d.bitcount = 0;
        return TINF_OK;
      }
      /* inflate stream from source to dest */


      function tinf_uncompress(source, dest) {
        var d = new Data(source, dest);
        var bfinal, btype, res;

        do {
          /* read final block flag */
          bfinal = tinf_getbit(d);
          /* read block type (2 bits) */

          btype = tinf_read_bits(d, 2, 0);
          /* decompress block */

          switch (btype) {
            case 0:
              /* decompress uncompressed block */
              res = tinf_inflate_uncompressed_block(d);
              break;

            case 1:
              /* decompress block with fixed huffman trees */
              res = tinf_inflate_block_data(d, sltree, sdtree);
              break;

            case 2:
              /* decompress block with dynamic huffman trees */
              tinf_decode_trees(d, d.ltree, d.dtree);
              res = tinf_inflate_block_data(d, d.ltree, d.dtree);
              break;

            default:
              res = TINF_DATA_ERROR;
          }

          if (res !== TINF_OK) throw new Error('Data error');
        } while (!bfinal);

        if (d.destLen < d.dest.length) {
          if (typeof d.dest.slice === 'function') return d.dest.slice(0, d.destLen); else return d.dest.subarray(0, d.destLen);
        }

        return d.dest;
      }
      /* -------------------- *
       * -- initialization -- *
       * -------------------- */

      /* build fixed huffman trees */


      tinf_build_fixed_trees(sltree, sdtree);
      /* build extra bits and base tables */

      tinf_build_bits_base(length_bits, length_base, 4, 3);
      tinf_build_bits_base(dist_bits, dist_base, 2, 1);
      /* fix a special case */

      length_bits[28] = 0;
      length_base[28] = 258;
      localModule.localExports = tinf_uncompress;
    }, {}],
    125: [function (localRequire, localModule, localExports) {

      var UnicodeTrie = localRequire('unicode-trie');
      var base64 = localRequire('base64-js');
      var categories = ["Cc", "Zs", "Po", "Sc", "Ps", "Pe", "Sm", "Pd", "Nd", "Lu", "Sk", "Pc", "Ll", "So", "Lo", "Pi", "Cf", "No", "Pf", "Lt", "Lm", "Mn", "Me", "Mc", "Nl", "Zl", "Zp", "Cs", "Co"];
      var combiningClasses = ["Not_Reordered", "Above", "Above_Right", "Below", "Attached_Above_Right", "Attached_Below", "Overlay", "Iota_Subscript", "Double_Below", "Double_Above", "Below_Right", "Above_Left", "CCC10", "CCC11", "CCC12", "CCC13", "CCC14", "CCC15", "CCC16", "CCC17", "CCC18", "CCC19", "CCC20", "CCC21", "CCC22", "CCC23", "CCC24", "CCC25", "CCC30", "CCC31", "CCC32", "CCC27", "CCC28", "CCC29", "CCC33", "CCC34", "CCC35", "CCC36", "Nukta", "Virama", "CCC84", "CCC91", "CCC103", "CCC107", "CCC118", "CCC122", "CCC129", "CCC130", "CCC132", "Attached_Above", "Below_Left", "Left", "Kana_Voicing", "CCC26", "Right"];
      var scripts = ["Common", "Latin", "Bopomofo", "Inherited", "Greek", "Coptic", "Cyrillic", "Armenian", "Hebrew", "Arabic", "Syriac", "Thaana", "Nko", "Samaritan", "Mandaic", "Devanagari", "Bengali", "Gurmukhi", "Gujarati", "Oriya", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhala", "Thai", "Lao", "Tibetan", "Myanmar", "Georgian", "Hangul", "Ethiopic", "Cherokee", "Canadian_Aboriginal", "Ogham", "Runic", "Tagalog", "Hanunoo", "Buhid", "Tagbanwa", "Khmer", "Mongolian", "Limbu", "Tai_Le", "New_Tai_Lue", "Buginese", "Tai_Tham", "Balinese", "Sundanese", "Batak", "Lepcha", "Ol_Chiki", "Braille", "Glagolitic", "Tifinagh", "Han", "Hiragana", "Katakana", "Yi", "Lisu", "Vai", "Bamum", "Syloti_Nagri", "Phags_Pa", "Saurashtra", "Kayah_Li", "Rejang", "Javanese", "Cham", "Tai_Viet", "Meetei_Mayek", "null", "Linear_B", "Lycian", "Carian", "Old_Italic", "Gothic", "Old_Permic", "Ugaritic", "Old_Persian", "Deseret", "Shavian", "Osmanya", "Osage", "Elbasan", "Caucasian_Albanian", "Linear_A", "Cypriot", "Imperial_Aramaic", "Palmyrene", "Nabataean", "Hatran", "Phoenician", "Lydian", "Meroitic_Hieroglyphs", "Meroitic_Cursive", "Kharoshthi", "Old_South_Arabian", "Old_North_Arabian", "Manichaean", "Avestan", "Inscriptional_Parthian", "Inscriptional_Pahlavi", "Psalter_Pahlavi", "Old_Turkic", "Old_Hungarian", "Hanifi_Rohingya", "Old_Sogdian", "Sogdian", "Elymaic", "Brahmi", "Kaithi", "Sora_Sompeng", "Chakma", "Mahajani", "Sharada", "Khojki", "Multani", "Khudawadi", "Grantha", "Newa", "Tirhuta", "Siddham", "Modi", "Takri", "Ahom", "Dogra", "Warang_Citi", "Nandinagari", "Zanabazar_Square", "Soyombo", "Pau_Cin_Hau", "Bhaiksuki", "Marchen", "Masaram_Gondi", "Gunjala_Gondi", "Makasar", "Cuneiform", "Egyptian_Hieroglyphs", "Anatolian_Hieroglyphs", "Mro", "Bassa_Vah", "Pahawh_Hmong", "Medefaidrin", "Miao", "Tangut", "Nushu", "Duployan", "SignWriting", "Nyiakeng_Puachue_Hmong", "Wancho", "Mende_Kikakui", "Adlam"];
      var eaw = ["N", "Na", "A", "W", "H", "F"];
      var data = {
        categories: categories,
        combiningClasses: combiningClasses,
        scripts: scripts,
        eaw: eaw
      };
      var data$1 = "AAARAAAAAADwfAEAZXl5ONRt+/5bPVFZimRfKoTQJNm37CGE7Iw0j3UsTWKsoyI7kwyyTiEUzSD7NiEzhWYijH0wMVkHE4Mx49fzfo+3nuP4/fdZjvv+XNd5n/d9nef1WZvmKhTxiZndzDQBSEYQqxqKwnsKvGQucFh+6t6cJ792ePQBZv5S9yXSwkyjf/P4T7mTNnIAv1dOVhMlR9lflbUL9JeJguqsjvG9NTj/wLb566VAURnLo2vvRi89S3gW/33ihh2eXpDn40BIW7REl/7coRKIhAFlAiOtbLDTt6mMb4GzMF1gNnvX/sBxtbsAIjfztCNcQjcNDtLThRvuXu5M5g/CBjaLBE4lJm4qy/oZD97+IJryApcXfgWYlkvWbhfXgujOJKVu8B+ozqTLbxyJ5kNiR75CxDqfBM9eOlDMmGeoZ0iQbbS5VUplIwI+ZNXEKQVJxlwqjhOY7w3XwPesbLK5JZE+Tt4X8q8km0dzInsPPzbscrjBMVjF5mOHSeRdJVgKUjLTHiHqXSPkep8N/zFk8167KLp75f6RndkvzdfB6Uz3MmqvRArzdCbs1/iRZjYPLLF3U8Qs+H+Rb8iK51a6NIV2V9+07uJsTGFWpPz8J++7iRu2B6eAKlK/kujrLthwaD/7a6J5w90TusnH1JMAc+gNrql4aspOUG/RrsxUKmPzhHgP4Bleru+6Vfc/MBjgXVx7who94nPn7MPFrnwQP7g0k0Dq0h2GSKO6fTZ8nLodN1SiOUj/5EL/Xo1DBvRm0wmrh3x6phcJ20/9CuMr5h8WPqXMSasLoLHoufTmE7mzYrs6B0dY7KjuCogKqsvxnxAwXWvd9Puc9PnE8DOHT2INHxRlIyVHrqZahtfV2E/A2PDdtA3ewlRHMtFIBKO/T4IozWTQZ+mb+gdKuk/ZHrqloucKdsOSJmlWTSntWjcxVMjUmroXLM10I6TwDLnBq4LP69TxgVeyGsd8yHvhF8ydPlrNRSNs9EP7WmeuSE7Lu10JbOuQcJw/63sDp68wB9iwP5AO+mBpV0R5VDDeyQUFCel1G+4KHBgEVFS0YK+m2sXLWLuGTlkVAd97WwKKdacjWElRCuDRauf33l/yVcDF6sVPKeTes99FC1NpNWcpieGSV/IbO8PCTy5pbUR1U8lxzf4T+y6fZMxOz3LshkQLeeDSd0WmUrQgajmbktrxsb2AZ0ACw2Vgni+gV/m+KvCRWLg08Clx7uhql+v9XySGcjjOHlsp8vBw/e8HS7dtiqF6T/XcSXuaMW66GF1g4q9YyBadHqy3Y5jin1c7yZos6BBr6dsomSHxiUHanYtcYQwnMMZhRhOnaYJeyJzaRuukyCUh48+e/BUvk/aEfDp8ag+jD64BHxNnQ5v/E7WRk7eLjGV13I3oqy45YNONi/1op1oDr7rPjkhPsTXgUpQtGDPlIs55KhQaic9kSGs/UrZ2QKQOflB8MTEQxRF9pullToWO7Eplan6mcMRFnUu2441yxi23x+KqKlr7RWWsi9ZXMWlr8vfP3llk1m2PRj0yudccxBuoa7VfIgRmnFPGX6Pm1WIfMm/Rm4n/xTn8IGqA0GWuqgu48pEUO0U9nN+ZdIvFpPb7VDPphIfRZxznlHeVFebkd9l+raXy9BpTMcIUIvBfgHEb6ndGo8VUkxpief14KjzFOcaANfgvFpvyY8lE8lE4raHizLpluPzMks1hx/e1Hok5yV0p7qQH7GaYeMzzZTFvRpv6k6iaJ4yNqzBvN8J7B430h2wFm1IBPcqbou33G7/NWPgopl4Mllla6e24L3TOTVNkza2zv3QKuDWTeDpClCEYgTQ+5vEBSQZs/rMF50+sm4jofTgWLqgX1x3TkrDEVaRqfY/xZizFZ3Y8/DFEFD31VSfBQ5raEB6nHnZh6ddehtclQJ8fBrldyIh99LNnV32HzKEej04hk6SYjdauCa4aYW0ru/QxvQRGzLKOAQszf3ixJypTW3WWL6BLSF2EMCMIw7OUvWBC6A/gDc2D1jvBapMCc7ztx6jYczwTKsRLL6dMNXb83HS8kdD0pTMMj161zbVHkU0mhSHo9SlBDDXdN6hDvRGizmohtIyR3ot8tF5iUG4GLNcXeGvBudSFrHu+bVZb9jirNVG+rQPI51A7Hu8/b0UeaIaZ4UgDO68PkYx3PE2HWpKapJ764Kxt5TFYpywMy4DLQqVRy11I7SOLhxUFmqiEK52NaijWArIfCg6qG8q5eSiwRCJb1R7GDJG74TrYgx/lVq7w9++Kh929xSJEaoSse5fUOQg9nMAnIZv+7fwVRcNv3gOHI46Vb5jYUC66PYHO6lS+TOmvEQjuYmx4RkffYGxqZIp/DPWNHAixbRBc+XKE3JEOgs4jIwu/dSAwhydruOGF39co91aTs85JJ3Z/LpXoF43hUwJsb/M1Chzdn8HX8vLXnqWUKvRhNLpfAF4PTFqva1sBQG0J+59HyYfmQ3oa4/sxZdapVLlo/fooxSXi/dOEQWIWq8E0FkttEyTFXR2aNMPINMIzZwCNEheYTVltsdaLkMyKoEUluPNAYCM2IG3br0DLy0fVNWKHtbSKbBjfiw7Lu06gQFalC7RC9BwRMSpLYDUo9pDtDfzwUiPJKLJ2LGcSphWBadOI/iJjNqUHV7ucG8yC6+iNM9QYElqBR7ECFXrcTgWQ3eG/tCWacT9bxIkfmxPmi3vOd36KxihAJA73vWNJ+Y9oapXNscVSVqS5g15xOWND/WuUCcA9YAAg6WFbjHamrblZ5c0L6Zx1X58ZittGcfDKU697QRSqW/g+RofNRyvrWMrBn44cPvkRe2HdTu/Cq01C5/riWPHZyXPKHuSDDdW8c1XPgd6ogvLh20qEIu8c19sqr4ufyHrwh37ZN5MkvY1dsGmEz9pUBTxWrvvhNyODyX2Q1k/fbX/T/vbHNcBrmjgDtvBdtZrVtiIg5iXQuzO/DEMvRX8Mi1zymSlt92BGILeKItjoShJXE/H7xwnf0Iewb8BFieJ9MflEBCQYEDm8eZniiEPfGoaYiiEdhQxHQNr2AuRdmbL9mcl18Kumh+HEZLp6z+j35ML9zTbUwahUZCyQQOgQrGfdfQtaR/OYJ/9dYXb2TWZFMijfCA8Nov4sa5FFDUe1T68h4q08WDE7JbbDiej4utRMR9ontevxlXv6LuJTXt1YEv8bDzEt683PuSsIN0afvu0rcBu9AbXZbkOG3K3AhtqQ28N23lXm7S3Yn6KXmAhBhz+GeorJJ4XxO/b3vZk2LXp42+QvsVxGSNVpfSctIFMTR1bD9t70i6sfNF3WKz/uKDEDCpzzztwhL45lsw89H2IpWN10sXHRlhDse9KCdpP5qNNpU84cTY+aiqswqR8XZ9ea0KbVRwRuOGQU3csAtV2fSbnq47U6es6rKlWLWhg3s/B9C9g+oTyp6RtIldR51OOkP5/6nSy6itUVPcMNOp4M/hDdKOz3uK6srbdxOrc2cJgr1Sg02oBxxSky6V7JaG+ziNwlfqnjnvh2/uq1lKfbp+qpwq/D/5OI5gkFl5CejKGxfc2YVJfGqc4E0x5e9PHK2ukbHNI7/RZV6LNe65apbTGjoCaQls0txPPbmQbCQn+/upCoXRZy9yzorWJvZ0KWcbXlBxU/d5I4ERUTxMuVWhSMmF677LNN7NnLwsmKawXkCgbrpcluOl0WChR1qhtSrxGXHu251dEItYhYX3snvn1gS2uXuzdTxCJjZtjsip0iT2sDC0qMS7Bk9su2NyXjFK5/f5ZoWwofg3DtTyjaFqspnOOTSh8xK/CKUFS57guVEkw9xoQuRCwwEO9Lu9z2vYxSa9NFV8DvSxv2C4WYLYF8Nrc4DzWkzNsk81JJOlZ/LYJrGCoj4MmZpnf3AXmzxT4rtl9jsqljEyedz468SGKdBiQzyz/qWKEhFg45ZczlZZ3KGL3l6sn+3TTa3zMVMhPa1obGp/z+fvY0QXTrJTf1XAT3EtQdUfYYlmWZyvPZ/6rWwU7UOQei7pVE0osgN94Iy+T1+omE6z4Rh2O20FjgBeK2y1mcoFiMDOJvuZPn5Moy9fmFH3wyfKvn4+TwfLvt/lHTTVnvrtoUWRBiQXhiNM8nE6ZoWeux/Z0b2unRcdUzdDpmL7CAgd1ToRXwgmHTZOgiGtVT+xr1QH9ObebRTT4NzL+XSpLuuWp62GqQvJVTPoZOeJCb6gIwd9XHMftQ+Kc08IKKdKQANSJ1a2gve3JdRhO0+tNiYzWAZfd7isoeBu67W7xuK8WX7nhJURld98Inb0t/dWOSau/kDvV4DJo/cImw9AO2Gvq0F2n0M7yIZKL8amMbjYld+qFls7hq8Acvq97K2PrCaomuUiesu7qNanGupEl6J/iem8lyr/NMnsTr6o41PO0yhQh3hPFN0wJP7S830je9iTBLzUNgYH+gUZpROo3rN2qgCI+6GewpX8w8CH+ro6QrWiStqmcMzVa3vEel+3/dDxMp0rDv1Q6wTMS3K64zTT6RWzK1y643im25Ja7X2ePCV2mTswd/4jshZPo4bLnerqIosq/hy2bKUAmVn9n4oun1+a0DIZ56UhVwmZHdUNpLa8gmPvxS1eNvCF1T0wo1wKPdCJi0qOrWz7oYRTzgTtkzEzZn308XSLwUog4OWGKJzCn/3FfF9iA32dZHSv30pRCM3KBY9WZoRhtdK/ChHk6DEQBsfV6tN2o1Cn0mLtPBfnkS+qy1L2xfFe9TQPtDE1Be44RTl82E9hPT2rS2+93LFbzhQQO3C/hD2jRFH3BWWbasAfuMhRJFcTri73eE835y016s22DjoFJ862WvLj69fu2TgSF3RHia9D5DSitlQAXYCnbdqjPkR287Lh6dCHDapos+eFDvcZPP2edPmTFxznJE/EBLoQQ0Qmn9EkZOyJmHxMbvKYb8o21ZHmv5YLqgsEPk9gWZwYQY9wLqGXuax/8QlV5qDaPbq9pLPT1yp+zOWKmraEy1OUJI7zdEcEmvBpbdwLrDCgEb2xX8S/nxZgjK4bRi+pbOmbh8bEeoPvU/L9ndx9kntlDALbdAvp0O8ZC3zSUnFg4cePsw7jxewWvL7HRSBLUn6J7vTH9uld5N76JFPgBCdXGF221oEJk++XfRwXplLSyrVO7HFWBEs99nTazKveW3HpbD4dH/YmdAl+lwbSt8BQWyTG7jAsACI7bPPUU9hI9XUHWqQOuezHzUjnx5Qqs6T1qNHfTTHleDtmqK7flA9a0gz2nycIpz1FHBuWxKNtUeTdqP29Fb3tv+tl5JyBqXoR+vCsdzZwZUhf6Lu8bvkB9yQP4x7GGegB0ym0Lpl03Q7e+C0cDsm9GSDepCDji7nUslLyYyluPfvLyKaDSX4xpR+nVYQjQQn5F8KbY1gbIVLiK1J3mW90zTyR1bqApX2BlWh7KG8LAY9/S9nWC0XXh9pZZo6xuir12T43rkaGfQssbQyIslA7uJnSHOV22NhlNtUo0czxPAsXhh8tIQYaTM4l/yAlZlydTcXhlG22Gs/n3BxKBd/3ZjYwg3NaUurVXhNB+afVnFfNr9TbC9ksNdvwpNfeHanyJ8M6GrIVfLlYAPv0ILe4dn0Z+BJSbJkN7eZY/c6+6ttDYcIDeUKIDXqUSE42Xdh5nRbuaObozjht0HJ5H1e+em+NJi/+8kQlyjCbJpPckwThZeIF9/u7lrVIKNeJLCN/TpPAeXxvd31/CUDWHK9MuP1V1TJgngzi4V0qzS3SW3Qy5UiGHqg02wQa5tsEl9s/X9nNMosgLlUgZSfCBj1DiypLfhr9/r0nR0XY2tmhDOcUS4E7cqa4EJBhzqvpbZa35Q5Iz5EqmhYiOGDAYk606Tv74+KGfPjKVuP15rIzgW0I7/niOu9el/sn2bRye0gV+GrePDRDMHjwO1lEdeXH8N+UTO3IoN18kpI3tPxz+fY+n2MGMSGFHAx/83tKeJOl+2i+f1O9v6FfEDBbqrw+lpM8Anav7zHNr7hE78nXUtPNodMbCnITWA7Ma/IHlZ50F9hWge/wzOvSbtqFVFtkS8Of2nssjZwbSFdU+VO8z6tCEc9UA9ACxT5zIUeSrkBB/v1krOpm7bVMrGxEKfI6LcnpB4D8bvn2hDKGqKrJaVAJuDaBEY3F7eXyqnFWlOoFV/8ZLspZiZd7orXLhd4mhHQgbuKbHjJWUzrnm0Dxw/LJLzXCkh7slMxKo8uxZIWZfdKHlfI7uj3LP6ARAuWdF7ZmZ7daOKqKGbz5LxOggTgS39oEioYmrqkCeUDvbxkBYKeHhcLmMN8dMF01ZMb32IpL/cH8R7VHQSI5I0YfL14g9d7P/6cjB1JXXxbozEDbsrPdmL8ph7QW10jio+v7YsqHKQ6xrBbOVtxU0/nFfzUGZwIBLwyUvg49ii+54nv9FyECBpURnQK4Ox6N7lw5fsjdd5l/2SwBcAHMJoyjO1Pifye2dagaOwCVMqdJWAo77pvBe0zdJcTWu5fdzPNfV2p1pc7/JKQ8zhKkwsOELUDhXygPJ5oR8Vpk2lsCen3D3QOQp2zdrSZHjVBstDF/wWO98rrkQ6/7zt/Drip7OHIug1lomNdmRaHRrjmqeodn22sesQQPgzimPOMqC60a5+i/UYh51uZm+ijWkkaI2xjrBO2558DZNZMiuDQlaVAvBy2wLn/bR3FrNzfnO/9oDztYqxZrr7JMIhqmrochbqmQnKowxW29bpqTaJu7kW1VotC72QkYX8OoDDdMDwV1kJRk3mufgJBzf+iwFRJ7XWQwO5ujVglgFgHtycWiMLx5N+6XU+TulLabWjOzoao03fniUW0xvIJNPbk7CQlFZd/RCOPvgQbLjh5ITE8NVJeKt3HGr6JTnFdIzcVOlEtwqbIIX0IM7saC+4N5047MTJ9+Wn11EhyEPIlwsHE5utCeXRjQzlrR+R1Cf/qDzcNbqLXdk3J7gQ39VUrrEkS/VMWjjg+t2oYrqB0tUZClcUF6+LBC3EQ7KnGIwm/qjZX4GKPtjTX1zQKV6nPAb2t/Rza5IqKRf8i2DFEhV/YSifX0YwsiF6TQnp48Gr65TFq0zUe6LGjiY7fq0LSGKL1VnC6ESI2yxvt3XqBx53B3gSlGFeJcPbUbonW1E9E9m4NfuwPh+t5QjRxX34lvBPVxwQd7aeTd+r9dw5CiP1pt8wMZoMdni7GapYdo6KPgeQKcmlFfq4UYhvV0IBgeiR3RnTMBaqDqpZrTRyLdsp4l0IXZTdErfH0sN3dqBG5vRIx3VgCYcHmmkqJ8Hyu3s9K9uBD1d8cZUEx3qYcF5vsqeRpF1GOg8emeWM2OmBlWPdZ6qAXwm3nENFyh+kvXk132PfWAlN0kb7yh4fz2T7VWUY/hEXX5DvxGABC03XRpyOG8t/u3Gh5tZdpsSV9AWaxJN7zwhVglgII1gV28tUViyqn4UMdIh5t+Ea2zo7PO48oba0TwQbiSZOH4YhD578kPF3reuaP7LujPMsjHmaDuId9XEaZBCJhbXJbRg5VCk3KJpryH/+8S3wdhR47pdFcmpZG2p0Bpjp/VbvalgIZMllYX5L31aMPdt1J7r/7wbixt0Mnz2ZvNGTARHPVD+2O1D8SGpWXlVnP2ekgon55YiinADDynyaXtZDXueVqbuTi8z8cHHK325pgqM+mWZwzHeEreMvhZopAScXM14SJHpGwZyRljMlDvcMm9FZ/1e9+r/puOnpXOtc9Iu2fmgBfEP9cGW1Fzb1rGlfJ08pACtq1ZW18bf2cevebzVeHbaA50G9qoUp39JWdPHbYkPCRXjt4gzlq3Cxge28Mky8MoS/+On72kc+ZI2xBtgJytpAQHQ1zrEddMIVyR5urX6yBNu8v5lKC8eLdGKTJtbgIZ3ZyTzSfWmx9f+cvcJe8yM39K/djkp2aUTE/9m2Lj5jg7b8vdRAer7DO3SyLNHs1CAm5x5iAdh2yGJYivArZbCBNY88Tw+w+C1Tbt7wK3zl2rzTHo/D8/gb3c3mYrnEIEipYqPUcdWjnTsSw471O3EUN7Gtg4NOAs9PJrxm03VuZKa5xwXAYCjt7Gs01Km6T2DhOYUMoFcCSu7Hk1p3yP1eG+M3v3Q5luAze6WwBnZIYO0TCucPWK+UJ36KoJ8Y+vpavhLO8g5ed704IjlQdfemrMu//EvPYXTQSGIPPfiagJS9nMqP5IvkxN9pvuJz7h8carPXTKMq8jnTeL0STan6dnLTAqwIswcIwWDR2KwbGddAVN8SYWRB7kfBfBRkSXzvHlIF8D6jo64kUzYk5o/n8oLjKqat0rdXvQ86MkwQGMnnlcasqPPT2+mVtUGb32KuH6cyZQenrRG11TArcAl27+nvOMBDe++EKHf4YdyGf7mznzOz33cFFGEcv329p4qG2hoaQ8ULiMyVz6ENcxhoqGnFIdupcn7GICQWuw3yO3W8S33mzCcMYJ8ywc7U7rmaQf/W5K63Gr4bVTpXOyOp4tbaPyIaatBNpXqlmQUTSZXjxPr19+73PSaT+QnI35YsWn6WpfJjRtK8vlJZoTSgjaRU39AGCkWOZtifJrnefCrqwTKDFmuWUCukEsYcRrMzCoit28wYpP7kSVjMD8WJYQiNc2blMjuqYegmf6SsfC1jqz8XzghMlOX+gn/MKZmgljszrmehEa4V98VreJDxYvHr3j7IeJB9/sBZV41BWT/AZAjuC5XorlIPnZgBAniBEhanp0/0+qZmEWDpu8ige1hUPIyTo6T6gDEcFhWSoduNh8YSu65KgMOGBw7VlNYzNIgwHtq9KP2yyTVysqX5v12sf7D+vQUdR2dRDvCV40rIInXSLWT/yrC6ExOQxBJwIDbeZcl3z1yR5Rj3l8IGpxspapnvBL+fwupA3b6fkFceID9wgiM1ILB0cHVdvo/R4xg8yqKXT8efl0GnGX1/27FUYeUW2L/GNRGGWVGp3i91oaJkb4rybENHre9a2P5viz/yqk8ngWUUS+Kv+fu+9BLFnfLiLXOFcIeBJLhnayCiuDRSqcx0Qu68gVsGYc6EHD500Fkt+gpDj6gvr884n8wZ5o6q7xtL5wA0beXQnffWYkZrs2NGIRgQbsc5NB302SVx+R4ROvmgZaR8wBcji128BMfJ9kcvJ4DC+bQ57kRmv5yxgU4ngZfn0/JNZ8JBwxjTqS+s9kjJFG1unGUGLwMiIuXUD9EFhNIJuyCEAmVZSIGKH4G6v1gRR1LyzQKH2ZqiI1DnHMoDEZspbDjTeaFIAbSvjSq3A+n46y9hhVM8wIpnARSXyzmOD96d9UXvFroSPgGw1dq2vdEqDq9fJN1EbL2WulNmHkFDvxSO9ZT/RX/Bw2gA/BrF90XrJACereVfbV/YXaKfp77Nmx5NjEIUlxojsy7iN7nBHSZigfsbFyVOX1ZTeCCxvqnRSExP4lk5ZeYlRu9caaa743TWNdchRIhEWwadsBIe245C8clpaZ4zrPsk+OwXzxWCvRRumyNSLW5KWaSJyJU95cwheK76gr7228spZ3hmTtLyrfM2QRFqZFMR8/Q6yWfVgwTdfX2Ry4w3+eAO/5VT5nFb5NlzXPvBEAWrNZ6Q3jbH0RF4vcbp+fDngf/ywpoyNQtjrfvcq93AVb1RDWRghvyqgI2BkMr1rwYi8gizZ0G9GmPpMeqPerAQ0dJbzx+KAFM4IBq6iSLpZHUroeyfd9o5o+4fR2EtsZBoJORQEA4SW0CmeXSnblx2e9QkCHIodyqV6+g5ETEpZsLqnd/Na60EKPX/tQpPEcO+COIBPcQdszDzSiHGyQFPly/7KciUh1u+mFfxTCHGv9nn2WqndGgeGjQ/kr02qmTBX7Hc1qiEvgiSz1Tz/sy7Es29wvn6FrDGPP7asXlhOaiHxOctPvTptFA1kHFUk8bME7SsTSnGbFbUrssxrq70LhoSh5OwvQna+w84XdXhZb2sloJ4ZsCg3j+PrjJL08/JBi5zGd6ud/ZxhmcGKLOXPcNunQq5ESW92iJvfsuRrNYtawWwSmNhPYoFj2QqWNF0ffLpGt/ad24RJ8vkb5sXkpyKXmvFG5Vcdzf/44k3PBL/ojJ52+kWGzOArnyp5f969oV3J2c4Li27Nkova9VwRNVKqN0V+gV+mTHitgkXV30aWd3A1RSildEleiNPA+5cp+3+T7X+xfHiRZXQ1s4FA9TxIcnveQs9JSZ5r5qNmgqlW4zMtZ6rYNvgmyVcywKtu8ZxnSbS5vXlBV+NXdIfi3+xzrnJ0TkFL+Un8v1PWOC2PPFCjVPq7qTH7mOpzOYj/b4h0ceT+eHgr97Jqhb1ziVfeANzfN8bFUhPKBi7hJBCukQnB0aGjFTYLJPXL26lQ2b80xrOD5cFWgA8hz3St0e69kwNnD3+nX3gy12FjrjO+ddRvvvfyV3SWbXcxqNHfmsb9u1TV+wHTb9B07/L2sB8WUHJ9eeNomDyysEWZ0deqEhH/oWI2oiEh526gvAK1Nx2kIhNvkYR+tPYHEa9j+nd1VBpQP1uzSjIDO+fDDB7uy029rRjDC5Sk6aKczyz1D5uA9Lu+Rrrapl8JXNL3VRllNQH2K1ZFxOpX8LprttfqQ56MbPM0IttUheXWD/mROOeFqGUbL+kUOVlXLTFX/525g4faLEFO4qWWdmOXMNvVjpIVTWt650HfQjX9oT3Dg5Au6+v1/Ci78La6ZOngYCFPT1AUwxQuZ0yt5xKdNXLaDTISMTeCj16XTryhM36K2mfGRIgot71voWs8tTpL/f1rvcwv3LSDf+/G8THCT7NpfHWcW+lsF/ol8q9Bi6MezNTqp0rpp/kJRiVfNrX/w27cRRTu8RIIqtUblBMkxy4jwAVqCjUJkiPBj2cAoVloG8B2/N5deLdMhDb7xs5nhd3dubJhuj8WbaFRyu1L678DHhhA+rMimNo4C1kGpp0tD/qnCfCFHejpf0LJX43OTr578PY0tnIIrlWyNYyuR/ie6j2xNb1OV6u0dOX/1Dtcd7+ya9W+rY2LmnyQMtk8SMLTon8RAdwOaN2tNg5zVnDKlmVeOxPV2vhHIo9QEPV7jc3f+zVDquiNg1OaHX3cZXJDRY5MJpo+VanAcmqp4oasYLG+wrXUL5vJU0kqk2hGEskhP+Jjigrz1l6QnEwp6n8PMVeJp70Ii6ppeaK9GhF6fJE00ceLyxv08tKiPat4QdxZFgSbQknnEiCLD8Qc1rjazVKM3r3gXnnMeONgdz/yFV1q+haaN+wnF3Fn4uYCI9XsKOuVwDD0LsCO/f0gj5cmxCFcr7sclIcefWjvore+3aSU474cyqDVxH7w1RX3CHsaqsMRX17ZLgjsDXws3kLm2XJdM3Ku383UXqaHqsywzPhx7NFir0Fqjym/w6cxD2U9ypa3dx7Z12w/fi3Jps8sqJ8f8Ah8aZAvkHXvIRyrsxK7rrFaNNdNvjI8+3Emri195DCNa858anj2Qdny6Czshkn4N2+1m+k5S8sunX3Ja7I+JutRzg1mc2e9Yc0Zv9PZn1SwhxIdU9sXwZRTd/J5FoUm0e+PYREeHg3oc2YYzGf2xfJxXExt4pT3RfDRHvMXLUmoXOy63xv5pLuhOEax0dRgSywZ/GH+YBXFgCeTU0hZ8SPEFsn8punp1Kurd1KgXxUZ+la3R5+4ePGR4ZF5UQtOa83+Vj8zh80dfzbhxWCeoJnQ4dkZJM4drzknZOOKx2n3WrvJnzFIS8p0xeic+M3ZRVXIp10tV2DyYKwRxLzulPwzHcLlYTxl4PF7v8l106Azr+6wBFejbq/3P72C/0j78cepY9990/d4eAurn2lqdGKLU8FffnMw7cY7pVeXJRMU73Oxwi2g2vh/+4gX8dvbjfojn/eLVhhYl8GthwCQ50KcZq4z2JeW5eeOnJWFQEnVxDoG459TaC4zXybECEoJ0V5q1tXrQbDMtUxeTV6Pdt1/zJuc7TJoV/9YZFWxUtCf6Ou3Vd/vR/vG0138hJQrHkNeoep5dLe+6umcSquKvMaFpm3EZHDBOvCi0XYyIFHMgX7Cqp3JVXlxJFwQfHSaIUEbI2u1lBVUdlNw4Qa9UsLPEK94Qiln3pyKxQVCeNlx8yd7EegVNQBkFLabKvnietYVB4IPZ1fSor82arbgYec8aSdFMaIluYTYuNx32SxfrjKUdPGq+UNp5YpydoEG3xVLixtmHO9zXxKAnHnPuH2fPGrjx0GcuCDEU+yXUtXh6nfUL+cykws1gJ5vkfYFaFBr9PdCXvVf35OJQxzUMmWjv0W6uGJK11uAGDqSpOwCf6rouSIjPVgw57cJCOQ4b9tkI/Y5WNon9Swe72aZryKo8d+HyHBEdWJKrkary0LIGczA4Irq353Wc0Zga3om7UQiAGCvIl8GGyaqz5zH+1gMP5phWUCpKtttWIyicz09vXg76GxkmiGSMQ06Z9X8BUwqOtauDbPIf4rpK/yYoeAHxJ9soXS9VDe1Aw+awOOxaN8foLrif0TXBvQ55dtRtulRq9emFDBxlQcqKCaD8NeTSE7FOHvcjf/+oKbbtRqz9gbofoc2EzQ3pL6W5JdfJzAWmOk8oeoECe90lVMruwl/ltM015P/zIPazqvdvFmLNVHMIZrwiQ2tIKtGh6PDVH+85ew3caqVt2BsDv5rOcu3G9srQWd7NmgtzCRUXLYknYRSwtH9oUtkqyN3CfP20xQ1faXQl4MEmjQehWR6GmGnkdpYNQYeIG408yAX7uCZmYUic9juOfb+Re28+OVOB+scYK4DaPcBe+5wmji9gymtkMpKo4UKqCz7yxzuN8VIlx9yNozpRJpNaWHtaZVEqP45n2JemTlYBSmNIK1FuSYAUQ1yBLnKxevrjayd+h2i8PjdB3YY6b0nr3JuOXGpPMyh4V2dslpR3DFEvgpsBLqhqLDOWP4yEvIL6f21PpA7/8B";
      var trieData = {
        data: data$1
      };

      var log2 = (<any>Math).log2 || function (n) {
        return Math.log(n) / Math.LN2;
      };

      var bits = function bits(n) {
        return log2(n) + 1 | 0;
      };

      var buildUnicodeProperties = function buildUnicodeProperties(data, trie) {
        // compute the number of bits stored for each field
        var CATEGORY_BITS = bits(data.categories.length - 1);
        var COMBINING_BITS = bits(data.combiningClasses.length - 1);
        var SCRIPT_BITS = bits(data.scripts.length - 1);
        var EAW_BITS = bits(data.eaw.length - 1);
        var NUMBER_BITS = 10; // compute shift and mask values for each field

        var CATEGORY_SHIFT = COMBINING_BITS + SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
        var COMBINING_SHIFT = SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
        var SCRIPT_SHIFT = EAW_BITS + NUMBER_BITS;
        var EAW_SHIFT = NUMBER_BITS;
        var CATEGORY_MASK = (1 << CATEGORY_BITS) - 1;
        var COMBINING_MASK = (1 << COMBINING_BITS) - 1;
        var SCRIPT_MASK = (1 << SCRIPT_BITS) - 1;
        var EAW_MASK = (1 << EAW_BITS) - 1;
        var NUMBER_MASK = (1 << NUMBER_BITS) - 1;

        var getCategory = function getCategory(codePoint) {
          var val = trie.get(codePoint);
          return data.categories[val >> CATEGORY_SHIFT & CATEGORY_MASK];
        };

        var getCombiningClass = function getCombiningClass(codePoint) {
          var val = trie.get(codePoint);
          return data.combiningClasses[val >> COMBINING_SHIFT & COMBINING_MASK];
        };

        var getScript = function getScript(codePoint) {
          var val = trie.get(codePoint);
          return data.scripts[val >> SCRIPT_SHIFT & SCRIPT_MASK];
        };

        var getEastAsianWidth = function getEastAsianWidth(codePoint) {
          var val = trie.get(codePoint);
          return data.eaw[val >> EAW_SHIFT & EAW_MASK];
        };

        var getNumericValue = function getNumericValue(codePoint) {
          var val = trie.get(codePoint);
          var num = val & NUMBER_MASK;

          if (num === 0) {
            return null;
          } else if (num <= 50) {
            return num - 1;
          } else if (num < 0x1e0) {
            var numerator = (num >> 4) - 12;
            var denominator = (num & 0xf) + 1;
            return numerator / denominator;
          } else if (num < 0x300) {
            val = (num >> 5) - 14;
            var exp = (num & 0x1f) + 2;

            while (exp > 0) {
              val *= 10;
              exp--;
            }

            return val;
          } else {
            val = (num >> 2) - 0xbf;

            var _exp = (num & 3) + 1;

            while (_exp > 0) {
              val *= 60;
              _exp--;
            }

            return val;
          }
        };

        var isAlphabetic = function isAlphabetic(codePoint) {
          var category = getCategory(codePoint);
          return category === 'Lu' || category === 'Ll' || category === 'Lt' || category === 'Lm' || category === 'Lo' || category === 'Nl';
        };

        var isDigit = function isDigit(codePoint) {
          return getCategory(codePoint) === 'Nd';
        };

        var isPunctuation = function isPunctuation(codePoint) {
          var category = getCategory(codePoint);
          return category === 'Pc' || category === 'Pd' || category === 'Pe' || category === 'Pf' || category === 'Pi' || category === 'Po' || category === 'Ps';
        };

        var isLowerCase = function isLowerCase(codePoint) {
          return getCategory(codePoint) === 'Ll';
        };

        var isUpperCase = function isUpperCase(codePoint) {
          return getCategory(codePoint) === 'Lu';
        };

        var isTitleCase = function isTitleCase(codePoint) {
          return getCategory(codePoint) === 'Lt';
        };

        var isWhiteSpace = function isWhiteSpace(codePoint) {
          var category = getCategory(codePoint);
          return category === 'Zs' || category === 'Zl' || category === 'Zp';
        };

        var isBaseForm = function isBaseForm(codePoint) {
          var category = getCategory(codePoint);
          return category === 'Nd' || category === 'No' || category === 'Nl' || category === 'Lu' || category === 'Ll' || category === 'Lt' || category === 'Lm' || category === 'Lo' || category === 'Me' || category === 'Mc';
        };

        var isMark = function isMark(codePoint) {
          var category = getCategory(codePoint);
          return category === 'Mn' || category === 'Me' || category === 'Mc';
        };

        return {
          getCategory: getCategory,
          getCombiningClass: getCombiningClass,
          getScript: getScript,
          getEastAsianWidth: getEastAsianWidth,
          getNumericValue: getNumericValue,
          isAlphabetic: isAlphabetic,
          isDigit: isDigit,
          isPunctuation: isPunctuation,
          isLowerCase: isLowerCase,
          isUpperCase: isUpperCase,
          isTitleCase: isTitleCase,
          isWhiteSpace: isWhiteSpace,
          isBaseForm: isBaseForm,
          isMark: isMark
        };
      };

      var trie = new UnicodeTrie(base64.toByteArray(trieData.data));
      var unicodeProperties = buildUnicodeProperties(data, trie);
      localModule.localExports = unicodeProperties;
    }, {
      "base64-js": 122,
      "unicode-trie": 126
    }],
    126: [function (localRequire, localModule, localExports) {

      var inflate = localRequire('tiny-inflate');

      var _require = localRequire('./swap'),
        swap32LE = _require.swap32LE; // Shift size for getting the index-1 table offset.


      var SHIFT_1 = 6 + 5; // Shift size for getting the index-2 table offset.

      var SHIFT_2 = 5; // Difference between the two shift sizes,
      // for getting an index-1 offset from an index-2 offset. 6=11-5

      var SHIFT_1_2 = SHIFT_1 - SHIFT_2; // Number of index-1 entries for the BMP. 32=0x20
      // This part of the index-1 table is omitted from the serialized form.

      var OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1; // Number of entries in an index-2 block. 64=0x40

      var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2; // Mask for getting the lower bits for the in-index-2-block offset. */

      var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1; // Shift size for shifting left the index array values.
      // Increases possible data size with 16-bit index values at the cost
      // of compactability.
      // This requires data blocks to be aligned by DATA_GRANULARITY.

      var INDEX_SHIFT = 2; // Number of entries in a data block. 32=0x20

      var DATA_BLOCK_LENGTH = 1 << SHIFT_2; // Mask for getting the lower bits for the in-data-block offset.

      var DATA_MASK = DATA_BLOCK_LENGTH - 1; // The part of the index-2 table for U+D800..U+DBFF stores values for
      // lead surrogate code _units_ not code _points_.
      // Values for lead surrogate code _points_ are indexed with this portion of the table.
      // Length=32=0x20=0x400>>SHIFT_2. (There are 1024=0x400 lead surrogates.)

      var LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;
      var LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2; // Count the lengths of both BMP pieces. 2080=0x820

      var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH; // The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
      // Length 32=0x20 for lead bytes C0..DF, regardless of SHIFT_2.

      var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
      var UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; // U+0800 is the first code point after 2-byte UTF-8
      // The index-1 table, only used for supplementary code points, at offset 2112=0x840.
      // Variable length, for code points up to highStart, where the last single-value range starts.
      // Maximum length 512=0x200=0x100000>>SHIFT_1.
      // (For 0x100000 supplementary code points U+10000..U+10ffff.)
      //
      // The part of the index-2 table for supplementary code points starts
      // after this index-1 table.
      //
      // Both the index-1 table and the following part of the index-2 table
      // are omitted completely if there is only BMP data.

      var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH; // The alignment size of a data block. Also the granularity for compaction.

      var DATA_GRANULARITY = 1 << INDEX_SHIFT;

      var UnicodeTrie = /*#__PURE__*/function () {
        function UnicodeTrie(data) {
          var isBuffer = typeof data.readUInt32BE === 'function' && typeof data.slice === 'function';

          if (isBuffer || data instanceof Uint8Array) {
            // read binary format
            var uncompressedLength;

            if (isBuffer) {
              this.highStart = data.readUInt32LE(0);
              this.errorValue = data.readUInt32LE(4);
              uncompressedLength = data.readUInt32LE(8);
              data = data.slice(12);
            } else {
              var view = new DataView(data.buffer);
              this.highStart = view.getUint32(0, true);
              this.errorValue = view.getUint32(4, true);
              uncompressedLength = view.getUint32(8, true);
              data = data.subarray(12);
            } // double inflate the actual trie data


            data = inflate(data, new Uint8Array(uncompressedLength));
            data = inflate(data, new Uint8Array(uncompressedLength)); // swap bytes from little-endian

            swap32LE(data);
            this.data = new Uint32Array(data.buffer);
          } else {
            // pre-parsed data
            var _data = data;
            this.data = _data.data;
            this.highStart = _data.highStart;
            this.errorValue = _data.errorValue;
          }
        }

        var _proto = UnicodeTrie.prototype;

        _proto.get = function get(codePoint) {
          var index;

          if (codePoint < 0 || codePoint > 0x10ffff) {
            return this.errorValue;
          }

          if (codePoint < 0xd800 || codePoint > 0xdbff && codePoint <= 0xffff) {
            // Ordinary BMP code point, excluding leading surrogates.
            // BMP uses a single level lookup.  BMP index starts at offset 0 in the index.
            // data is stored in the index array itself.
            index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
            return this.data[index];
          }

          if (codePoint <= 0xffff) {
            // Lead Surrogate Code Point.  A Separate index section is stored for
            // lead surrogate code units and code points.
            //   The main index has the code unit data.
            //   For this function, we need the code point data.
            index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 0xd800 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
            return this.data[index];
          }

          if (codePoint < this.highStart) {
            // Supplemental code point, use two-level lookup.
            index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
            index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
            index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
            return this.data[index];
          }

          return this.data[this.data.length - DATA_GRANULARITY];
        };

        return UnicodeTrie;
      }();

      localModule.localExports = UnicodeTrie;
    }, {
      "./swap": 127,
      "tiny-inflate": 124
    }],
    127: [function (localRequire, localModule, localExports) {
      var isBigEndian = new Uint8Array(new Uint32Array([0x12345678]).buffer)[0] === 0x12;

      var swap = function swap(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      };

      var swap32 = function swap32(array) {
        var len = array.length;

        for (var i = 0; i < len; i += 4) {
          swap(array, i, i + 3);
          swap(array, i + 1, i + 2);
        }
      };

      var swap32LE = function swap32LE(array) {
        if (isBigEndian) {
          swap32(array);
        }
      };

      localModule.localExports = {
        swap32LE: swap32LE
      };
    }, {}],
    128: [function (localRequire, localModule, localExports) {
      arguments[4][122][0].apply(localExports, arguments);
    }, {
      "dup": 122
    }],
    129: [function (localRequire, localModule, localExports) {
      arguments[4][124][0].apply(localExports, arguments);
    }, {
      "dup": 124
    }],
    130: [function (localRequire, localModule, localExports) {
      arguments[4][126][0].apply(localExports, arguments);
    }, {
      "./swap": 131,
      "dup": 126,
      "tiny-inflate": 129
    }],
    131: [function (localRequire, localModule, localExports) {
      arguments[4][127][0].apply(localExports, arguments);
    }, {
      "dup": 127
    }],
    132: [function (localRequire, localModule, localExports) {
      // The following break classes are handled by the pair table
      localExports.OP = 0; // Opening punctuation

      localExports.CL = 1; // Closing punctuation

      localExports.CP = 2; // Closing parenthesis

      localExports.QU = 3; // Ambiguous quotation

      localExports.GL = 4; // Glue

      localExports.NS = 5; // Non-starters

      localExports.EX = 6; // Exclamation/Interrogation

      localExports.SY = 7; // Symbols allowing break after

      localExports.IS = 8; // Infix separator

      localExports.PR = 9; // Prefix

      localExports.PO = 10; // Postfix

      localExports.NU = 11; // Numeric

      localExports.AL = 12; // Alphabetic

      localExports.HL = 13; // Hebrew Letter

      localExports.ID = 14; // Ideographic

      localExports.IN = 15; // Inseparable characters

      localExports.HY = 16; // Hyphen

      localExports.BA = 17; // Break after

      localExports.BB = 18; // Break before

      localExports.B2 = 19; // Break on either side (but not pair)

      localExports.ZW = 20; // Zero-width space

      localExports.CM = 21; // Combining marks

      localExports.WJ = 22; // Word joiner

      localExports.H2 = 23; // Hangul LV

      localExports.H3 = 24; // Hangul LVT

      localExports.JL = 25; // Hangul L Jamo

      localExports.JV = 26; // Hangul V Jamo

      localExports.JT = 27; // Hangul T Jamo

      localExports.RI = 28; // Regional Indicator

      localExports.EB = 29; // Emoji Base

      localExports.EM = 30; // Emoji Modifier

      localExports.ZWJ = 31; // Zero Width Joiner

      localExports.CB = 32; // Contingent break
      // The following break classes are not handled by the pair table

      localExports.AI = 33; // Ambiguous (Alphabetic or Ideograph)

      localExports.BK = 34; // Break (mandatory)

      localExports.CJ = 35; // Conditional Japanese Starter

      localExports.CR = 36; // Carriage return

      localExports.LF = 37; // Line feed

      localExports.NL = 38; // Next line

      localExports.SA = 39; // South-East Asian

      localExports.SG = 40; // Surrogates

      localExports.SP = 41; // Space

      localExports.XX = 42; // Unknown
    }, {}],
    133: [function (localRequire, localModule, localExports) {

      var UnicodeTrie = localRequire('unicode-trie');
      var base64 = localRequire('base64-js');

      var _require = localRequire('./classes'),
        BK = _require.BK,
        CR = _require.CR,
        LF = _require.LF,
        NL = _require.NL,
        SG = _require.SG,
        WJ = _require.WJ,
        SP = _require.SP,
        ZWJ = _require.ZWJ,
        BA = _require.BA,
        HY = _require.HY,
        NS = _require.NS,
        AI = _require.AI,
        AL = _require.AL,
        CJ = _require.CJ,
        HL = _require.HL,
        RI = _require.RI,
        SA = _require.SA,
        XX = _require.XX;

      var _require2 = localRequire('./pairs'),
        DI_BRK = _require2.DI_BRK,
        IN_BRK = _require2.IN_BRK,
        CI_BRK = _require2.CI_BRK,
        CP_BRK = _require2.CP_BRK,
        PR_BRK = _require2.PR_BRK,
        pairTable = _require2.pairTable;

      var data = base64.toByteArray("AAgOAAAAAABA2gAAAZ8OYPHtnQ2s1lUdx8/l3vvc+zz3uVzvhQuR4I23CMqRqdkbM42lqRlM1iSohrQaVjMmrZjmRIWEphOITWUtlbXhmI2GLowxC+cge6GcxrImw5oQtmmgWdpm37PnnD3nHs77y///gM/dPjv/8z9vv/M7v/P6//+f+71OQtaCu8AWsBc8BX4HngN/AX8LcI+DE+BNMKaLkB4w0GVPNxFxRgzxZiLsXHAhmAc+Ba4EC8FiId2XcP1V8E3wbXATuB3cBjaATeB+8BB4GDzC0lIew/Ve8BT4Lfg9+BN4AbwEjoFXwX8A6Ub9QBUMgkndjfCpcGd3N8Kp/4NwPwI+CS4FV4CFYDG4A+HL4K4AK1n81XDXsPTrwUZwH3iwuyHjdrg7wW7wC7APPNLZ8D8NDjL/IbiHWZqjcF8BJ8FbLPxpFr+z0nB7Kk09UAYqTSYypoARhhjXxCzEnSvFp3q+yCMPFy4W8rsM11eCa8ASsLzSrO/XcX0juEkq/3b4bxBsYS38d4EtQlrKVpZum3B/B653gT2Vht1TaPu+DncfjQeeAc+ztEeYewzuq+ANQZa3cd3do68nzz9GV3XkPx5MBjPAB8AF4BNgPrgcLADXgiVgObieybSSuavhrgHrwUZwH3iAhW2H+1PwmKYejwv3n8D1fokDwvUfwLPgr+Dv4GVwErwFOnsJ6QPjwNlgOng/OB98vJfZBdzLwGeZfxHcJb3+OlvO0lwPd6VH+tUBZd0qpblT8K9lNnYP7t0LHuht9Oftve48DH4GHge/Ar8GfwR/ZtdHLOn/IVz/y6PcNm3axMHHgbLlaNOmTZs2bdq0aXN68XoLyKDif72jz0N0dFQbZ3n0ulJtnKXxsLFVe/oJiHMOizcT7qSuxnnNubi+kOU9D+58cFW1cR74ObAI10tZuq/A/UZ19PkQZRXu3dKlL/tmKi9YC9aB74M7wXqwoR3WDmuHtcPaYcnDNoJ7wdZq48y0TLZVy6Xs+rdp08rErmN3oI/tAj+vhj+n24O0TyrS78e9g+AQeAG8JMU5Dv8J8CYYUyOkBgZqDbkmwh2plT/+rBrb4DVwwQDW0Qa2g2Ng8lmnhi2V7v0Q/mdBfRBr98HGve/CfRT8E/QOEXI5OFJt6OHL4MfgMOjsI+Q8QHoIuaav4Re5DWzuMLMPcV5keVCm1Qm5DjwIjoCp/YQs67fncyazqr+pnzZt2rR5p/Fov3nun4X5aG5NH35e7dQ1Cw/7KMIukdLOh/8qdu98zfkafS/rxsTvZZm4WlO/RYZ6U5bSubob86oi3gp2b6UlDxurFfpVYcpjjUKGdbXGu2Cv4fpuXG9h/h/B/QnYwfy74O4BTzA/PXvcX2ueKx6sjZbhEG3frsY6hr47eBTuK+ANjZ08hzzfFuT7N+jp09dxAX2Ps6/pp/Enwj/Sx+wV7lwWTs9AL9LkxdNf3KfW2SbDuemnkeZq8HnwBXAdy2MF3JWa/HTQ+qxGmlvBWrChb7R8tKxNLM/7hbrZeMggx3aE7fSUMze7W0yeMvgl08EBgy5+owl7xtEuchJa7+cTtj19L/FFQRd033qc5X8C7n8LsjNSV9/vqTfem6zXmzKOr9v38ZNZ/Blw5zjEF6HvWZZtG7628yHU8WP18so3cSnkugIsULTxtZp2b1W+CHmXJZCZ2vQKZtvfgvudevMd8dOBWwy2Ruu3DuF3B+hpc4E2nNr2t9ZHh28roC47mI53JupHu7vsZdrGz92QZW+98R3Ak8w9wMbgg55jMeUQ0hwGR8HLQvqTtM+AMdiT1fqb94dwPQmMgGlgNgubC/fDQrx5uL6E+T8DdyG7FvWxWNjvzWTplrF7X2PuDXDPEfKl52Q394+uwx3w/0DKf3G/vy7OJDbTtukKH4O29pc/FsQyTOwMgplgGmOGQxpXZgMsAUlnYwlGsPwjNXZN79G/MUIYmo2cxVx6JNLnSC+jLlCR/LkhrA5jCixTLp+2ZQfzD5P235x3OKo++V7N/Rx0sXagfb4qQO1zKoNf8zFikDRtmqfjcYektCKdkp+QvP1taub8W738VoPbh2gD3O+qM9mmxDRDlrRFUFS/PR3oCkyjI0SG0HaU1yq2ti3b7nJCdUHHfD5n8ftVop/DWp1Bod2GFdcV5trm7/4WIrR9awLyOt1Hp6LOKqT49X0ZY7Pr/qcmXMsy5axzhdjrbtOPHK6Ky+O46iN1u54JNiWPr2cSPnqok/D9VBn2l1Mncho6NvM+Le4hxX1bEbLq5Jfv6+IVaeut2MeKOkvw6XM55kdf+y6j76Wsuy0vX/kGGUWOa3J/KbN/pGoflz43rLhn01HovMPX26q8+f2qojzVOFp2+6TA1C42GWLWAap+6WovKh0U3R6x+k4tR0h/qBJ7+xc1HxXV/0NsWra5Mvq9Ts5UejfpwDZO5NoH8HHYdc11OvR/1zbJ3f9Nbeh6ni/KXPQzgCLHItO4FKN/37HHZXzMqesUenctL7f9u+StWyeKbRbSZ1OTcj7w7RO+441oB742P6tFkOWqRuZX99Aj35e2um587UKlkyEJ8V6XcD3I/BUFXSyd/EzENh6l3vfLz724S/86BDdmLZNqbTjocN80FpfFHNLsH7Fzi2hburUNfz4eMy7q5I3th67l69JPKpl3l8zZJVPG+kFep5n6UW7KLLvo8ulfBxk9fvjKahv3QnHdF+Xan8jzj2rtU0T5ZezP5P1FmWtlrvtuwc9tT1z/hq7/crUfXwdy+Yek+7KN8fk8h/wxa7uU5Nwnuu4f65Kft0fsuiV2L+drv6Y9XS5M+uVxytz7DXvoL5bU41/s3kleQ5n6YOx+YZCEzf2xsqvq4Ju2qH7hWs9U+/1U46NtPsk5Pst25fMehE7m1OcpuXDtS7b2km0sxfhh6lvD0nXZfZHC11o6m+J0Sf7xTPYRoR5yvHFk9LconaT53WSnwi/GpQwI0Pz4N56qdqDl1iyIMtBy2L8k1Oqml8nWIcQ1xTfZq2i3uvlhgiKtzzwn273LN1a8fuL3QvI3RC7pQ/cDYn+sGqhZwn3T1hLlLZJ6jI/Zz3J7l9uwRtzaRUzn8+6sq93k+P7PVLbqOzrVd5gmdOX5pnPVi9y+OcrzkSm0Liq55HuqcO7K393a2lalC7kOJt2ZbMjFHkLa2lZuiv5g0o3Jn8J+UuXvqrNY3cXK5ctAAhnon/icMlTWsQyfMnPodKxETF4x86oO3/kjJ/XANLJd5JDLpw+lKCtUBldd+uSj8rvel/OIrZ+r3l3T5Ojfpnrb9Mbz4eFjFeVMIWnGk5A66nSYQpcx7a6yOa4/VZwUMhelf1u9i0a2eRty31TZ9FRNfFV/kMPEfqfTk0oOVT4qeaYYylWh0tUUiaJsRPR3aqBh/LmYLD/96whwc8zDofbOZSqyj7jqqYwyfd0y9VZk2UXZSiq7ljGdo8rPwOUz3Apxex5hw/W9Gd2zDN0YZcN07i+eUxOpnuIYKPrpn6lPyPnzdzxU5+IqPY1j6M7SiaIMXZ3EdLH7Qd+5PTWyPPz3FDuEON3Cta2diJTWFq9buBbT2dCdheviqu7zZzOyPqaza5ubm6LKsZXvUm9b2HRy6jPUbgneJq2m/1T1V9nfdKK2Q9EefZgeiU0ntvVijnbQ6caG7/OvmDk41XyuW1/4vm+QWgZxzhNx1a8sk+97EDn0maI812ejofDvVfh+0WVNF/KMOOZ9IJfyY9+RMenHxX5s5eV4zz73s3xaRhnf8Mjtrau/yzuMofbG05f5PZXr/JHzvQ7f8VPO21f/ru3qqgdVPjH1t/Xx2PrLTATvKpCiy/Ndf6b8Vk/Ou4zv9WQZ3lcyOdcadU2b0t/CHSZ+v5vbar/JGws/s/DtDzn2Gz7w9Wmq9VkvaZ7V8N825mtTwu4PGOofW75qn8fLdXXldKY9ZIfgUvn5Xl18fmMrxwZ/n1S1Zy3D1nnZE5jL6ynLqtJhh+T67PHlfX7FM49YSKDsucrnuu2QrrmeUp3pFIHpjCs3Yn+itluVwvm7orb+5jrGi+PVe0jjXKyM/qySzXR2U9bcKq7Hc9Xbp+3K0oOsE5f9YFnycVsqo9w5UvlFnDOF2pvLM0VXW3Bpe105pjVZEfbkqhNbP7DJH7uf9+mPOW0q1u5c1ts5zjx1xLZLUWN3aDv7PhfJ2efK6B++upP7tO938qLthp4XprAV6orfw4bYqPx+icrOfNtPlCv0vDakTXXv4/D2cSnT1H+K7N9F95/UY4BoP7HnLqL8Jtt2rXOsPD5rAtf5UNcvRTv2aX9ux+JYYSsz9/qGlsl//5C/tyD/hqZtzRqyfhPLl+P6tF9s/eXfHnXBR76U809IX7Dps4h1mInY33FylV/+fbNBEvb7TTHjUqqxPHZ8pHkMCXnlaludvRetrxA9qsJV66dBT136tl9RNiGP2eJ4l+rd5lB7CXnPzHd8iF1bcfi7WalslOebam1kwkWftv6Sqj1M9pCzP9jmy5zjT+7xTkeNnPobR6ns1ofYsyeeRyudvciIfx0Ccjz5Ho9PNPFzy6yT07d9TP9/nJeTo31S6S10/Eo1h8boXjd++8gVqz+fNYgKHpZ6/i+i78eer6vmYptOYwiRUf6GJ9befSnznYYU8sd+r5NbP7n7iGnMUJ2FF21frmOa65iXon+m7sMh43jO/Iu0Nd95Ize5bEel11zzhE8binFVZ8kxfde3XkWNH642aatDSrtOIbfLuBFzHuDzm6Ku8vi2v09+KvsNrT//K8smOTWL35eQ36QR1yepf+cmdX71DPLmWMtOLghV2VM091OgaoMiy9DdF3+bSqUHVXjRnKNAlk8lr40UsvmU5yOPSj45rmtdphjy9LEtlasrS5c2tA+Yxu7YNnSdI3LmnatuNrt1ab/Q/F3LTEHRegwpx9TXi/qdQPG3s0z/FyK1TfiOu75lprar1HrPXX5q+VPJl6u/pqyfi+2EriV87N1njVDEuky11ojpa6b1S5FrthhCz3Ryn/H8Hw==");
      var classTrie = new UnicodeTrie(data);

      var mapClass = function mapClass(c) {
        switch (c) {
          case AI:
            return AL;

          case SA:
          case SG:
          case XX:
            return AL;

          case CJ:
            return NS;

          default:
            return c;
        }
      };

      var mapFirst = function mapFirst(c) {
        switch (c) {
          case LF:
          case NL:
            return BK;

          case SP:
            return WJ;

          default:
            return c;
        }
      };

      var Break = function Break(position, required?): void {
        if (required === void 0) {
          required = false;
        }

        this.position = position;
        this.required = required;
      };

      var LineBreaker = /*#__PURE__*/function () {
        function LineBreaker(string) {
          this.string = string;
          this.pos = 0;
          this.lastPos = 0;
          this.curClass = null;
          this.nextClass = null;
          this.LB8a = false;
          this.LB21a = false;
          this.LB30a = 0;
        }

        var _proto = LineBreaker.prototype;

        _proto.nextCodePoint = function nextCodePoint() {
          var code = this.string.charCodeAt(this.pos++);
          var next = this.string.charCodeAt(this.pos); // If a surrogate pair

          if (0xd800 <= code && code <= 0xdbff && 0xdc00 <= next && next <= 0xdfff) {
            this.pos++;
            return (code - 0xd800) * 0x400 + (next - 0xdc00) + 0x10000;
          }

          return code;
        };

        _proto.nextCharClass = function nextCharClass() {
          return mapClass(classTrie.get(this.nextCodePoint()));
        };

        _proto.getSimpleBreak = function getSimpleBreak() {
          // handle classes not handled by the pair table
          switch (this.nextClass) {
            case SP:
              return false;

            case BK:
            case LF:
            case NL:
              this.curClass = BK;
              return false;

            case CR:
              this.curClass = CR;
              return false;
          }

          return null;
        };

        _proto.getPairTableBreak = function getPairTableBreak(lastClass) {
          // if not handled already, use the pair table
          var shouldBreak = false;

          switch (pairTable[this.curClass][this.nextClass]) {
            case DI_BRK:
              // Direct break
              shouldBreak = true;
              break;

            case IN_BRK:
              // possible indirect break
              shouldBreak = lastClass === SP;
              break;

            case CI_BRK:
              shouldBreak = lastClass === SP;

              if (!shouldBreak) {
                shouldBreak = false;
                return shouldBreak;
              }

              break;

            case CP_BRK:
              // prohibited for combining marks
              if (lastClass !== SP) {
                return shouldBreak;
              }

              break;
          }

          if (this.LB8a) {
            shouldBreak = false;
          } // Rule LB21a


          if (this.LB21a && (this.curClass === HY || this.curClass === BA)) {
            shouldBreak = false;
            this.LB21a = false;
          } else {
            this.LB21a = this.curClass === HL;
          } // Rule LB30a


          if (this.curClass === RI) {
            this.LB30a++;

            if (this.LB30a == 2 && this.nextClass === RI) {
              shouldBreak = true;
              this.LB30a = 0;
            }
          } else {
            this.LB30a = 0;
          }

          this.curClass = this.nextClass;
          return shouldBreak;
        };

        _proto.nextBreak = function nextBreak() {
          // get the first char if we're at the beginning of the string
          if (this.curClass == null) {
            var firstClass = this.nextCharClass();
            this.curClass = mapFirst(firstClass);
            this.nextClass = firstClass;
            this.LB8a = firstClass === ZWJ;
            this.LB30a = 0;
          }

          while (this.pos < this.string.length) {
            this.lastPos = this.pos;
            var lastClass = this.nextClass;
            this.nextClass = this.nextCharClass(); // explicit newline

            if (this.curClass === BK || this.curClass === CR && this.nextClass !== LF) {
              this.curClass = mapFirst(mapClass(this.nextClass));
              return new Break(this.lastPos, true);
            }

            var shouldBreak = this.getSimpleBreak();

            if (shouldBreak === null) {
              shouldBreak = this.getPairTableBreak(lastClass);
            } // Rule LB8a


            this.LB8a = this.nextClass === ZWJ;

            if (shouldBreak) {
              return new Break(this.lastPos);
            }
          }

          if (this.pos >= this.string.length) {
            if (this.lastPos < this.string.length) {
              this.lastPos = this.string.length;
              return new Break(this.string.length);
            } else {
              return null;
            }
          }
        };

        return LineBreaker;
      }();

      localModule.localExports = LineBreaker;
    }, {
      "./classes": 132,
      "./pairs": 134,
      "base64-js": 128,
      "unicode-trie": 130
    }],
    134: [function (localRequire, localModule, localExports) {
      var CI_BRK, CP_BRK, DI_BRK, IN_BRK, PR_BRK;
      localExports.DI_BRK = DI_BRK = 0; // Direct break opportunity

      localExports.IN_BRK = IN_BRK = 1; // Indirect break opportunity

      localExports.CI_BRK = CI_BRK = 2; // Indirect break opportunity for combining marks

      localExports.CP_BRK = CP_BRK = 3; // Prohibited break for combining marks

      localExports.PR_BRK = PR_BRK = 4; // Prohibited break
      // Based on example pair table from https://www.unicode.org/reports/tr14/tr14-37.html#Table2
      // - ZWJ special processing for LB8a
      // - CB manually added as per Rule LB20

      localExports.pairTable = [//OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
        [PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, CP_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK], // OP
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // CL
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // CP
        [PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], // QU
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], // GL
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // NS
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // EX
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // SY
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // IS
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK], // PR
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // PO
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // NU
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // AL
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // HL
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // ID
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // IN
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // HY
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // BA
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK], // BB
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, PR_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // B2
        [DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], // ZW
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // CM
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], // WJ
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // H2
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // H3
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // JL
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // JV
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // JT
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // RI
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK], // EB
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // EM
        [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], // ZWJ
        [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, DI_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK] // CB
      ];
    }, {}],
    135: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {

          var _Object$assign = localRequire('@babel/runtime-corejs2/core-js/object/assign');

          var stream = localRequire('stream');

          var _Array$isArray = localRequire('@babel/runtime-corejs2/core-js/array/is-array');

          var _Object$keys = localRequire('@babel/runtime-corejs2/core-js/object/keys');

          var zlib = localRequire('zlib');

          var _parseInt = localRequire('@babel/runtime-corejs2/core-js/parse-int');

          var _JSON$stringify = localRequire('@babel/runtime-corejs2/core-js/json/stringify');

          var _Number$isFinite = localRequire('@babel/runtime-corejs2/core-js/number/is-finite');

          var fontkit = localRequire('fontkit');

          var _Object$create = localRequire('@babel/runtime-corejs2/core-js/object/create');

          var events = localRequire('events');
          var LineBreaker = localRequire('linebreak');
          var PNG = localRequire('png-js');

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps?) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return self;
          }

          function _unsupportedIterableToArray(o, minLen?) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return (<any>Array).from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }

          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;

            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }

            return arr2;
          }

          function _createForOfIteratorHelperLoose(o, allowArrayLike?) {
            var it;

            if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
              if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                return function () {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                };
              }

              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }

            it = o[Symbol.iterator]();
            return it.next.bind(it);
          }
          /*
          PDFAbstractReference - abstract class for PDF reference
          */


          var PDFAbstractReference = /*#__PURE__*/function () {
            function PDFAbstractReference() { }

            var _proto = PDFAbstractReference.prototype;

            _proto.toString = function toString() {
              throw new Error('Must be implemented by subclasses');
            };

            return PDFAbstractReference;
          }();

          var PDFNameTree = /*#__PURE__*/function () {
            function PDFNameTree() {
              this._items = {};
            }

            var _proto = PDFNameTree.prototype;

            _proto.add = function add(key, val) {
              return this._items[key] = val;
            };

            _proto.get = function get(key) {
              return this._items[key];
            };

            _proto.toString = function toString() {
              // Needs to be sorted by key
              var sortedKeys = _Object$keys(this._items).sort(function (a, b) {
                return a.localeCompare(b);
              });

              var out = ['<<'];

              if (sortedKeys.length > 1) {
                var first = sortedKeys[0],
                  last = sortedKeys[sortedKeys.length - 1];
                out.push("  /Limits " + (<any>PDFObject).convert([new String(first), new String(last)]));
              }

              out.push('  /Names [');

              for (var _iterator = _createForOfIteratorHelperLoose(sortedKeys), _step; !(_step = _iterator()).done;) {
                var key = _step.value;
                out.push("    " + (<any>PDFObject).convert(new String(key)) + " " + (<any>PDFObject).convert(this._items[key]));
              }

              out.push(']');
              out.push('>>');
              return out.join('\n');
            };

            return PDFNameTree;
          }();

          var pad = function pad(str, length) {
            return (Array(length + 1).join('0') + str).slice(-length);
          };

          var escapableRe = /[\n\r\t\b\f\(\)\\]/g;
          var escapable = {
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '\b': '\\b',
            '\f': '\\f',
            '\\': '\\\\',
            '(': '\\(',
            ')': '\\)'
          }; // Convert little endian UTF-16 to big endian

          var swapBytes = function swapBytes(buff) {
            var l = buff.length;

            if (l & 0x01) {
              throw new Error('Buffer length must be even');
            } else {
              for (var i = 0, end = l - 1; i < end; i += 2) {
                var a = buff[i];
                buff[i] = buff[i + 1];
                buff[i + 1] = a;
              }
            }

            return buff;
          };

          var PDFObject = /*#__PURE__*/function () {
            function PDFObject() { }

            (<any>PDFObject).convert = function convert(object, encryptFn) {
              if (encryptFn === void 0) {
                encryptFn = null;
              } // String literals are converted to the PDF name type


              if (typeof object === 'string') {
                return "/" + object; // String objects are converted to PDF strings (UTF-16)
              } else if (object instanceof String) {
                var string = object; // Detect if this is a unicode string

                var isUnicode = false;

                for (var i = 0, end = string.length; i < end; i++) {
                  if (string.charCodeAt(i) > 0x7f) {
                    isUnicode = true;
                    break;
                  }
                } // If so, encode it as big endian UTF-16


                var stringBuffer;

                if (isUnicode) {
                  stringBuffer = swapBytes(Buffer.from("\uFEFF" + string, 'utf16le'));
                } else {
                  stringBuffer = Buffer.from(string.valueOf(), 'ascii');
                } // Encrypt the string when necessary


                if (encryptFn) {
                  string = encryptFn(stringBuffer).toString('binary');
                } else {
                  string = stringBuffer.toString('binary');
                } // Escape characters as required by the spec


                string = string.replace(escapableRe, function (c) {
                  return escapable[c];
                });
                return "(" + string + ")"; // Buffers are converted to PDF hex strings
              } else if (Buffer.isBuffer(object)) {
                return "<" + object.toString('hex') + ">";
              } else if (object instanceof PDFAbstractReference || object instanceof PDFNameTree) {
                return object.toString();
              } else if (object instanceof Date) {
                var _string = "D:" + pad(object.getUTCFullYear(), 4) + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z'; // Encrypt the string when necessary


                if (encryptFn) {
                  _string = encryptFn(new Buffer(_string, 'ascii')).toString('binary'); // Escape characters as required by the spec

                  _string = _string.replace(escapableRe, function (c) {
                    return escapable[c];
                  });
                }

                return "(" + _string + ")";
              } else if (_Array$isArray(object)) {
                var items = object.map(function (e) {
                  return (<any>PDFObject).convert(e, encryptFn);
                }).join(' ');
                return "[" + items + "]";
              } else if ({}.toString.call(object) === '[object Object]') {
                var out = ['<<'];

                for (var key in object) {
                  var val = object[key];
                  out.push("/" + key + " " + (<any>PDFObject).convert(val, encryptFn));
                }

                out.push('>>');
                return out.join('\n');
              } else if (typeof object === 'number') {
                return (<any>PDFObject).number(object);
              } else {
                return "" + object;
              }
            };

            (<any>PDFObject).number = function number(n) {
              if (n > -1e21 && n < 1e21) {
                return Math.round(n * 1e6) / 1e6;
              }

              throw new Error("unsupported number: " + n);
            };

            return PDFObject;
          }();

          var PDFReference = /*#__PURE__*/function (_PDFAbstractReference) {
            _inheritsLoose(PDFReference, _PDFAbstractReference);

            function PDFReference(document, id, data): void {
              var _this;

              if (data === void 0) {
                data = {};
              }

              _this = _PDFAbstractReference.call(this) || this;
              _this.document = document;
              _this.id = id;
              _this.data = data;
              _this.gen = 0;
              _this.compress = _this.document.compress && !_this.data.Filter;
              _this.uncompressedLength = 0;
              _this.buffer = [];
              return _this;
            }

            var _proto = PDFReference.prototype;

            _proto.write = function write(chunk) {
              if (!Buffer.isBuffer(chunk)) {
                chunk = new Buffer(chunk + '\n', 'binary');
              }

              this.uncompressedLength += chunk.length;

              if (this.data.Length == null) {
                this.data.Length = 0;
              }

              this.buffer.push(chunk);
              this.data.Length += chunk.length;

              if (this.compress) {
                return this.data.Filter = 'FlateDecode';
              }
            };

            _proto.end = function end(chunk) {
              if (chunk) {
                this.write(chunk);
              }

              return this.finalize();
            };

            _proto.finalize = function finalize() {
              this.offset = this.document._offset;
              var encryptFn = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null;

              if (this.buffer.length) {
                this.buffer = Buffer.concat(this.buffer);

                if (this.compress) {
                  this.buffer = zlib.deflateSync(this.buffer);
                }

                if (encryptFn) {
                  this.buffer = encryptFn(this.buffer);
                }

                this.data.Length = this.buffer.length;
              }

              this.document._write(this.id + " " + this.gen + " obj");

              this.document._write((<any>PDFObject).convert(this.data, encryptFn));

              if (this.buffer.length) {
                this.document._write('stream');

                this.document._write(this.buffer);

                this.buffer = []; // free up memory

                this.document._write('\nendstream');
              }

              this.document._write('endobj');

              this.document._refEnd(this);
            };

            _proto.toString = function toString() {
              return this.id + " " + this.gen + " R";
            };

            return PDFReference;
          }(PDFAbstractReference);
          /*
          PDFPage - represents a single page in the PDF document
          By Devon Govett
          */


          var DEFAULT_MARGINS = {
            top: 72,
            left: 72,
            bottom: 72,
            right: 72
          };
          var SIZES = {
            '4A0': [4767.87, 6740.79],
            '2A0': [3370.39, 4767.87],
            A0: [2383.94, 3370.39],
            A1: [1683.78, 2383.94],
            A2: [1190.55, 1683.78],
            A3: [841.89, 1190.55],
            A4: [595.28, 841.89],
            A5: [419.53, 595.28],
            A6: [297.64, 419.53],
            A7: [209.76, 297.64],
            A8: [147.4, 209.76],
            A9: [104.88, 147.4],
            A10: [73.7, 104.88],
            B0: [2834.65, 4008.19],
            B1: [2004.09, 2834.65],
            B2: [1417.32, 2004.09],
            B3: [1000.63, 1417.32],
            B4: [708.66, 1000.63],
            B5: [498.9, 708.66],
            B6: [354.33, 498.9],
            B7: [249.45, 354.33],
            B8: [175.75, 249.45],
            B9: [124.72, 175.75],
            B10: [87.87, 124.72],
            C0: [2599.37, 3676.54],
            C1: [1836.85, 2599.37],
            C2: [1298.27, 1836.85],
            C3: [918.43, 1298.27],
            C4: [649.13, 918.43],
            C5: [459.21, 649.13],
            C6: [323.15, 459.21],
            C7: [229.61, 323.15],
            C8: [161.57, 229.61],
            C9: [113.39, 161.57],
            C10: [79.37, 113.39],
            RA0: [2437.8, 3458.27],
            RA1: [1729.13, 2437.8],
            RA2: [1218.9, 1729.13],
            RA3: [864.57, 1218.9],
            RA4: [609.45, 864.57],
            SRA0: [2551.18, 3628.35],
            SRA1: [1814.17, 2551.18],
            SRA2: [1275.59, 1814.17],
            SRA3: [907.09, 1275.59],
            SRA4: [637.8, 907.09],
            EXECUTIVE: [521.86, 756.0],
            FOLIO: [612.0, 936.0],
            LEGAL: [612.0, 1008.0],
            LETTER: [612.0, 792.0],
            TABLOID: [792.0, 1224.0]
          };

          var PDFPage = /*#__PURE__*/function () {
            function PDFPage(document, options) {
              if (options === void 0) {
                options = {};
              }

              this.document = document;
              this.size = options.size || 'letter';
              this.layout = options.layout || 'portrait'; // process margins

              if (typeof options.margin === 'number') {
                this.margins = {
                  top: options.margin,
                  left: options.margin,
                  bottom: options.margin,
                  right: options.margin
                }; // default to 1 inch margins
              } else {
                this.margins = options.margins || DEFAULT_MARGINS; //GrapeCity begin -- always clone, don't keep a reference to DEFAULT_MARGINS

                this.margins = {
                  top: this.margins.top,
                  left: this.margins.left,
                  bottom: this.margins.bottom,
                  right: this.margins.right
                }; //GrapeCity end
              } // calculate page dimensions


              var dimensions = _Array$isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
              this.width = dimensions[this.layout === 'portrait' ? 0 : 1];
              this.height = dimensions[this.layout === 'portrait' ? 1 : 0];
              this.content = this.document.ref(); // Initialize the Font, XObject, and ExtGState dictionaries

              this.resources = this.document.ref({
                ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI']
              }); // The page dictionary

              this.dictionary = this.document.ref({
                Type: 'Page',
                Parent: this.document._root.data.Pages,
                MediaBox: [0, 0, this.width, this.height],
                Contents: this.content,
                Resources: this.resources
              });
            } // Lazily create these dictionaries


            var _proto = PDFPage.prototype;

            _proto.maxY = function maxY() {
              return this.height - this.margins.bottom;
            };

            _proto.write = function write(chunk) {
              return this.content.write(chunk);
            };

            _proto.end = function end() {
              this.dictionary.end();
              this.resources.end();
              return this.content.end();
            };

            _createClass(PDFPage, [{
              key: "fonts",
              get: function get() {
                var data = this.resources.data;
                return data.Font != null ? data.Font : data.Font = {};
              }
            }, {
              key: "xobjects",
              get: function get() {
                var data = this.resources.data;
                return data.XObject != null ? data.XObject : data.XObject = {};
              }
            }, {
              key: "ext_gstates",
              get: function get() {
                var data = this.resources.data;
                return data.ExtGState != null ? data.ExtGState : data.ExtGState = {};
              }
            }, {
              key: "patterns",
              get: function get() {
                var data = this.resources.data;
                return data.Pattern != null ? data.Pattern : data.Pattern = {};
              }
            }, {
              key: "annotations",
              get: function get() {
                var data = this.dictionary.data;
                return data.Annots != null ? data.Annots : data.Annots = [];
              }
            }]);

            return PDFPage;
          }();

          var number = (<any>PDFObject).number;

          var PDFGradient = /*#__PURE__*/function () {
            function PDFGradient(doc) {
              this.doc = doc;
              this.stops = [];
              this.embedded = false;
              this.transform = [1, 0, 0, 1, 0, 0];
            }

            var _proto = PDFGradient.prototype;

            _proto.stop = function stop(pos, color, opacity) {
              if (opacity == null) {
                opacity = 1;
              }

              color = this.doc._normalizeColor(color);

              if (this.stops.length === 0) {
                if (color.length === 3) {
                  this._colorSpace = 'DeviceRGB';
                } else if (color.length === 4) {
                  this._colorSpace = 'DeviceCMYK';
                } else if (color.length === 1) {
                  this._colorSpace = 'DeviceGray';
                } else {
                  throw new Error('Unknown color space');
                }
              } else if (this._colorSpace === 'DeviceRGB' && color.length !== 3 || this._colorSpace === 'DeviceCMYK' && color.length !== 4 || this._colorSpace === 'DeviceGray' && color.length !== 1) {
                throw new Error('All gradient stops must use the same color space');
              }

              opacity = Math.max(0, Math.min(1, opacity));
              this.stops.push([pos, color, opacity]);
              return this;
            };

            _proto.setTransform = function setTransform(m11, m12, m21, m22, dx, dy) {
              this.transform = [m11, m12, m21, m22, dx, dy];
              return this;
            };

            _proto.embed = function embed(m) {
              var fn;
              var stopsLength = this.stops.length;

              if (stopsLength === 0) {
                return;
              }

              this.embedded = true;
              this.matrix = m; // if the last stop comes before 100%, add a copy at 100%

              var last = this.stops[stopsLength - 1];

              if (last[0] < 1) {
                this.stops.push([1, last[1], last[2]]);
              }

              var bounds = [];
              var encode = [];
              var stops = [];

              for (var i = 0; i < stopsLength - 1; i++) {
                encode.push(0, 1);

                if (i + 2 !== stopsLength) {
                  bounds.push(this.stops[i + 1][0]);
                }

                fn = this.doc.ref({
                  FunctionType: 2,
                  Domain: [0, 1],
                  C0: this.stops[i + 0][1],
                  C1: this.stops[i + 1][1],
                  N: 1
                });
                stops.push(fn);
                fn.end();
              } // if there are only two stops, we don't need a stitching function


              if (stopsLength === 1) {
                fn = stops[0];
              } else {
                fn = this.doc.ref({
                  FunctionType: 3,
                  // stitching function
                  Domain: [0, 1],
                  Functions: stops,
                  Bounds: bounds,
                  Encode: encode
                });
                fn.end();
              }

              this.id = "Sh" + ++this.doc._gradCount;
              var shader = this.shader(fn);
              shader.end();
              var pattern = this.doc.ref({
                Type: 'Pattern',
                PatternType: 2,
                Shading: shader,
                Matrix: this.matrix.map(number)
              });
              pattern.end();

              if (this.stops.some(function (stop) {
                return stop[2] < 1;
              })) {
                var grad = this.opacityGradient();
                grad._colorSpace = 'DeviceGray';

                for (var _iterator = _createForOfIteratorHelperLoose(this.stops), _step; !(_step = _iterator()).done;) {
                  var stop = _step.value;
                  grad.stop(stop[0], [stop[2]]);
                }

                grad = grad.embed(this.matrix);
                var pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
                var form = this.doc.ref({
                  Type: 'XObject',
                  Subtype: 'Form',
                  FormType: 1,
                  BBox: pageBBox,
                  Group: {
                    Type: 'Group',
                    S: 'Transparency',
                    CS: 'DeviceGray'
                  },
                  Resources: {
                    ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],
                    Pattern: {
                      Sh1: grad
                    }
                  }
                });
                form.write('/Pattern cs /Sh1 scn');
                form.end(pageBBox.join(' ') + " re f");
                var gstate = this.doc.ref({
                  Type: 'ExtGState',
                  SMask: {
                    Type: 'Mask',
                    S: 'Luminosity',
                    G: form
                  }
                });
                gstate.end();
                var opacityPattern = this.doc.ref({
                  Type: 'Pattern',
                  PatternType: 1,
                  PaintType: 1,
                  TilingType: 2,
                  BBox: pageBBox,
                  XStep: pageBBox[2],
                  YStep: pageBBox[3],
                  Resources: {
                    ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],
                    Pattern: {
                      Sh1: pattern
                    },
                    ExtGState: {
                      Gs1: gstate
                    }
                  }
                });
                opacityPattern.write('/Gs1 gs /Pattern cs /Sh1 scn');
                opacityPattern.end(pageBBox.join(' ') + " re f");
                this.doc.page.patterns[this.id] = opacityPattern;
              } else {
                this.doc.page.patterns[this.id] = pattern;
              }

              return pattern;
            };

            _proto.apply = function apply(op) {
              // apply gradient transform to existing document ctm
              var _this$doc$_ctm = this.doc._ctm,
                m0 = _this$doc$_ctm[0],
                m1 = _this$doc$_ctm[1],
                m2 = _this$doc$_ctm[2],
                m3 = _this$doc$_ctm[3],
                m4 = _this$doc$_ctm[4],
                m5 = _this$doc$_ctm[5];
              var _this$transform = this.transform,
                m11 = _this$transform[0],
                m12 = _this$transform[1],
                m21 = _this$transform[2],
                m22 = _this$transform[3],
                dx = _this$transform[4],
                dy = _this$transform[5];
              var m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];

              if (!this.embedded || m.join(' ') !== this.matrix.join(' ')) {
                this.embed(m);
              }

              return this.doc.addContent("/" + this.id + " " + op);
            };

            return PDFGradient;
          }();

          var PDFLinearGradient = /*#__PURE__*/function (_PDFGradient) {
            _inheritsLoose(PDFLinearGradient, _PDFGradient);

            function PDFLinearGradient(doc, x1, y1, x2, y2): void {
              var _this;

              _this = _PDFGradient.call(this, doc) || this;
              _this.x1 = x1;
              _this.y1 = y1;
              _this.x2 = x2;
              _this.y2 = y2;
              return _this;
            }

            var _proto2 = PDFLinearGradient.prototype;

            _proto2.shader = function shader(fn) {
              return this.doc.ref({
                ShadingType: 2,
                ColorSpace: this._colorSpace,
                Coords: [this.x1, this.y1, this.x2, this.y2],
                Function: fn,
                Extend: [true, true]
              });
            };

            _proto2.opacityGradient = function opacityGradient() {
              return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);
            };

            return PDFLinearGradient;
          }(PDFGradient);

          var PDFRadialGradient = /*#__PURE__*/function (_PDFGradient2) {
            _inheritsLoose(PDFRadialGradient, _PDFGradient2);

            function PDFRadialGradient(doc, x1, y1, r1, x2, y2, r2): void {
              var _this2;

              _this2 = _PDFGradient2.call(this, doc) || this;
              _this2.doc = doc;
              _this2.x1 = x1;
              _this2.y1 = y1;
              _this2.r1 = r1;
              _this2.x2 = x2;
              _this2.y2 = y2;
              _this2.r2 = r2;
              return _this2;
            }

            var _proto3 = PDFRadialGradient.prototype;

            _proto3.shader = function shader(fn) {
              return this.doc.ref({
                ShadingType: 3,
                ColorSpace: this._colorSpace,
                Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
                Function: fn,
                Extend: [true, true]
              });
            };

            _proto3.opacityGradient = function opacityGradient() {
              return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
            };

            return PDFRadialGradient;
          }(PDFGradient);

          var Gradient = {
            PDFGradient: PDFGradient,
            PDFLinearGradient: PDFLinearGradient,
            PDFRadialGradient: PDFRadialGradient
          };
          var PDFGradient$1 = Gradient.PDFGradient,
            PDFLinearGradient$1 = Gradient.PDFLinearGradient,
            PDFRadialGradient$1 = Gradient.PDFRadialGradient;
          var ColorMixin = {
            initColor: function initColor() {
              // The opacity dictionaries
              this._opacityRegistry = {};
              this._opacityCount = 0;
              return this._gradCount = 0;
            },
            _normalizeColor: function _normalizeColor(color) {
              if (color instanceof PDFGradient$1) {
                return color;
              }

              if (typeof color === 'string') {
                if (color.charAt(0) === '#') {
                  if (color.length === 4) {
                    color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, '#$1$1$2$2$3$3');
                  }

                  var hex = _parseInt(color.slice(1), 16);

                  color = [hex >> 16, hex >> 8 & 0xff, hex & 0xff];
                } else if (namedColors[color]) {
                  color = namedColors[color];
                }
              }

              if (_Array$isArray(color)) {
                // RGB
                if (color.length === 3) {
                  color = color.map(function (part) {
                    return part / 255;
                  }); // CMYK
                } else if (color.length === 4) {
                  color = color.map(function (part) {
                    return part / 100;
                  });
                }

                return color;
              }

              return null;
            },
            _setColor: function _setColor(color, stroke) {
              color = this._normalizeColor(color);

              if (!color) {
                return false;
              }

              var op = stroke ? 'SCN' : 'scn';

              if (color instanceof PDFGradient$1) {
                this._setColorSpace('Pattern', stroke);

                (<any>color).apply(op);
              } else {
                var space = color.length === 4 ? 'DeviceCMYK' : 'DeviceRGB';

                this._setColorSpace(space, stroke);

                color = color.join(' ');
                this.addContent(color + " " + op);
              }

              return true;
            },
            _setColorSpace: function _setColorSpace(space, stroke) {
              var op = stroke ? 'CS' : 'cs';
              return this.addContent("/" + space + " " + op);
            },
            fillColor: function fillColor(color, opacity) {
              var set = this._setColor(color, false);

              if (set) {
                this.fillOpacity(opacity);
              } // save this for text wrapper, which needs to reset
              // the fill color on new pages


              this._fillColor = [color, opacity];
              return this;
            },
            strokeColor: function strokeColor(color, opacity) {
              var set = this._setColor(color, true);

              if (set) {
                this.strokeOpacity(opacity);
              }

              return this;
            },
            opacity: function opacity(_opacity) {
              this._doOpacity(_opacity, _opacity);

              return this;
            },
            fillOpacity: function fillOpacity(opacity) {
              this._doOpacity(opacity, null);

              return this;
            },
            strokeOpacity: function strokeOpacity(opacity) {
              this._doOpacity(null, opacity);

              return this;
            },
            _doOpacity: function _doOpacity(fillOpacity, strokeOpacity) {
              var dictionary, name;

              if (fillOpacity == null && strokeOpacity == null) {
                return;
              }

              if (fillOpacity != null) {
                fillOpacity = Math.max(0, Math.min(1, fillOpacity));
              }

              if (strokeOpacity != null) {
                strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
              }

              var key = fillOpacity + "_" + strokeOpacity;

              if (this._opacityRegistry[key]) {
                var _this$_opacityRegistr = this._opacityRegistry[key];
                dictionary = _this$_opacityRegistr[0];
                name = _this$_opacityRegistr[1];
              } else {
                dictionary = {
                  Type: 'ExtGState'
                };

                if (fillOpacity != null) {
                  dictionary.ca = fillOpacity;
                }

                if (strokeOpacity != null) {
                  dictionary.CA = strokeOpacity;
                }

                dictionary = this.ref(dictionary);
                dictionary.end();
                var id = ++this._opacityCount;
                name = "Gs" + id;
                this._opacityRegistry[key] = [dictionary, name];
              }

              this.page.ext_gstates[name] = dictionary;
              return this.addContent("/" + name + " gs");
            },
            linearGradient: function linearGradient(x1, y1, x2, y2) {
              return new PDFLinearGradient$1(this, x1, y1, x2, y2);
            },
            radialGradient: function radialGradient(x1, y1, r1, x2, y2, r2) {
              return new PDFRadialGradient$1(this, x1, y1, r1, x2, y2, r2);
            }
          };
          var namedColors = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            grey: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
          };
          var cx, cy, px, py, sx, sy;
          cx = cy = px = py = sx = sy = 0;
          var parameters = {
            A: 7,
            a: 7,
            C: 6,
            c: 6,
            H: 1,
            h: 1,
            L: 2,
            l: 2,
            M: 2,
            m: 2,
            Q: 4,
            q: 4,
            S: 4,
            s: 4,
            T: 2,
            t: 2,
            V: 1,
            v: 1,
            Z: 0,
            z: 0
          };

          var parse = function parse(path) {
            var cmd;
            var ret = [];
            var args = [];
            var curArg = '';
            var foundDecimal = false;
            var params = 0;

            for (var _iterator = _createForOfIteratorHelperLoose(path), _step; !(_step = _iterator()).done;) {
              var c = _step.value;

              if (parameters[c] != null) {
                params = parameters[c];

                if (cmd) {
                  // save existing command
                  if (curArg.length > 0) {
                    args[args.length] = +curArg;
                  }

                  ret[ret.length] = {
                    cmd: cmd,
                    args: args
                  };
                  args = [];
                  curArg = '';
                  foundDecimal = false;
                }

                cmd = c;
              } else if ([' ', ','].indexOf(c) !== -1 || c === '-' && curArg.length > 0 && curArg[curArg.length - 1] !== 'e' || c === '.' && foundDecimal) {
                if (curArg.length === 0) {
                  continue;
                }

                if (args.length === params) {
                  // handle reused commands
                  ret[ret.length] = {
                    cmd: cmd,
                    args: args
                  };
                  args = [+curArg]; // handle assumed commands

                  if (cmd === 'M') {
                    cmd = 'L';
                  }

                  if (cmd === 'm') {
                    cmd = 'l';
                  }
                } else {
                  args[args.length] = +curArg;
                }

                foundDecimal = c === '.'; // fix for negative numbers or repeated decimals with no delimeter between commands

                curArg = ['-', '.'].indexOf(c) !== -1 ? c : '';
              } else {
                curArg += c;

                if (c === '.') {
                  foundDecimal = true;
                }
              }
            } // add the last command


            if (curArg.length > 0) {
              if (args.length === params) {
                // handle reused commands
                ret[ret.length] = {
                  cmd: cmd,
                  args: args
                };
                args = [+curArg]; // handle assumed commands

                if (cmd === 'M') {
                  cmd = 'L';
                }

                if (cmd === 'm') {
                  cmd = 'l';
                }
              } else {
                args[args.length] = +curArg;
              }
            }

            ret[ret.length] = {
              cmd: cmd,
              args: args
            };
            return ret;
          };

          var _apply = function apply(commands, doc) {
            // current point, control point, and subpath starting point
            cx = cy = px = py = sx = sy = 0; // run the commands

            for (var i = 0; i < commands.length; i++) {
              var c = commands[i];

              if (typeof runners[c.cmd] === 'function') {
                runners[c.cmd](doc, c.args);
              }
            }
          };

          var runners = {
            M: function M(doc, a) {
              cx = a[0];
              cy = a[1];
              px = py = null;
              sx = cx;
              sy = cy;
              return doc.moveTo(cx, cy);
            },
            m: function m(doc, a) {
              cx += a[0];
              cy += a[1];
              px = py = null;
              sx = cx;
              sy = cy;
              return doc.moveTo(cx, cy);
            },
            C: function C(doc, a) {
              cx = a[4];
              cy = a[5];
              px = a[2];
              py = a[3];
              return doc.bezierCurveTo.apply(doc, a);
            },
            c: function c(doc, a) {
              doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
              px = cx + a[2];
              py = cy + a[3];
              cx += a[4];
              return cy += a[5];
            },
            S: function S(doc, a) {
              if (px === null) {
                px = cx;
                py = cy;
              }

              doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
              px = a[0];
              py = a[1];
              cx = a[2];
              return cy = a[3];
            },
            s: function s(doc, a) {
              if (px === null) {
                px = cx;
                py = cy;
              }

              doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
              px = cx + a[0];
              py = cy + a[1];
              cx += a[2];
              return cy += a[3];
            },
            Q: function Q(doc, a) {
              px = a[0];
              py = a[1];
              cx = a[2];
              cy = a[3];
              return doc.quadraticCurveTo(a[0], a[1], cx, cy);
            },
            q: function q(doc, a) {
              doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
              px = cx + a[0];
              py = cy + a[1];
              cx += a[2];
              return cy += a[3];
            },
            T: function T(doc, a) {
              if (px === null) {
                px = cx;
                py = cy;
              } else {
                px = cx - (px - cx);
                py = cy - (py - cy);
              }

              doc.quadraticCurveTo(px, py, a[0], a[1]);
              px = cx - (px - cx);
              py = cy - (py - cy);
              cx = a[0];
              return cy = a[1];
            },
            t: function t(doc, a) {
              if (px === null) {
                px = cx;
                py = cy;
              } else {
                px = cx - (px - cx);
                py = cy - (py - cy);
              }

              doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);
              cx += a[0];
              return cy += a[1];
            },
            A: function A(doc, a) {
              solveArc(doc, cx, cy, a);
              cx = a[5];
              return cy = a[6];
            },
            a: function a(doc, _a) {
              _a[5] += cx;
              _a[6] += cy;
              solveArc(doc, cx, cy, _a);
              cx = _a[5];
              return cy = _a[6];
            },
            L: function L(doc, a) {
              cx = a[0];
              cy = a[1];
              px = py = null;
              return doc.lineTo(cx, cy);
            },
            l: function l(doc, a) {
              cx += a[0];
              cy += a[1];
              px = py = null;
              return doc.lineTo(cx, cy);
            },
            H: function H(doc, a) {
              cx = a[0];
              px = py = null;
              return doc.lineTo(cx, cy);
            },
            h: function h(doc, a) {
              cx += a[0];
              px = py = null;
              return doc.lineTo(cx, cy);
            },
            V: function V(doc, a) {
              cy = a[0];
              px = py = null;
              return doc.lineTo(cx, cy);
            },
            v: function v(doc, a) {
              cy += a[0];
              px = py = null;
              return doc.lineTo(cx, cy);
            },
            Z: function Z(doc) {
              doc.closePath();
              cx = sx;
              return cy = sy;
            },
            z: function z(doc) {
              doc.closePath();
              cx = sx;
              return cy = sy;
            }
          };

          var solveArc = function solveArc(doc, x, y, coords) {
            var rx = coords[0],
              ry = coords[1],
              rot = coords[2],
              large = coords[3],
              sweep = coords[4],
              ex = coords[5],
              ey = coords[6];
            var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);

            for (var _iterator2 = _createForOfIteratorHelperLoose(segs), _step2; !(_step2 = _iterator2()).done;) {
              var seg = _step2.value;
              var bez = segmentToBezier.apply(void 0, seg);
              doc.bezierCurveTo.apply(doc, bez);
            }
          }; // from Inkscape svgtopdf, thanks!


          var arcToSegments = function arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
            var th = rotateX * (Math.PI / 180);
            var sin_th = Math.sin(th);
            var cos_th = Math.cos(th);
            rx = Math.abs(rx);
            ry = Math.abs(ry);
            px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
            py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
            var pl = px * px / (rx * rx) + py * py / (ry * ry);

            if (pl > 1) {
              pl = Math.sqrt(pl);
              rx *= pl;
              ry *= pl;
            }

            var a00 = cos_th / rx;
            var a01 = sin_th / rx;
            var a10 = -sin_th / ry;
            var a11 = cos_th / ry;
            var x0 = a00 * ox + a01 * oy;
            var y0 = a10 * ox + a11 * oy;
            var x1 = a00 * x + a01 * y;
            var y1 = a10 * x + a11 * y;
            var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
            var sfactor_sq = 1 / d - 0.25;

            if (sfactor_sq < 0) {
              sfactor_sq = 0;
            }

            var sfactor = Math.sqrt(sfactor_sq);

            if (sweep === large) {
              sfactor = -sfactor;
            }

            var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
            var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
            var th0 = Math.atan2(y0 - yc, x0 - xc);
            var th1 = Math.atan2(y1 - yc, x1 - xc);
            var th_arc = th1 - th0;

            if (th_arc < 0 && sweep === 1) {
              th_arc += 2 * Math.PI;
            } else if (th_arc > 0 && sweep === 0) {
              th_arc -= 2 * Math.PI;
            }

            var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
            var result = [];

            for (var i = 0; i < segments; i++) {
              var th2 = th0 + i * th_arc / segments;
              var th3 = th0 + (i + 1) * th_arc / segments;
              result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
            }

            return result;
          };

          var segmentToBezier = function segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {
            var a00 = cos_th * rx;
            var a01 = -sin_th * ry;
            var a10 = sin_th * rx;
            var a11 = cos_th * ry;
            var th_half = 0.5 * (th1 - th0);
            var t = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
            var x1 = cx + Math.cos(th0) - t * Math.sin(th0);
            var y1 = cy + Math.sin(th0) + t * Math.cos(th0);
            var x3 = cx + Math.cos(th1);
            var y3 = cy + Math.sin(th1);
            var x2 = x3 + t * Math.sin(th1);
            var y2 = y3 - t * Math.cos(th1);
            return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
          };

          var SVGPath = /*#__PURE__*/function () {
            function SVGPath() { }

            SVGPath.apply = function apply(doc, path) {
              var commands = parse(path);

              _apply(commands, doc);
            };

            return SVGPath;
          }();

          var number$1 = (<any>PDFObject).number; // This constant is used to approximate a symmetrical arc using a cubic
          // Bezier curve.

          var KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);
          var VectorMixin = {
            initVector: function initVector() {
              this._ctm = [1, 0, 0, 1, 0, 0]; // current transformation matrix

              return this._ctmStack = [];
            },
            save: function save() {
              this._ctmStack.push(this._ctm.slice()); // TODO: save/restore colorspace and styles so not setting it unnessesarily all the time?


              return this.addContent('q');
            },
            restore: function restore() {
              this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
              return this.addContent('Q');
            },
            closePath: function closePath() {
              return this.addContent('h');
            },
            lineWidth: function lineWidth(w) {
              return this.addContent(number$1(w) + " w");
            },
            _CAP_STYLES: {
              BUTT: 0,
              ROUND: 1,
              SQUARE: 2
            },
            lineCap: function lineCap(c) {
              if (typeof c === 'string') {
                c = this._CAP_STYLES[c.toUpperCase()];
              }

              return this.addContent(c + " J");
            },
            _JOIN_STYLES: {
              MITER: 0,
              ROUND: 1,
              BEVEL: 2
            },
            lineJoin: function lineJoin(j) {
              if (typeof j === 'string') {
                j = this._JOIN_STYLES[j.toUpperCase()];
              }

              return this.addContent(j + " j");
            },
            miterLimit: function miterLimit(m) {
              return this.addContent(number$1(m) + " M");
            },
            dash: function dash(length, options) {
              if (options === void 0) {
                options = {};
              }

              var originalLength = length;

              if (!_Array$isArray(length)) {
                length = [length, options.space || length];
              }

              var valid = length.every(function (x) {
                return _Number$isFinite(x) && x > 0;
              });

              if (!valid) {
                throw new Error("dash(" + _JSON$stringify(originalLength) + ", " + _JSON$stringify(options) + ") invalid, lengths must be numeric and greater than zero");
              }

              length = length.map(number$1).join(' ');
              return this.addContent("[" + length + "] " + number$1(options.phase || 0) + " d");
            },
            undash: function undash() {
              return this.addContent('[] 0 d');
            },
            moveTo: function moveTo(x, y) {
              return this.addContent(number$1(x) + " " + number$1(y) + " m");
            },
            lineTo: function lineTo(x, y) {
              return this.addContent(number$1(x) + " " + number$1(y) + " l");
            },
            bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
              return this.addContent(number$1(cp1x) + " " + number$1(cp1y) + " " + number$1(cp2x) + " " + number$1(cp2y) + " " + number$1(x) + " " + number$1(y) + " c");
            },
            quadraticCurveTo: function quadraticCurveTo(cpx, cpy, x, y) {
              return this.addContent(number$1(cpx) + " " + number$1(cpy) + " " + number$1(x) + " " + number$1(y) + " v");
            },
            rect: function rect(x, y, w, h) {
              return this.addContent(number$1(x) + " " + number$1(y) + " " + number$1(w) + " " + number$1(h) + " re");
            },
            roundedRect: function roundedRect(x, y, w, h, r) {
              if (r == null) {
                r = 0;
              }

              r = Math.min(r, 0.5 * w, 0.5 * h); // amount to inset control points from corners (see `ellipse`)

              var c = r * (1.0 - KAPPA);
              this.moveTo(x + r, y);
              this.lineTo(x + w - r, y);
              this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);
              this.lineTo(x + w, y + h - r);
              this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);
              this.lineTo(x + r, y + h);
              this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);
              this.lineTo(x, y + r);
              this.bezierCurveTo(x, y + c, x + c, y, x + r, y);
              return this.closePath();
            },
            ellipse: function ellipse(x, y, r1, r2) {
              // based on http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas/2173084#2173084
              if (r2 == null) {
                r2 = r1;
              }

              x -= r1;
              y -= r2;
              var ox = r1 * KAPPA;
              var oy = r2 * KAPPA;
              var xe = x + r1 * 2;
              var ye = y + r2 * 2;
              var xm = x + r1;
              var ym = y + r2;
              this.moveTo(x, ym);
              this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
              this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
              this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
              this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
              return this.closePath();
            },
            circle: function circle(x, y, radius) {
              return this.ellipse(x, y, radius);
            },
            arc: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {
              if (anticlockwise == null) {
                anticlockwise = false;
              }

              var TWO_PI = 2.0 * Math.PI;
              var HALF_PI = 0.5 * Math.PI;
              var deltaAng = endAngle - startAngle;

              if (Math.abs(deltaAng) > TWO_PI) {
                // draw only full circle if more than that is specified
                deltaAng = TWO_PI;
              } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
                // necessary to flip direction of rendering
                var dir = anticlockwise ? -1 : 1;
                deltaAng = dir * TWO_PI + deltaAng;
              }

              var numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
              var segAng = deltaAng / numSegs;
              var handleLen = segAng / HALF_PI * KAPPA * radius;
              var curAng = startAngle; // component distances between anchor point and control point

              var deltaCx = -Math.sin(curAng) * handleLen;
              var deltaCy = Math.cos(curAng) * handleLen; // anchor point

              var ax = x + Math.cos(curAng) * radius;
              var ay = y + Math.sin(curAng) * radius; // calculate and render segments

              this.moveTo(ax, ay);

              for (var segIdx = 0; segIdx < numSegs; segIdx++) {
                // starting control point
                var cp1x = ax + deltaCx;
                var cp1y = ay + deltaCy; // step angle

                curAng += segAng; // next anchor point

                ax = x + Math.cos(curAng) * radius;
                ay = y + Math.sin(curAng) * radius; // next control point delta

                deltaCx = -Math.sin(curAng) * handleLen;
                deltaCy = Math.cos(curAng) * handleLen; // ending control point

                var cp2x = ax - deltaCx;
                var cp2y = ay - deltaCy; // render segment

                this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
              }

              return this;
            },
            polygon: function polygon() {
              for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
                points[_key] = arguments[_key];
              }

              this.moveTo.apply(this, points.shift() || []);

              for (var _i = 0, _points = points; _i < _points.length; _i++) {
                var point = _points[_i];
                this.lineTo.apply(this, point || []);
              }

              return this.closePath();
            },
            path: function path(_path) {
              SVGPath.apply(this, _path);
              return this;
            },
            _windingRule: function _windingRule(rule) {
              if (/even-?odd/.test(rule)) {
                return '*';
              }

              return '';
            },
            fill: function fill(color, rule) {
              if (/(even-?odd)|(non-?zero)/.test(color)) {
                rule = color;
                color = null;
              }

              if (color) {
                this.fillColor(color);
              }

              return this.addContent("f" + this._windingRule(rule));
            },
            stroke: function stroke(color) {
              if (color) {
                this.strokeColor(color);
              }

              return this.addContent('S');
            },
            fillAndStroke: function fillAndStroke(fillColor, strokeColor, rule) {
              if (strokeColor == null) {
                strokeColor = fillColor;
              }

              var isFillRule = /(even-?odd)|(non-?zero)/;

              if (isFillRule.test(fillColor)) {
                rule = fillColor;
                fillColor = null;
              }

              if (isFillRule.test(strokeColor)) {
                rule = strokeColor;
                strokeColor = fillColor;
              }

              if (fillColor) {
                this.fillColor(fillColor);
                this.strokeColor(strokeColor);
              }

              return this.addContent("B" + this._windingRule(rule));
            },
            clip: function clip(rule) {
              return this.addContent("W" + this._windingRule(rule) + " n");
            },
            transform: function transform(m11, m12, m21, m22, dx, dy) {
              // keep track of the current transformation matrix
              var m = this._ctm;
              var m0 = m[0],
                m1 = m[1],
                m2 = m[2],
                m3 = m[3],
                m4 = m[4],
                m5 = m[5];
              m[0] = m0 * m11 + m2 * m12;
              m[1] = m1 * m11 + m3 * m12;
              m[2] = m0 * m21 + m2 * m22;
              m[3] = m1 * m21 + m3 * m22;
              m[4] = m0 * dx + m2 * dy + m4;
              m[5] = m1 * dx + m3 * dy + m5;
              var values = [m11, m12, m21, m22, dx, dy].map(function (v) {
                return number$1(v);
              }).join(' ');
              return this.addContent(values + " cm");
            },
            translate: function translate(x, y) {
              return this.transform(1, 0, 0, 1, x, y);
            },
            rotate: function rotate(angle, options) {
              if (options === void 0) {
                options = {};
              }

              var y;
              var rad = angle * Math.PI / 180;
              var cos = Math.cos(rad);
              var sin = Math.sin(rad);
              var x = y = 0;

              if (options.origin != null) {
                var _options$origin = options.origin;
                x = _options$origin[0];
                y = _options$origin[1];
                var x1 = x * cos - y * sin;
                var y1 = x * sin + y * cos;
                x -= x1;
                y -= y1;
              }

              return this.transform(cos, sin, -sin, cos, x, y);
            },
            scale: function scale(xFactor, yFactor, options) {
              if (options === void 0) {
                options = {};
              }

              var y;

              if (yFactor == null) {
                yFactor = xFactor;
              }

              if (typeof yFactor === 'object') {
                options = yFactor;
                yFactor = xFactor;
              }

              var x = y = 0;

              if (options.origin != null) {
                var _options$origin2 = options.origin;
                x = _options$origin2[0];
                y = _options$origin2[1];
                x -= xFactor * x;
                y -= yFactor * y;
              }

              return this.transform(xFactor, 0, 0, yFactor, x, y);
            }
          }; // GrapeCity begin: The class is reworked to use compressed metrics (standard.coffee/STANDARD_FONTS).

          var WIN_ANSI_MAP = {
            402: 131,
            8211: 150,
            8212: 151,
            8216: 145,
            8217: 146,
            8218: 130,
            8220: 147,
            8221: 148,
            8222: 132,
            8224: 134,
            8225: 135,
            8226: 149,
            8230: 133,
            8364: 128,
            8240: 137,
            8249: 139,
            8250: 155,
            710: 136,
            8482: 153,
            338: 140,
            339: 156,
            732: 152,
            352: 138,
            353: 154,
            376: 159,
            381: 142,
            382: 158
          };
          var CHAR_TABLE = 'space:exclam:quotedbl:numbersign:dollar:percent:ampersand:quoteright:parenleft:parenright:asterisk:plus:comma:hyphen:period:slash:zero:one:two:three:four:five:six:seven:eight:nine:colon:semicolon:less:equal:greater:question:at:A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z:bracketleft:backslash:bracketright:asciicircum:underscore:quoteleft:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:braceleft:bar:braceright:asciitilde:exclamdown:cent:sterling:fraction:yen:florin:section:currency:quotesingle:quotedblleft:guillemotleft:guilsinglleft:guilsinglright:fi:fl:endash:dagger:daggerdbl:periodcentered:paragraph:bullet:quotesinglbase:quotedblbase:quotedblright:guillemotright:ellipsis:perthousand:questiondown:grave:acute:circumflex:tilde:macron:breve:dotaccent:dieresis:ring:cedilla:hungarumlaut:ogonek:caron:emdash:AE:ordfeminine:Lslash:Oslash:OE:ordmasculine:ae:dotlessi:lslash:oslash:oe:germandbls:Idieresis:eacute:abreve:uhungarumlaut:ecaron:Ydieresis:divide:Yacute:Acircumflex:aacute:Ucircumflex:yacute:scommaaccent:ecircumflex:Uring:Udieresis:aogonek:Uacute:uogonek:Edieresis:Dcroat:commaaccent:copyright:Emacron:ccaron:aring:Ncommaaccent:lacute:agrave:Tcommaaccent:Cacute:atilde:Edotaccent:scaron:scedilla:iacute:lozenge:Rcaron:Gcommaaccent:ucircumflex:acircumflex:Amacron:rcaron:ccedilla:Zdotaccent:Thorn:Omacron:Racute:Sacute:dcaron:Umacron:uring:threesuperior:Ograve:Agrave:Abreve:multiply:uacute:Tcaron:partialdiff:ydieresis:Nacute:icircumflex:Ecircumflex:adieresis:edieresis:cacute:nacute:umacron:Ncaron:Iacute:plusminus:brokenbar:registered:Gbreve:Idotaccent:summation:Egrave:racute:omacron:Zacute:Zcaron:greaterequal:Eth:Ccedilla:lcommaaccent:tcaron:eogonek:Uogonek:Aacute:Adieresis:egrave:zacute:iogonek:Oacute:oacute:amacron:sacute:idieresis:Ocircumflex:Ugrave:Delta:thorn:twosuperior:Odieresis:mu:igrave:ohungarumlaut:Eogonek:dcroat:threequarters:Scedilla:lcaron:Kcommaaccent:Lacute:trademark:edotaccent:Igrave:Imacron:Lcaron:onehalf:lessequal:ocircumflex:ntilde:Uhungarumlaut:Eacute:emacron:gbreve:onequarter:Scaron:Scommaaccent:Ohungarumlaut:degree:ograve:Ccaron:ugrave:radical:Dcaron:rcommaaccent:Ntilde:otilde:Rcommaaccent:Lcommaaccent:Atilde:Aogonek:Aring:Otilde:zdotaccent:Ecaron:Iogonek:kcommaaccent:minus:Icircumflex:ncaron:tcommaaccent:logicalnot:odieresis:udieresis:notequal:gcommaaccent:eth:zcaron:ncommaaccent:onesuperior:imacron:Euro:universal:existential:suchthat:asteriskmath:congruent:Alpha:Beta:Chi:Epsilon:Phi:Gamma:Eta:Iota:theta1:Kappa:Lambda:Mu:Nu:Omicron:Pi:Theta:Rho:Sigma:Tau:Upsilon:sigma1:Omega:Xi:Psi:Zeta:therefore:perpendicular:radicalex:alpha:beta:chi:delta:epsilon:phi:gamma:eta:iota:phi1:kappa:lambda:nu:omicron:pi:theta:rho:sigma:tau:upsilon:omega1:omega:xi:psi:zeta:similar:Upsilon1:minute:infinity:club:diamond:heart:spade:arrowboth:arrowleft:arrowup:arrowright:arrowdown:second:proportional:equivalence:approxequal:arrowvertex:arrowhorizex:carriagereturn:aleph:Ifraktur:Rfraktur:weierstrass:circlemultiply:circleplus:emptyset:intersection:union:propersuperset:reflexsuperset:notsubset:propersubset:reflexsubset:element:notelement:angle:gradient:registerserif:copyrightserif:trademarkserif:product:dotmath:logicaland:logicalor:arrowdblboth:arrowdblleft:arrowdblup:arrowdblright:arrowdbldown:angleleft:registersans:copyrightsans:trademarksans:parenlefttp:parenleftex:parenleftbt:bracketlefttp:bracketleftex:bracketleftbt:bracelefttp:braceleftmid:braceleftbt:braceex:angleright:integral:integraltp:integralex:integralbt:parenrighttp:parenrightex:parenrightbt:bracketrighttp:bracketrightex:bracketrightbt:bracerighttp:bracerightmid:bracerightbt:apple:a1:a2:a202:a3:a4:a5:a119:a118:a117:a11:a12:a13:a14:a15:a16:a105:a17:a18:a19:a20:a21:a22:a23:a24:a25:a26:a27:a28:a6:a7:a8:a9:a10:a29:a30:a31:a32:a33:a34:a35:a36:a37:a38:a39:a40:a41:a42:a43:a44:a45:a46:a47:a48:a49:a50:a51:a52:a53:a54:a55:a56:a57:a58:a59:a60:a61:a62:a63:a64:a65:a66:a67:a68:a69:a70:a71:a72:a73:a74:a203:a75:a204:a76:a77:a78:a79:a81:a82:a83:a84:a97:a98:a99:a100:a89:a90:a93:a94:a91:a92:a205:a85:a206:a86:a87:a88:a95:a96:a101:a102:a103:a104:a106:a107:a108:a112:a111:a110:a109:a120:a121:a122:a123:a124:a125:a126:a127:a128:a129:a130:a131:a132:a133:a134:a135:a136:a137:a138:a139:a140:a141:a142:a143:a144:a145:a146:a147:a148:a149:a150:a151:a152:a153:a154:a155:a156:a157:a158:a159:a160:a161:a163:a164:a196:a165:a192:a166:a167:a168:a169:a170:a171:a172:a173:a162:a174:a175:a176:a177:a178:a179:a193:a180:a199:a181:a200:a182:a201:a183:a184:a197:a185:a194:a198:a186:a195:a187:a188:a189:a190:a191'.split(':');
          var CHARACTERS = '.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde .notdef Euro .notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand Scaron guilsinglleft OE .notdef Zcaron .notdef .notdef quoteleft quoteright quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright oe .notdef zcaron ydieresis space exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute mu paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown Agrave Aacute Acircumflex Atilde Adieresis Aring AE Ccedilla Egrave Eacute Ecircumflex Edieresis Igrave Iacute Icircumflex Idieresis Eth Ntilde Ograve Oacute Ocircumflex Otilde Odieresis multiply Oslash Ugrave Uacute Ucircumflex Udieresis Yacute Thorn germandbls agrave aacute acircumflex atilde adieresis aring ae ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis'.split(' ');

          var AFMFont = /*#__PURE__*/function () {
            function AFMFont(contents) {
              this.contents = contents;
              this.bbox = this._parseFontBBox(contents[1]);
              this.ascender = contents[4];
              this.descender = contents[5];
              this.glyphWidths = this._parseGlyphWidths(contents[6]);
              this.charWidths = this._getCharWidths();
              this.kernPairs = this._parseKerningPairs(contents[7]);
              this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
            }

            var _proto = AFMFont.prototype;

            _proto.encodeText = function encodeText(text) {
              var res = [];

              for (var i = 0, len = text.length; i < len; i++) {
                var char = text.charCodeAt(i);
                char = WIN_ANSI_MAP[char] || char;
                res.push(char.toString(16));
              }

              return res;
            };

            _proto.glyphsForString = function glyphsForString(text) {
              var res = [];

              for (var i = 0, len = text.length; i < len; i++) {
                var charCode = text.charCodeAt(i);
                res.push(this.characterToGlyph(charCode));
              }

              return res;
            };

            _proto.characterToGlyph = function characterToGlyph(character) {
              return CHARACTERS[WIN_ANSI_MAP[character] || character] || '.notdef';
            };

            _proto.widthOfGlyph = function widthOfGlyph(glyph) {
              return this.glyphWidths[glyph] || 0;
            };

            _proto.getKernPair = function getKernPair(left, right) {
              return this.kernPairs[left + '\0' + right] || 0;
            };

            _proto.advancesForGlyphs = function advancesForGlyphs(glyphs) {
              var advances = [];

              for (var index = 0; index < glyphs.length; index++) {
                var left = glyphs[index];
                var right = glyphs[index + 1];
                advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
              }

              return advances;
            };

            _proto._parseFontBBox = function _parseFontBBox(val) {
              var tmp = val.split(':'),
                res = [];

              for (var i = 0, len = tmp.length; i < len; i++) {
                res.push(_parseInt(tmp[i]));
              }

              return res;
            };

            _proto._getCharWidths = function _getCharWidths() {
              var res = [];

              for (var i = 0; i <= 255; i++) {
                res.push(this.glyphWidths[CHARACTERS[i]]);
              }

              return res;
            };

            _proto._parseGlyphWidths = function _parseGlyphWidths(val) {
              var widths = val.split(',');
              var res = {};

              if (widths.length == 1) {
                var m = widths[0].match(/(^\d+)-(\d+):(\d+)$/),
                  start = _parseInt(m[1]),
                  end = _parseInt(m[2]),
                  width = _parseInt(m[3]);

                for (var i = start; i <= end; i++) {
                  res[CHAR_TABLE[i]] = width;
                }
              } else {
                var charTableIndex = 0;

                for (var _i = 0, len = widths.length; _i < len; _i++) {
                  var pair = widths[_i].split(':'),
                    _width = void 0;

                  if (pair.length === 1) {
                    _width = _parseInt(pair[0]);
                  } else {
                    charTableIndex = _parseInt(pair[0]);
                    _width = _parseInt(pair[1]);
                  }

                  res[CHAR_TABLE[charTableIndex++]] = _width;
                }
              }

              return res;
            };

            _proto._parseKerningPairs = function _parseKerningPairs(val) {
              var res = {}; // if (!val) {
              //   return res;
              // }
              // let b1Mask = 255,
              //   b2Mask = 128,
              //   cycle = 1, // [1..8]
              //   tmp = [],
              //   bytes = base64.toByteArray(val); // A bit vector, each value is packed into 9 bit (LE).
              // for (let i = 0; i < bytes.length; i++) {
              //   let b1 = bytes[i],
              //     b2 = bytes[i + 1];
              //   b1 = (b1 & b1Mask) << cycle;
              //   b2 = (b2 & b2Mask) >> (8 - cycle);
              //   tmp.push(b1 | b2);
              //   b1Mask = b1Mask >> 1;
              //   b2Mask = (b2Mask >> 1) | 128;
              //   cycle++;
              //   if (cycle > 8) {
              //     i++; // skip one byte because it is fully processed.
              //     cycle = 1;
              //     b1Mask = 255;
              //     b2Mask = 128;
              //   }
              // }
              // // now tmp is an array of triplets <firstCharIndex, secondCharIndex, kerning>
              // for (let i = 0; i < tmp.length - 2; i = i + 3) {
              //   let kerning = tmp[i + 2],
              //     first = CHAR_TABLE[tmp[i]],
              //     second = CHAR_TABLE[tmp[i + 1]];
              //   if (kerning > 255) {
              //     kerning = -(kerning & 255); // handle negative value, "sign and magnitude" representation.
              //   }
              //   res[first + '\0' + second] = kerning;
              // }

              return res;
            };

            return AFMFont;
          }(); // GrapeCity end


          var PDFFont = /*#__PURE__*/function () {
            function PDFFont() { }

            var _proto = PDFFont.prototype;

            _proto.encode = function encode() {
              throw new Error('Must be implemented by subclasses');
            };

            _proto.widthOfString = function widthOfString() {
              throw new Error('Must be implemented by subclasses');
            };

            _proto.ref = function ref() {
              return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
            };

            _proto.finalize = function finalize() {
              if (this.embedded || this.dictionary == null) {
                return;
              }

              this.embed();
              return this.embedded = true;
            };

            _proto.embed = function embed() {
              throw new Error('Must be implemented by subclasses');
            } // GrapeCity begin
              ;

            _proto.getAscender = function getAscender(size) {
              return this.ascender / 1000 * size;
            };

            _proto.getBBox = function getBBox(size) {
              return {
                llx: this.bbox[0] / 1000 * size,
                lly: this.bbox[1] / 1000 * size,
                urx: this.bbox[2] / 1000 * size,
                ury: this.bbox[3] / 1000 * size
              };
            } // GrapeCity end
              ;

            _proto.lineHeight = function lineHeight(size, includeGap) {
              if (includeGap == null) {
                includeGap = false;
              }

              var gap = includeGap ? this.lineGap : 0;
              return (this.ascender + gap - this.descender) / 1000 * size;
            };

            return PDFFont;
          }();

          var STANDARD_FONTS = {
            Courier: function Courier() {
              return "0, \"-23:-250:715:805\", 562, 426, 629, -157, \"0-314:600\"";
            },
            'Courier-Bold': function CourierBold() {
              return "0, \"-113:-250:749:801\", 562, 439, 629, -157, \"0-314:600\"";
            },
            'Courier-Oblique': function CourierOblique() {
              return "-12, \"-27:-250:849:805\", 562, 426, 629, -157, \"0-314:600\"";
            },
            'Courier-BoldOblique': function CourierBoldOblique() {
              return "-12, \"-57:-250:869:801\", 562, 439, 629, -157, \"0-314:600\"";
            },
            Helvetica: function Helvetica() {
              return "0, \"-166:-225:1000:931\", 718, 523, 718, -207, \"278,278,355,556,556,889,667,222,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,222,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,333,556,556,167,556,556,556,556,191,333,556,333,333,500,500,556,556,556,278,537,350,222,333,333,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,556,778,1000,365,889,278,222,611,944,611,278,556,556,556,556,667,584,667,667,556,722,500,500,556,722,722,556,722,556,667,722,250,737,667,500,556,722,222,556,611,722,556,667,500,500,278,471,722,778,556,556,667,333,500,611,667,778,722,667,643,722,556,333,778,667,667,584,556,611,476,500,722,278,667,556,556,500,556,556,722,278,584,260,737,778,278,600,667,333,556,611,611,549,722,722,222,317,556,722,667,667,556,500,222,778,556,556,500,278,778,722,612,556,333,778,556,278,556,667,556,834,667,299,667,556,1000,556,278,278,556,834,549,556,556,722,667,556,556,834,667,667,778,400,556,722,556,453,722,333,722,556,722,556,667,667,667,778,500,667,278,500,584,278,556,278,584,556,556,549,556,556,500,556,333,278,556\"";
            },
            'Helvetica-Bold': function HelveticaBold() {
              return "0, \"-170:-228:1003:962\", 718, 532, 718, -207, \"278,333,474,556,556,889,722,278,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,278,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,333,556,556,167,556,556,556,556,238,500,556,333,333,611,611,556,556,556,278,556,350,278,500,500,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,611,778,1000,365,889,278,278,611,944,611,278,556,556,611,556,667,584,667,722,556,722,556,556,556,722,722,556,722,611,667,722,250,737,667,556,556,722,278,556,611,722,556,667,556,556,278,494,722,778,611,556,722,389,556,611,667,778,722,667,743,722,611,333,778,722,722,584,611,611,494,556,722,278,667,556,556,556,611,611,722,278,584,280,737,778,278,600,667,389,611,611,611,549,722,722,278,389,556,722,722,722,556,500,278,778,611,556,556,278,778,722,612,611,333,778,611,278,611,667,611,834,667,400,722,611,1000,556,278,278,611,834,549,611,611,722,667,556,611,834,667,667,778,400,611,722,611,549,722,389,722,611,722,611,722,722,722,778,500,667,278,556,584,278,611,333,584,611,611,549,611,611,500,611,333,278,556\"";
            },
            'Helvetica-Oblique': function HelveticaOblique() {
              return "-12, \"-170:-225:1116:931\", 718, 523, 718, -207, \"278,278,355,556,556,889,667,222,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,222,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,333,556,556,167,556,556,556,556,191,333,556,333,333,500,500,556,556,556,278,537,350,222,333,333,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,556,778,1000,365,889,278,222,611,944,611,278,556,556,556,556,667,584,667,667,556,722,500,500,556,722,722,556,722,556,667,722,250,737,667,500,556,722,222,556,611,722,556,667,500,500,278,471,722,778,556,556,667,333,500,611,667,778,722,667,643,722,556,333,778,667,667,584,556,611,476,500,722,278,667,556,556,500,556,556,722,278,584,260,737,778,278,600,667,333,556,611,611,549,722,722,222,317,556,722,667,667,556,500,222,778,556,556,500,278,778,722,612,556,333,778,556,278,556,667,556,834,667,299,667,556,1000,556,278,278,556,834,549,556,556,722,667,556,556,834,667,667,778,400,556,722,556,453,722,333,722,556,722,556,667,667,667,778,500,667,278,500,584,278,556,278,584,556,556,549,556,556,500,556,333,278,556\"";
            },
            'Helvetica-BoldOblique': function HelveticaBoldOblique() {
              return "-12, \"-174:-228:1114:962\", 718, 532, 718, -207, \"278,333,474,556,556,889,722,278,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,278,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,333,556,556,167,556,556,556,556,238,500,556,333,333,611,611,556,556,556,278,556,350,278,500,500,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,611,778,1000,365,889,278,278,611,944,611,278,556,556,611,556,667,584,667,722,556,722,556,556,556,722,722,556,722,611,667,722,250,737,667,556,556,722,278,556,611,722,556,667,556,556,278,494,722,778,611,556,722,389,556,611,667,778,722,667,743,722,611,333,778,722,722,584,611,611,494,556,722,278,667,556,556,556,611,611,722,278,584,280,737,778,278,600,667,389,611,611,611,549,722,722,278,389,556,722,722,722,556,500,278,778,611,556,556,278,778,722,612,611,333,778,611,278,611,667,611,834,667,400,722,611,1000,556,278,278,611,834,549,611,611,722,667,556,611,834,667,667,778,400,611,722,611,549,722,389,722,611,722,611,722,722,722,778,500,667,278,556,584,278,611,333,584,611,611,549,611,611,500,611,333,278,556\"";
            },
            'Times-Roman': function TimesRoman() {
              return "0, \"-168:-218:1000:898\", 662, 450, 683, -217, \"250,333,408,500,500,833,778,333,333,333,500,564,250,333,250,278,500,500,500,500,500,500,500,500,500,500,278,278,564,564,564,444,921,722,667,667,722,611,556,722,722,333,389,722,611,889,722,722,556,722,667,556,611,722,722,944,722,722,611,333,278,333,469,500,333,444,500,444,500,444,333,500,500,278,278,500,278,778,500,500,500,500,333,389,278,500,500,722,500,500,444,480,200,480,541,333,500,500,167,500,500,500,500,180,444,500,333,333,556,556,500,500,500,250,453,350,333,444,444,500,1000,1000,444,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,889,276,611,722,889,310,667,278,278,500,722,500,333,444,444,500,444,722,564,722,722,444,722,500,389,444,722,722,444,722,500,611,722,250,760,611,444,444,722,278,444,611,667,444,611,389,389,278,471,667,722,500,444,722,333,444,611,556,722,667,556,588,722,500,300,722,722,722,564,500,611,476,500,722,278,611,444,444,444,500,500,722,333,564,200,760,722,333,600,611,333,500,611,611,549,722,667,278,326,444,722,722,722,444,444,278,722,500,444,389,278,722,722,612,500,300,722,500,278,500,611,500,750,556,344,722,611,980,444,333,333,611,750,549,500,500,722,611,444,500,750,556,556,722,400,500,667,500,453,722,333,722,500,667,611,722,722,722,722,444,611,333,500,564,333,500,278,564,500,500,549,500,500,444,500,300,278,500\"";
            },
            'Times-Bold': function TimesBold() {
              return "0, \"-168:-218:1000:935\", 676, 461, 683, -217, \"250,333,555,500,500,1000,833,333,333,333,500,570,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,570,570,570,500,930,722,667,722,722,667,611,778,778,389,500,778,667,944,722,778,611,778,722,556,667,722,722,1000,722,722,667,333,278,333,581,500,333,500,556,444,556,444,333,500,556,278,333,556,278,833,556,500,556,556,444,389,333,556,500,722,500,500,444,394,220,394,520,333,500,500,167,500,500,500,500,278,500,500,333,333,556,556,500,500,500,250,540,350,333,500,500,500,1000,1000,500,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,300,667,778,1000,330,722,278,278,500,722,556,389,444,500,556,444,722,570,722,722,500,722,500,389,444,722,722,500,722,556,667,722,250,747,667,444,500,722,278,500,667,722,500,667,389,389,278,494,722,778,556,500,722,444,444,667,611,778,722,556,672,722,556,300,778,722,722,570,556,667,494,500,722,278,667,500,444,444,556,556,722,389,570,220,747,778,389,600,667,444,500,667,667,549,722,722,278,416,444,722,722,722,444,444,278,778,500,500,389,278,778,722,612,556,300,778,556,278,500,667,556,750,556,394,778,667,1000,444,389,389,667,750,549,500,556,722,667,444,500,750,556,556,778,400,500,722,556,549,722,444,722,500,722,667,722,722,722,778,444,667,389,556,570,389,556,333,570,500,556,549,500,500,444,556,300,278,500\"";
            },
            'Times-Italic': function TimesItalic() {
              return "-15.5, \"-169:-217:1010:883\", 653, 441, 683, -217, \"250,333,420,500,500,833,778,333,333,333,500,675,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,675,675,675,500,920,611,611,667,722,611,611,722,722,333,444,667,556,833,667,722,611,722,611,500,556,722,611,833,611,556,556,389,278,389,422,500,333,500,500,444,500,444,278,500,500,278,278,444,278,722,500,500,500,500,389,389,278,500,444,667,444,444,389,400,275,400,541,389,500,500,167,500,500,500,500,214,556,500,333,333,500,500,500,500,500,250,523,350,333,556,556,500,889,1000,500,333,333,333,333,333,333,333,333,333,333,333,333,333,889,889,276,556,722,944,310,667,278,278,500,667,500,333,444,500,500,444,556,675,556,611,500,722,444,389,444,722,722,500,722,500,611,722,250,760,611,444,500,667,278,500,556,667,500,611,389,389,278,471,611,722,500,500,611,389,444,556,611,722,611,500,544,722,500,300,722,611,611,675,500,556,476,444,667,278,611,500,444,444,500,500,667,333,675,275,760,722,333,600,611,389,500,556,556,549,722,667,278,300,444,722,611,611,444,389,278,722,500,500,389,278,722,722,612,500,300,722,500,278,500,611,500,750,500,300,667,556,980,444,333,333,611,750,549,500,500,722,611,444,500,750,500,500,722,400,500,667,500,453,722,389,667,500,611,556,611,611,611,722,389,611,333,444,675,333,500,278,675,500,500,549,500,500,389,500,300,278,500\"";
            },
            'Times-BoldItalic': function TimesBoldItalic() {
              return "-15, \"-200:-218:996:921\", 669, 462, 683, -217, \"250,389,555,500,500,833,778,333,333,333,500,570,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,570,570,570,500,832,667,667,667,722,667,667,722,778,389,500,667,611,889,722,722,611,722,667,556,611,722,667,889,667,611,611,333,278,333,570,500,333,500,500,444,500,444,333,500,556,278,278,500,278,778,556,500,500,500,389,389,278,556,444,667,500,444,389,348,220,348,570,389,500,500,167,500,500,500,500,278,500,500,333,333,556,556,500,500,500,250,500,350,333,500,500,500,1000,1000,500,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,944,266,611,722,944,300,722,278,278,500,722,500,389,444,500,556,444,611,570,611,667,500,722,444,389,444,722,722,500,722,556,667,722,250,747,667,444,500,722,278,500,611,667,500,667,389,389,278,494,667,722,556,500,667,389,444,611,611,722,667,556,608,722,556,300,722,667,667,570,556,611,494,444,722,278,667,500,444,444,556,556,722,389,570,220,747,722,389,600,667,389,500,611,611,549,722,667,278,366,444,722,667,667,444,389,278,722,500,500,389,278,722,722,612,500,300,722,576,278,500,667,500,750,556,382,667,611,1000,444,389,389,611,750,549,500,556,722,667,444,500,750,556,556,722,400,500,667,556,549,722,389,722,500,667,611,667,667,667,722,389,667,389,500,606,389,556,278,606,500,556,549,500,500,389,556,300,278,500\"";
            },
            Symbol: function Symbol() {
              return "0, \"-180:-293:1090:1010\", 0, 0, 0, 0, \"250,333,315:713,3:500,316:549,5:833,778,317:439,8:333,333,318:500,11:549,250,300:549,14:250,278,500,500,500,500,500,500,500,500,500,500,278,278,549,549,549,444,319:549,722,667,722,250:612,323:611,763,603,722,333,631,722,686,889,722,722,768,741,556,592,611,690,439,768,645,795,611,59:333,345:863,61:333,346:658,63:500,347:500,631,549,549,494,439,521,411,603,329,603,549,549,254:576,360:521,549,549,521,549,603,439,576,713,686,493,686,494,91:480,200,480,373:549,314:750,374:620,247,270:549,98:167,376:713,100:500,377:753,753,753,753,1042,987,603,987,603,281:400,220:549,386:411,231:549,205:549,387:713,208:494,115:460,155:549,307:549,388:549,549,120:1000,390:603,1000,658,823,686,795,987,768,768,823,768,768,713,713,713,713,713,713,713,768,713,790,790,890,823,285:549,415:250,304:713,416:603,603,1042,987,603,987,603,185:494,423:329,790,790,786,225:713,427:384,384,384,384,384,384,494,494,494,494,329,274,686,686,686,384,384,384,384,384,384,494,494,494,790\"";
            },
            ZapfDingbats: function ZapfDingbats() {
              return "0, \"-1:-143:981:820\", 0, 0, 0, 0, \"278,452:974,961,974,980,719,789,790,791,690,960,939,549,855,911,933,911,945,974,755,846,762,761,571,677,763,760,759,754,494,552,537,577,692,786,788,788,790,793,794,816,823,789,841,823,833,816,831,923,744,723,749,790,792,695,776,768,792,759,707,708,682,701,826,815,789,789,707,687,696,689,786,787,713,791,785,791,873,761,762,762,759,759,892,892,788,784,438,138,277,415,392,392,668,668,390,390,317,317,276,276,509,509,410,410,234,234,334,334,732,544,544,910,667,760,760,776,595,694,626,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,894,838,1016,458,748,924,748,918,927,928,928,834,873,828,924,924,917,930,931,463,883,836,836,867,867,696,696,874,874,760,946,771,865,771,888,967,888,831,873,927,970,918\"";
            }
          }; // GrapeCity begin: compressed font (no kerning).

          var StandardFont: any = /*#__PURE__*/function (_PDFFont) {
            _inheritsLoose(StandardFont, _PDFFont);

            function StandardFont(document, name, id) {
              var _this;

              _this = _PDFFont.call(this) || this;
              _this.document = document;
              _this.name = name;
              _this.id = id;
              _this.font = new AFMFont(JSON.parse('[' + STANDARD_FONTS[_this.name]() + ',\"' + _this.getKerning(_this.name) + '\"]'));
              var _this$font = _this.font;
              _this.ascender = _this$font.ascender;
              _this.descender = _this$font.descender;
              _this.bbox = _this$font.bbox;
              _this.lineGap = _this$font.lineGap;
              _this.xHeight = _this$font.xHeight;
              _this.capHeight = _this$font.capHeight;
              return _this;
            }

            var _proto = StandardFont.prototype;

            _proto.embed = function embed() {
              this.dictionary.data = {
                Type: 'Font',
                BaseFont: this.name,
                Subtype: 'Type1',
                Encoding: 'WinAnsiEncoding'
              };
              return this.dictionary.end();
            };

            _proto.encode = function encode(text) {
              var encoded = this.font.encodeText(text);
              var glyphs = this.font.glyphsForString("" + text);
              var advances = this.font.advancesForGlyphs(glyphs);
              var positions = [];

              for (var i = 0; i < glyphs.length; i++) {
                var glyph = glyphs[i];
                positions.push({
                  xAdvance: advances[i],
                  yAdvance: 0,
                  xOffset: 0,
                  yOffset: 0,
                  advanceWidth: this.font.widthOfGlyph(glyph)
                });
              }

              return [encoded, positions];
            };

            _proto.widthOfString = function widthOfString(string, size) {
              var glyphs = this.font.glyphsForString("" + string);
              var advances = this.font.advancesForGlyphs(glyphs);
              var width = 0;

              for (var _iterator = _createForOfIteratorHelperLoose(advances), _step; !(_step = _iterator()).done;) {
                var advance = _step.value;
                width += advance;
              }

              var scale = size / 1000;
              return width * scale;
            };

            (<any>StandardFont).isStandardFont = function isStandardFont(name) {
              return name in STANDARD_FONTS;
            };

            _proto.getKerning = function getKerning(fontName) {
              return '';
            };

            return StandardFont;
          }(PDFFont); // GrapeCity end


          var toHex = function toHex(num) {
            return ("0000" + num.toString(16)).slice(-4);
          };

          var EmbeddedFont = /*#__PURE__*/function (_PDFFont) {
            _inheritsLoose(EmbeddedFont, _PDFFont);

            function EmbeddedFont(document, font, id): void {
              var _this;

              _this = _PDFFont.call(this) || this;
              _this.document = document;
              _this.font = font;
              _this.id = id;
              _this.subset = _this.font.createSubset();
              _this.unicode = [[0]];
              _this.widths = [_this.font.getGlyph(0).advanceWidth];
              _this.name = _this.font.postscriptName;
              _this.scale = 1000 / _this.font.unitsPerEm;
              _this.ascender = _this.font.ascent * _this.scale;
              _this.descender = _this.font.descent * _this.scale;
              _this.xHeight = _this.font.xHeight * _this.scale;
              _this.capHeight = _this.font.capHeight * _this.scale;
              _this.lineGap = _this.font.lineGap * _this.scale;
              _this.bbox = _this.font.bbox;

              if (document.options.fontLayoutCache !== false) {
                _this.layoutCache = _Object$create(null);
              }

              return _this;
            }

            var _proto = EmbeddedFont.prototype;

            _proto.layoutRun = function layoutRun(text, features) {
              var run = this.font.layout(text, features); // Normalize position values

              for (var i = 0; i < run.positions.length; i++) {
                var position = run.positions[i];

                for (var key in position) {
                  position[key] *= this.scale;
                }

                position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;
              }

              return run;
            };

            _proto.layoutCached = function layoutCached(text) {
              if (!this.layoutCache) {
                return this.layoutRun(text);
              }

              var cached;

              if (cached = this.layoutCache[text]) {
                return cached;
              }

              var run = this.layoutRun(text);
              this.layoutCache[text] = run;
              return run;
            };

            _proto.layout = function layout(text, features, onlyWidth) {
              // Skip the cache if any user defined features are applied
              if (features) {
                return this.layoutRun(text, features);
              }

              var glyphs = onlyWidth ? null : [];
              var positions = onlyWidth ? null : [];
              var advanceWidth = 0; // Split the string by words to increase cache efficiency.
              // For this purpose, spaces and tabs are a good enough delimeter.
              //
              // GrapeCity begin
              // original: "ab  cd" => ["ab ", " ", "cd"]
              // fixed:    "ab  cd" => ["ab", " ", " ", "cd"]

              var delimeters = [' ', '\t'],
                prevDelim = false,
                last = 0,
                len = text.length;

              for (var i = 0; i <= len; i++) {
                var delim = delimeters.indexOf(text.charAt(i)) >= 0;

                if (delim && i || prevDelim || i === len && last < i) {
                  var run = this.layoutCached(text.slice(last, i));

                  if (!onlyWidth) {
                    glyphs = glyphs.concat(run.glyphs);
                    positions = positions.concat(run.positions);
                  }

                  advanceWidth += run.advanceWidth;
                  last = i;
                }

                prevDelim = delim;
              } // let last = 0;
              // let index = 0;
              // while (index <= text.length) {
              //   var needle;
              //   if (
              //     (index === text.length && last < index) ||
              //     ((needle = text.charAt(index)), [' ', '\t'].includes(needle))
              //   ) {
              //     const run = this.layoutCached(text.slice(last, ++index));
              //     if (!onlyWidth) {
              //       glyphs = glyphs.concat(run.glyphs);
              //       positions = positions.concat(run.positions);
              //     }
              //     advanceWidth += run.advanceWidth;
              //     last = index;
              //   } else {
              //     index++;
              //   }
              // }
              // GrapeCity end


              return {
                glyphs: glyphs,
                positions: positions,
                advanceWidth: advanceWidth
              };
            };

            _proto.encode = function encode(text, features) {
              var _this$layout = this.layout(text, features),
                glyphs = _this$layout.glyphs,
                positions = _this$layout.positions;

              var res = [];

              for (var i = 0; i < glyphs.length; i++) {
                var glyph = glyphs[i];
                var gid = this.subset.includeGlyph(glyph.id);
                res.push(("0000" + gid.toString(16)).slice(-4));

                if (this.widths[gid] == null) {
                  this.widths[gid] = glyph.advanceWidth * this.scale;
                }

                if (this.unicode[gid] == null) {
                  this.unicode[gid] = glyph.codePoints;
                }
              }

              return [res, positions];
            };

            _proto.widthOfString = function widthOfString(string, size, features) {
              var width = this.layout(string, features, true).advanceWidth;
              var scale = size / 1000;
              return width * scale;
            };

            _proto.embed = function embed() {
              var _this2 = this;

              var isCFF = this.subset.cff != null;
              var fontFile = this.document.ref();

              if (isCFF) {
                fontFile.data.Subtype = 'CIDFontType0C';
              }

              this.subset.encodeStream().on('data', function (data) {
                return fontFile.write(data);
              }).on('end', function () {
                return fontFile.end();
              });
              var familyClass = ((this.font['OS/2'] != null ? this.font['OS/2'].sFamilyClass : undefined) || 0) >> 8;
              var flags = 0;

              if (this.font.post.isFixedPitch) {
                flags |= 1 << 0;
              }

              if (1 <= familyClass && familyClass <= 7) {
                flags |= 1 << 1;
              }

              flags |= 1 << 2; // assume the font uses non-latin characters

              if (familyClass === 10) {
                flags |= 1 << 3;
              }

              if (this.font.head.macStyle.italic) {
                flags |= 1 << 6;
              } // generate a tag (6 uppercase letters. 16 is the char code offset from '1' to 'A'. 74 will map to 'Z')


              var tag = [1, 2, 3, 4, 5, 6].map(function (i) {
                return String.fromCharCode((_this2.id.charCodeAt(i) || 74) + 16);
              }).join('');
              var name = tag + '+' + this.font.postscriptName;
              var bbox = this.font.bbox;
              var descriptor = this.document.ref({
                Type: 'FontDescriptor',
                FontName: name,
                Flags: flags,
                FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
                ItalicAngle: this.font.italicAngle,
                Ascent: this.ascender,
                Descent: this.descender,
                CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
                XHeight: (this.font.xHeight || 0) * this.scale,
                StemV: 0
              }); // not sure how to calculate this

              if (isCFF) {
                descriptor.data.FontFile3 = fontFile;
              } else {
                descriptor.data.FontFile2 = fontFile;
              }

              descriptor.end();
              var descendantFontData = {
                Type: 'Font',
                Subtype: 'CIDFontType0',
                BaseFont: name,
                CIDSystemInfo: {
                  Registry: new String('Adobe'),
                  Ordering: new String('Identity'),
                  Supplement: 0
                },
                FontDescriptor: descriptor,
                W: [0, this.widths]
              };

              if (!isCFF) {
                descendantFontData.Subtype = 'CIDFontType2';
                (<any>descendantFontData).CIDToGIDMap = 'Identity';
              }

              var descendantFont = this.document.ref(descendantFontData);
              descendantFont.end();
              this.dictionary.data = {
                Type: 'Font',
                Subtype: 'Type0',
                BaseFont: name,
                Encoding: 'Identity-H',
                DescendantFonts: [descendantFont],
                ToUnicode: this.toUnicodeCmap()
              };
              return this.dictionary.end();
            } // Maps the glyph ids encoded in the PDF back to unicode strings
              // Because of ligature substitutions and the like, there may be one or more
              // unicode characters represented by each glyph.
              ;

            _proto.toUnicodeCmap = function toUnicodeCmap() {
              var cmap = this.document.ref();
              var entries = [];

              for (var _iterator = _createForOfIteratorHelperLoose(this.unicode), _step; !(_step = _iterator()).done;) {
                var codePoints = _step.value;
                var encoded = []; // encode codePoints to utf16

                for (var _iterator2 = _createForOfIteratorHelperLoose(codePoints), _step2; !(_step2 = _iterator2()).done;) {
                  var value = _step2.value;

                  if (value > 0xffff) {
                    value -= 0x10000;
                    encoded.push(toHex(value >>> 10 & 0x3ff | 0xd800));
                    value = 0xdc00 | value & 0x3ff;
                  }

                  encoded.push(toHex(value));
                }

                entries.push("<" + encoded.join(' ') + ">");
              }

              cmap.end("/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n<0000> <" + toHex(entries.length - 1) + "> [" + entries.join(' ') + "]\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend");
              return cmap;
            };

            return EmbeddedFont;
          }(PDFFont); //import fs from 'fs';


          var PDFFontFactory = /*#__PURE__*/function () {
            function PDFFontFactory() { }

            (<any>PDFFontFactory).open = function open(document, src, family, id) {
              var font;

              if (typeof src === 'string') {
                if (StandardFont.isStandardFont(src)) {
                  return new StandardFont(document, src, id);
                } //src = fs.readFileSync(src);

              }

              if (Buffer.isBuffer(src)) {
                font = fontkit.create(src, family);
              } else if (src instanceof Uint8Array) {
                font = fontkit.create(new Buffer(src), family);
              } else if (src instanceof ArrayBuffer) {
                font = fontkit.create(new Buffer(new Uint8Array(src)), family);
              }

              if (font == null) {
                throw new Error('Not a supported font format or standard PDF font.');
              }

              return new EmbeddedFont(document, font, id);
            };

            return PDFFontFactory;
          }();

          var FontsMixin = {
            initFonts: function initFonts(defaultFont) {
              if (defaultFont === void 0) {
                defaultFont = 'Helvetica';
              } // Lookup table for embedded fonts


              this._fontFamilies = {};
              this._fontCount = 0; // Font state

              this._fontSize = 12;
              this._font = null;
              this._registeredFonts = {}; // Set the default font

              if (defaultFont) {
                this.font(defaultFont);
              }
            },
            font: function font(src, family, size) {
              var cacheKey, font;

              if (typeof family === 'number') {
                size = family;
                family = null;
              } // check registered fonts if src is a string


              if (typeof src === 'string' && this._registeredFonts[src]) {
                cacheKey = src;
                var _this$_registeredFont = this._registeredFonts[src];
                src = _this$_registeredFont.src;
                family = _this$_registeredFont.family;
              } else {
                cacheKey = family || src;

                if (typeof cacheKey !== 'string') {
                  cacheKey = null;
                }
              }

              if (size != null) {
                this.fontSize(size);
              } // fast path: check if the font is already in the PDF


              if (font = this._fontFamilies[cacheKey]) {
                this._font = font;
                return this;
              } // load the font


              var id = "F" + ++this._fontCount;
              this._font = (<any>PDFFontFactory).open(this, src, family, id); // check for existing font familes with the same name already in the PDF
              // useful if the font was passed as a buffer

              if (font = this._fontFamilies[this._font.name]) {
                this._font = font;
                return this;
              } // save the font for reuse later


              if (cacheKey) {
                this._fontFamilies[cacheKey] = this._font;
              }

              if (this._font.name) {
                this._fontFamilies[this._font.name] = this._font;
              }

              return this;
            },
            fontSize: function fontSize(_fontSize) {
              this._fontSize = _fontSize;
              return this;
            },
            currentLineHeight: function currentLineHeight(includeGap) {
              if (includeGap == null) {
                includeGap = false;
              }

              return this._font.lineHeight(this._fontSize, includeGap);
            },
            // GrapeCity begin
            currentFontAscender: function currentFontAscender() {
              return this._font.getAscender(this._fontSize);
            },
            currentFontBBox: function currentFontBBox() {
              return this._font.getBBox(this._fontSize);
            },
            currentFontSize: function currentFontSize() {
              return this._fontSize;
            },
            // GrapeCity end
            registerFont: function registerFont(name, src, family) {
              this._registeredFonts[name] = {
                src: src,
                family: family
              };
              return this;
            }
          };

          var LineWrapper = /*#__PURE__*/function (_EventEmitter) {
            _inheritsLoose(LineWrapper, _EventEmitter);

            function LineWrapper(document, options): void {
              var _this;

              _this = _EventEmitter.call(this) || this;
              _this.document = document;
              _this.indent = options.indent || 0;
              _this.characterSpacing = options.characterSpacing || 0;
              _this.wordSpacing = options.wordSpacing === 0;
              _this.columns = options.columns || 1;
              _this.columnGap = options.columnGap != null ? options.columnGap : 18; // 1/4 inch

              _this.lineWidth = (options.width - _this.columnGap * (_this.columns - 1)) / _this.columns;
              _this.spaceLeft = _this.lineWidth;
              _this.startX = _this.document.x;
              _this.startY = _this.document.y;
              _this.column = 1;
              _this.ellipsis = options.ellipsis;
              _this.continuedX = 0;
              _this.features = options.features; // calculate the maximum Y position the text can appear at

              if (options.height != null) {
                _this.height = options.height;
                _this.maxY = _this.startY + options.height;
              } else {
                _this.maxY = _this.document.page.maxY();
              } // handle paragraph indents


              _this.on('firstLine', function (options) {
                // if this is the first line of the text segment, and
                // we're continuing where we left off, indent that much
                // otherwise use the user specified indent option
                var indent = _this.continuedX || _this.indent;
                _this.document.x += indent;
                _this.lineWidth -= indent;
                return _this.once('line', function () {
                  _this.document.x -= indent;
                  _this.lineWidth += indent;

                  if (options.continued && !_this.continuedX) {
                    _this.continuedX = _this.indent;
                  }

                  if (!options.continued) {
                    return _this.continuedX = 0;
                  }
                });
              }); // handle left aligning last lines of paragraphs


              _this.on('lastLine', function (options) {
                var align = options.align;

                if (align === 'justify') {
                  options.align = 'left';
                }

                _this.lastLine = true;
                return _this.once('line', function () {
                  _this.document.y += options.paragraphGap || 0;
                  options.align = align;
                  return _this.lastLine = false;
                });
              });

              return _this;
            }

            var _proto = LineWrapper.prototype;

            _proto.wordWidth = function wordWidth(word) {
              return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;
            };

            _proto.eachWord = function eachWord(text, fn) {
              // setup a unicode line breaker
              var bk;
              var breaker = new LineBreaker(text);
              var last = null;

              var wordWidths = _Object$create(null);

              while (bk = breaker.nextBreak()) {
                var shouldContinue;
                var word = text.slice((last != null ? last.position : undefined) || 0, bk.position);
                var w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word); // if the word is longer than the whole line, chop it up
                // TODO: break by grapheme clusters, not JS string characters

                if (w > this.lineWidth + this.continuedX) {
                  // make some fake break objects
                  var lbk = last;
                  var fbk: any = {};

                  while (word.length) {
                    // fit as much of the word as possible into the space we have
                    var l, mightGrow;

                    if (w > this.spaceLeft) {
                      // start our check at the end of our available space - this method is faster than a loop of each character and it resolves
                      // an issue with long loops when processing massive words, such as a huge number of spaces
                      l = Math.ceil(this.spaceLeft / (w / word.length));
                      w = this.wordWidth(word.slice(0, l));
                      mightGrow = w <= this.spaceLeft && l < word.length;
                    } else {
                      l = word.length;
                    }

                    var mustShrink = w > this.spaceLeft && l > 0; // shrink or grow word as necessary after our near-guess above

                    while (mustShrink || mightGrow) {
                      if (mustShrink) {
                        w = this.wordWidth(word.slice(0, --l));
                        mustShrink = w > this.spaceLeft && l > 0;
                      } else {
                        w = this.wordWidth(word.slice(0, ++l));
                        mustShrink = w > this.spaceLeft && l > 0;
                        mightGrow = w <= this.spaceLeft && l < word.length;
                      }
                    } // check for the edge case where a single character cannot fit into a line.


                    if (l === 0 && this.spaceLeft === this.lineWidth) {
                      l = 1;
                    } // send a required break unless this is the last piece and a linebreak is not specified


                    fbk.required = bk.required || l < word.length;
                    shouldContinue = fn(word.slice(0, l), w, fbk, lbk);
                    lbk = {
                      required: false
                    }; // get the remaining piece of the word

                    word = word.slice(l);
                    w = this.wordWidth(word);

                    if (shouldContinue === false) {
                      break;
                    }
                  }
                } else {
                  // otherwise just emit the break as it was given to us
                  shouldContinue = fn(word, w, bk, last);
                }

                if (shouldContinue === false) {
                  break;
                }

                last = bk;
              }
            };

            _proto.wrap = function wrap(text, options) {
              var _this2 = this; // override options from previous continued fragments


              if (options.indent != null) {
                this.indent = options.indent;
              }

              if (options.characterSpacing != null) {
                this.characterSpacing = options.characterSpacing;
              }

              if (options.wordSpacing != null) {
                this.wordSpacing = options.wordSpacing;
              }

              if (options.ellipsis != null) {
                this.ellipsis = options.ellipsis;
              } // make sure we're actually on the page
              // and that the first line of is never by
              // itself at the bottom of a page (orphans)


              var nextY = this.document.y + this.document.currentLineHeight(true);

              if (this.document.y > this.maxY || nextY > this.maxY) {
                this.nextSection();
              }

              var buffer = '';
              var textWidth = 0;
              var wc = 0;
              var lc = 0;
              var y = this.document.y; // used to reset Y pos if options.continued (below)

              var emitLine = function emitLine() {
                options.textWidth = textWidth + _this2.wordSpacing * (wc - 1);
                options.wordCount = wc;
                options.lineWidth = _this2.lineWidth;
                y = _this2.document.y;

                _this2.emit('line', buffer, options, _this2);

                return lc++;
              };

              this.emit('sectionStart', options, this);
              this.eachWord(text, function (word, w, bk, last) {
                if (last == null || last.required) {
                  _this2.emit('firstLine', options, _this2);

                  _this2.spaceLeft = _this2.lineWidth;
                }

                if (w <= _this2.spaceLeft) {
                  buffer += word;
                  textWidth += w;
                  wc++;
                }

                if (bk.required || w > _this2.spaceLeft) {
                  // if the user specified a max height and an ellipsis, and is about to pass the
                  // max height and max columns after the next line, append the ellipsis
                  var lh = _this2.document.currentLineHeight(true);

                  if (_this2.height != null && _this2.ellipsis && _this2.document.y + lh * 2 > _this2.maxY && _this2.column >= _this2.columns) {
                    if (_this2.ellipsis === true) {
                      _this2.ellipsis = '…';
                    } // map default ellipsis character


                    buffer = buffer.replace(/\s+$/, '');
                    textWidth = _this2.wordWidth(buffer + _this2.ellipsis); // remove characters from the buffer until the ellipsis fits
                    // to avoid inifinite loop need to stop while-loop if buffer is empty string

                    while (buffer && textWidth > _this2.lineWidth) {
                      buffer = buffer.slice(0, -1).replace(/\s+$/, '');
                      textWidth = _this2.wordWidth(buffer + _this2.ellipsis);
                    } // need to add ellipsis only if there is enough space for it


                    if (textWidth <= _this2.lineWidth) {
                      buffer = buffer + _this2.ellipsis;
                    }

                    textWidth = _this2.wordWidth(buffer);
                  }

                  if (bk.required) {
                    if (w > _this2.spaceLeft) {
                      emitLine();
                      buffer = word;
                      textWidth = w;
                      wc = 1;
                    }

                    _this2.emit('lastLine', options, _this2);
                  }

                  emitLine(); // if we've reached the edge of the page,
                  // continue on a new page or column
                  // GrapeCity begin

                  if (_this2.maxY - (_this2.document.y + lh) < -1e-6) {
                    //if (this.document.y + lh > this.maxY) {
                    // GrapeCity end
                    var shouldContinue = _this2.nextSection(); // stop if we reached the maximum height


                    if (!shouldContinue) {
                      wc = 0;
                      buffer = '';
                      return false;
                    }
                  } // reset the space left and buffer


                  if (bk.required) {
                    _this2.spaceLeft = _this2.lineWidth;
                    buffer = '';
                    textWidth = 0;
                    return wc = 0;
                  } else {
                    // reset the space left and buffer
                    _this2.spaceLeft = _this2.lineWidth - w;
                    buffer = word;
                    textWidth = w;
                    return wc = 1;
                  }
                } else {
                  return _this2.spaceLeft -= w;
                }
              });

              if (wc > 0) {
                this.emit('lastLine', options, this);
                emitLine();
              }

              this.emit('sectionEnd', options, this); // if the wrap is set to be continued, save the X position
              // to start the first line of the next segment at, and reset
              // the y position

              if (options.continued === true) {
                if (lc > 1) {
                  this.continuedX = 0;
                }

                this.continuedX += options.textWidth || 0;
                return this.document.y = y;
              } else {
                return this.document.x = this.startX;
              }
            };

            _proto.nextSection = function nextSection(options) {
              this.emit('sectionEnd', options, this);

              if (++this.column > this.columns) {
                // if a max height was specified by the user, we're done.
                // otherwise, the default is to make a new page at the bottom.
                if (this.height != null) {
                  return false;
                }

                this.document.addPage();
                this.column = 1;
                this.startY = this.document.page.margins.top;
                this.maxY = this.document.page.maxY();
                this.document.x = this.startX;

                if (this.document._fillColor) {
                  var _this$document;

                  (_this$document = this.document).fillColor.apply(_this$document, this.document._fillColor);
                }

                this.emit('pageBreak', options, this);
              } else {
                this.document.x += this.lineWidth + this.columnGap;
                this.document.y = this.startY;
                this.emit('columnBreak', options, this);
              }

              this.emit('sectionStart', options, this);
              return true;
            };

            return LineWrapper;
          }(events.EventEmitter);

          var number$2 = (<any>PDFObject).number;
          var TextMixin = {
            initText: function initText() {
              this._line = this._line.bind(this); // Current coordinates

              this.x = 0;
              this.y = 0;
              return this._lineGap = 0;
            },
            // GrapeCity begin
            currentLineGap: function currentLineGap() {
              return this._lineGap;
            },
            // GrapeCity end
            lineGap: function lineGap(_lineGap) {
              this._lineGap = _lineGap;
              return this;
            },
            moveDown: function moveDown(lines) {
              if (lines == null) {
                lines = 1;
              }

              this.y += this.currentLineHeight(true) * lines + this._lineGap;
              return this;
            },
            moveUp: function moveUp(lines) {
              if (lines == null) {
                lines = 1;
              }

              this.y -= this.currentLineHeight(true) * lines + this._lineGap;
              return this;
            },
            _text: function _text(text, x, y, options, lineCallback) {
              options = this._initOptions(x, y, options); // Convert text to a string

              text = text == null ? '' : "" + text; // if the wordSpacing option is specified, remove multiple consecutive spaces

              if (options.wordSpacing) {
                text = text.replace(/\s{2,}/g, ' ');
              } // word wrapping


              if (options.width) {
                var wrapper = this._wrapper;

                if (!wrapper) {
                  wrapper = new LineWrapper(this, options);
                  wrapper.on('line', lineCallback);
                }

                this._wrapper = options.continued ? wrapper : null;
                this._textOptions = options.continued ? options : null;
                wrapper.wrap(text, options); // render paragraphs as single lines
              } else {
                for (var _iterator = _createForOfIteratorHelperLoose(text.split('\n')), _step; !(_step = _iterator()).done;) {
                  var line = _step.value;
                  lineCallback(line, options);
                }
              }

              return this;
            },
            text: function text(_text2, x, y, options) {
              return this._text(_text2, x, y, options, this._line);
            },
            widthOfString: function widthOfString(string, options) {
              if (options === void 0) {
                options = {};
              }

              return this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1);
            },
            heightOfString: function heightOfString(text, options) {
              var _this = this;

              var x = this.x,
                y = this.y;
              options = this._initOptions(options);
              options.height = Infinity; // don't break pages

              var lineGap = options.lineGap || this._lineGap || 0;

              this._text(text, this.x, this.y, options, function () {
                return _this.y += _this.currentLineHeight(true) + lineGap;
              });

              var height = this.y - y;
              this.x = x;
              this.y = y;
              return height;
            },
            // GrapeCity begin
            // Based on 'text' and 'heightOfString' methods (see above).
            textAndMeasure: function textAndMeasure(text, x, y, options, measureOnly) {
              options = options || {};

              if (x === null) {
                x = this.x;
                y = this.y;
              }

              var self = this,
                tx = this.x,
                ty = this.y,
                sz = {
                  width: 0,
                  height: 0,
                  charCount: 0
                },
                lineGap = options.lineGap || this._lineGap || 0,
                columnGap = options.columnGap || 18,
                lastColX = x === null ? this.x : x,
                col = [],
                colCnt = 0;

              if (measureOnly) {
                if (options.height === null) {
                  options.height = Infinity;
                }
              }

              this._text(text, x, y, options, function (line, options, wrapper) {
                sz.charCount += line.length;

                if (self.x === x) {
                  sz.height += self.currentLineHeight(true) + lineGap;
                }

                if (options.textWidth) {
                  if (self.x > lastColX) {
                    lastColX = self.x;
                    col[colCnt++] = options.lineWidth;
                  }

                  col[colCnt] = Math.max(col[colCnt] || 0, options.textWidth);
                }

                if (measureOnly) {
                  if (!wrapper) {
                    return self.x += self.widthOfString(text);
                  } else {
                    return self.y += self.currentLineHeight(true) + lineGap;
                  }
                } else {
                  return self._line.apply(self, arguments);
                }
              });

              if (!col.length) {
                sz.width = this.x - tx;
              } else {
                col.forEach(function (v) {
                  return sz.width += v + columnGap;
                });
                sz.width -= columnGap;
              }

              if (options.includeLastLineExternalLeading === false) {
                sz.height -= this.currentLineHeight(true) - this.currentLineHeight(false);
              }

              sz.height = Math.max(0, sz.height);

              if (measureOnly) {
                this.x = tx;
                this.y = ty;
              }

              return sz;
            },
            //# GrapeCity end
            list: function list(_list, x, y, options, wrapper) {
              var _this2 = this;

              options = this._initOptions(x, y, options);
              var listType = options.listType || 'bullet';
              var unit = Math.round(this._font.ascender / 1000 * this._fontSize);
              var midLine = unit / 2;
              var r = options.bulletRadius || unit / 3;
              var indent = options.textIndent || (listType === 'bullet' ? r * 5 : unit * 2);
              var itemIndent = options.bulletIndent || (listType === 'bullet' ? r * 8 : unit * 2);
              var level = 1;
              var items = [];
              var levels = [];
              var numbers = [];

              var flatten = function flatten(list) {
                var n = 1;

                for (var _i = 0; _i < list.length; _i++) {
                  var item = list[_i];

                  if (_Array$isArray(item)) {
                    level++;
                    flatten(item);
                    level--;
                  } else {
                    items.push(item);
                    levels.push(level);

                    if (listType !== 'bullet') {
                      numbers.push(n++);
                    }
                  }
                }
              };

              flatten(_list);

              var label = function label(n) {
                switch (listType) {
                  case 'numbered':
                    return n + ".";

                  case 'lettered':
                    var letter = String.fromCharCode((n - 1) % 26 + 65);
                    var times = Math.floor((n - 1) / 26 + 1);
                    var text = Array(times + 1).join(letter);
                    return text + ".";
                }
              };

              wrapper = new LineWrapper(this, options);
              wrapper.on('line', this._line);
              level = 1;
              var i = 0;
              wrapper.on('firstLine', function () {
                var l;

                if ((l = levels[i++]) !== level) {
                  var diff = itemIndent * (l - level);
                  _this2.x += diff;
                  wrapper.lineWidth -= diff;
                  level = l;
                }

                switch (listType) {
                  case 'bullet':
                    _this2.circle(_this2.x - indent + r, _this2.y + midLine, r);

                    return _this2.fill();

                  case 'numbered':
                  case 'lettered':
                    var text = label(numbers[i - 1]);
                    return _this2._fragment(text, _this2.x - indent, _this2.y, options);
                }
              });
              wrapper.on('sectionStart', function () {
                var pos = indent + itemIndent * (level - 1);
                _this2.x += pos;
                return wrapper.lineWidth -= pos;
              });
              wrapper.on('sectionEnd', function () {
                var pos = indent + itemIndent * (level - 1);
                _this2.x -= pos;
                return wrapper.lineWidth += pos;
              });
              wrapper.wrap(items.join('\n'), options);
              return this;
            },
            _initOptions: function _initOptions(x, y, options) {
              if (x === void 0) {
                x = {};
              }

              if (options === void 0) {
                options = {};
              }

              if (typeof x === 'object') {
                options = x;
                x = null;
              } // clone options object


              var result = _Object$assign({}, options); // extend options with previous values for continued text


              if (this._textOptions) {
                for (var key in this._textOptions) {
                  var val = this._textOptions[key];

                  if (key !== 'continued') {
                    if (result[key] === undefined) {
                      result[key] = val;
                    }
                  }
                }
              } // Update the current position


              if (x != null) {
                this.x = x;
              }

              if (y != null) {
                this.y = y;
              } // wrap to margins if no x or y position passed


              if (result.lineBreak !== false) {
                if (result.width == null) {
                  result.width = this.page.width - this.x - this.page.margins.right;
                }

                result.width = Math.max(result.width, 0);
              }

              if (!result.columns) {
                result.columns = 0;
              }

              if (result.columnGap == null) {
                result.columnGap = 18;
              } // 1/4 inch


              return result;
            },
            _line: function _line(text, options, wrapper) {
              if (options === void 0) {
                options = {};
              }

              this._fragment(text, this.x, this.y, options);

              var lineGap = options.lineGap || this._lineGap || 0;

              if (!wrapper) {
                return this.x += this.widthOfString(text);
              } else {
                return this.y += this.currentLineHeight(true) + lineGap;
              }
            },
            _fragment: function _fragment(text, x, y, options) {
              var _this3 = this;

              var dy, encoded, i, positions, textWidth, words; // GrapeCity begin
              //text = ("" + text).replace(/\n/g, '');
              text = ("" + text).replace(/\n|\r/g, ''); // TFS 472301. PDFKit handles the CR character incorrectly (https://github.com/foliojs/pdfkit/issues/606)
              // GrapeCity end

              if (text.length === 0) {
                return;
              } // handle options


              var align = options.align || 'left';
              var wordSpacing = options.wordSpacing || 0;
              var characterSpacing = options.characterSpacing || 0; // text alignments

              if (options.width) {
                switch (align) {
                  case 'right':
                    textWidth = this.widthOfString(text.replace(/\s+$/, ''), options);
                    x += options.lineWidth - textWidth;
                    break;

                  case 'center':
                    x += options.lineWidth / 2 - options.textWidth / 2;
                    break;

                  case 'justify':
                    // calculate the word spacing value
                    words = text.trim().split(/\s+/);
                    textWidth = this.widthOfString(text.replace(/\s+/g, ''), options);
                    var spaceWidth = this.widthOfString(' ') + characterSpacing;
                    wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
                    break;
                }
              } // text baseline alignments based on http://wiki.apache.org/xmlgraphics-fop/LineLayout/AlignmentHandling


              if (typeof options.baseline === 'number') {
                dy = -options.baseline;
              } else {
                switch (options.baseline) {
                  case 'svg-middle':
                    dy = 0.5 * this._font.xHeight;
                    break;

                  case 'middle':
                  case 'svg-central':
                    dy = 0.5 * (this._font.descender + this._font.ascender);
                    break;

                  case 'bottom':
                  case 'ideographic':
                    dy = this._font.descender;
                    break;

                  case 'alphabetic':
                    dy = 0;
                    break;

                  case 'mathematical':
                    dy = 0.5 * this._font.ascender;
                    break;

                  case 'hanging':
                    dy = 0.8 * this._font.ascender;
                    break;

                  case 'top':
                    dy = this._font.ascender;
                    break;

                  default:
                    dy = this._font.ascender;
                }

                dy = dy / 1000 * this._fontSize;
              } // calculate the actual rendered width of the string after word and character spacing


              var renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1); // create link annotations if the link option is given

              if (options.link != null) {
                this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);
              }

              if (options.goTo != null) {
                this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);
              }

              if (options.destination != null) {
                this.addNamedDestination(options.destination, 'XYZ', x, y, null);
              } // create underline or strikethrough line


              if (options.underline || options.strike) {
                this.save();

                if (!options.stroke) {
                  this.strokeColor.apply(this, this._fillColor || []);
                }

                var lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
                this.lineWidth(lineWidth);
                var d = options.underline ? 1 : 2;
                var lineY = y + this.currentLineHeight() / d;

                if (options.underline) {
                  lineY -= lineWidth;
                }

                this.moveTo(x, lineY);
                this.lineTo(x + renderedWidth, lineY);
                this.stroke();
                this.restore();
              }

              this.save(); // oblique (angle in degrees or boolean)

              if (options.oblique) {
                var skew;

                if (typeof options.oblique === 'number') {
                  skew = -Math.tan(options.oblique * Math.PI / 180);
                } else {
                  skew = -0.25;
                }

                this.transform(1, 0, 0, 1, x, y);
                this.transform(1, 0, skew, 1, -skew * dy, 0);
                this.transform(1, 0, 0, 1, -x, -y);
              } // flip coordinate system


              this.transform(1, 0, 0, -1, 0, this.page.height);
              y = this.page.height - y - dy; // add current font to page if necessary

              if (this.page.fonts[this._font.id] == null) {
                this.page.fonts[this._font.id] = this._font.ref();
              } // begin the text object


              this.addContent('BT'); // text position

              this.addContent("1 0 0 1 " + number$2(x) + " " + number$2(y) + " Tm"); // font and font size

              this.addContent("/" + this._font.id + " " + number$2(this._fontSize) + " Tf"); // rendering mode

              var mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;

              if (mode) {
                this.addContent(mode + " Tr");
              } // Character spacing


              if (characterSpacing) {
                this.addContent(number$2(characterSpacing) + " Tc");
              } // Add the actual text
              // If we have a word spacing value, we need to encode each word separately
              // since the normal Tw operator only works on character code 32, which isn't
              // used for embedded fonts.


              if (wordSpacing) {
                words = text.trim().split(/\s+/);
                wordSpacing += this.widthOfString(' ') + characterSpacing;
                wordSpacing *= 1000 / this._fontSize;
                encoded = [];
                positions = [];

                for (var _iterator2 = _createForOfIteratorHelperLoose(words), _step2; !(_step2 = _iterator2()).done;) {
                  var word = _step2.value;

                  var _this$_font$encode = this._font.encode(word, options.features),
                    encodedWord = _this$_font$encode[0],
                    positionsWord = _this$_font$encode[1];

                  encoded = encoded.concat(encodedWord);
                  positions = positions.concat(positionsWord); // add the word spacing to the end of the word
                  // clone object because of cache

                  var space: any = {};
                  var object = positions[positions.length - 1];

                  for (var key in object) {
                    var val = object[key];
                    space[key] = val;
                  }

                  space.xAdvance += wordSpacing;
                  positions[positions.length - 1] = space;
                }
              } else {
                var _this$_font$encode2 = this._font.encode(text, options.features);

                encoded = _this$_font$encode2[0];
                positions = _this$_font$encode2[1];
              }

              var scale = this._fontSize / 1000;
              var commands = [];
              var last = 0;
              var hadOffset = false; // Adds a segment of text to the TJ command buffer

              var addSegment = function addSegment(cur) {
                if (last < cur) {
                  var hex = encoded.slice(last, cur).join('');
                  var advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
                  commands.push("<" + hex + "> " + number$2(-advance));
                }

                return last = cur;
              }; // Flushes the current TJ commands to the output stream


              var flush = function flush(i) {
                addSegment(i);

                if (commands.length > 0) {
                  _this3.addContent("[" + commands.join(' ') + "] TJ");

                  return commands.length = 0;
                }
              };

              for (i = 0; i < positions.length; i++) {
                // If we have an x or y offset, we have to break out of the current TJ command
                // so we can move the text position.
                var pos = positions[i];

                if (pos.xOffset || pos.yOffset) {
                  // Flush the current buffer
                  flush(i); // Move the text position and flush just the current character

                  this.addContent("1 0 0 1 " + number$2(x + pos.xOffset * scale) + " " + number$2(y + pos.yOffset * scale) + " Tm");
                  flush(i + 1);
                  hadOffset = true;
                } else {
                  // If the last character had an offset, reset the text position
                  if (hadOffset) {
                    this.addContent("1 0 0 1 " + number$2(x) + " " + number$2(y) + " Tm");
                    hadOffset = false;
                  } // Group segments that don't have any advance adjustments


                  if (pos.xAdvance - pos.advanceWidth !== 0) {
                    addSegment(i + 1);
                  }
                }

                x += pos.xAdvance * scale;
              } // Flush any remaining commands


              flush(i); // end the text object

              this.addContent('ET'); // restore flipped coordinate system

              return this.restore();
            }
          };
          var MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];
          var COLOR_SPACE_MAP = {
            1: 'DeviceGray',
            3: 'DeviceRGB',
            4: 'DeviceCMYK'
          };

          var JPEG = /*#__PURE__*/function () {
            function JPEG(data, label) {
              var marker;
              this.data = data;
              this.label = label;

              if (this.data.readUInt16BE(0) !== 0xffd8) {
                throw 'SOI not found in JPEG';
              }

              var pos = 2;

              while (pos < this.data.length) {
                marker = this.data.readUInt16BE(pos);
                pos += 2;

                if (MARKERS.indexOf(marker) !== -1) {
                  break;
                }

                pos += this.data.readUInt16BE(pos);
              }

              if (!(MARKERS.indexOf(marker) !== -1)) {
                throw 'Invalid JPEG.';
              }

              pos += 2;
              this.bits = this.data[pos++];
              this.height = this.data.readUInt16BE(pos);
              pos += 2;
              this.width = this.data.readUInt16BE(pos);
              pos += 2;
              var channels = this.data[pos++];
              this.colorSpace = COLOR_SPACE_MAP[channels];
              this.obj = null;
            }

            var _proto = JPEG.prototype;

            _proto.embed = function embed(document) {
              if (this.obj) {
                return;
              }

              this.obj = document.ref({
                Type: 'XObject',
                Subtype: 'Image',
                BitsPerComponent: this.bits,
                Width: this.width,
                Height: this.height,
                ColorSpace: this.colorSpace,
                Filter: 'DCTDecode'
              }); // add extra decode params for CMYK images. By swapping the
              // min and max values from the default, we invert the colors. See
              // section 4.8.4 of the spec.

              if (this.colorSpace === 'DeviceCMYK') {
                this.obj.data['Decode'] = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];
              }

              this.obj.end(this.data); // free memory

              return this.data = null;
            };

            return JPEG;
          }();

          var PNGImage = /*#__PURE__*/function () {
            function PNGImage(data, label) {
              this.label = label;
              this.image = new PNG(data);
              this.width = this.image.width;
              this.height = this.image.height;
              this.imgData = this.image.imgData;
              this.obj = null;
            }

            var _proto = PNGImage.prototype;

            _proto.embed = function embed(document) {
              var dataDecoded = false;
              this.document = document;

              if (this.obj) {
                return;
              }

              var hasAlphaChannel = this.image.hasAlphaChannel;
              var isInterlaced = this.image.interlaceMethod === 1;
              this.obj = this.document.ref({
                Type: 'XObject',
                Subtype: 'Image',
                BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
                Width: this.width,
                Height: this.height,
                Filter: 'FlateDecode'
              });

              if (!hasAlphaChannel) {
                var params = this.document.ref({
                  Predictor: isInterlaced ? 1 : 15,
                  Colors: this.image.colors,
                  BitsPerComponent: this.image.bits,
                  Columns: this.width
                });
                this.obj.data['DecodeParms'] = params;
                params.end();
              }

              if (this.image.palette.length === 0) {
                this.obj.data['ColorSpace'] = this.image.colorSpace;
              } else {
                // embed the color palette in the PDF as an object stream
                var palette = this.document.ref();
                palette.end(new Buffer(this.image.palette)); // build the color space array for the image

                this.obj.data['ColorSpace'] = ['Indexed', 'DeviceRGB', this.image.palette.length / 3 - 1, palette];
              } // For PNG color types 0, 2 and 3, the transparency data is stored in
              // a dedicated PNG chunk.


              if (this.image.transparency.grayscale != null) {
                // Use Color Key Masking (spec section 4.8.5)
                // An array with N elements, where N is two times the number of color components.
                var val = this.image.transparency.grayscale;
                this.obj.data['Mask'] = [val, val];
              } else if (this.image.transparency.rgb) {
                // Use Color Key Masking (spec section 4.8.5)
                // An array with N elements, where N is two times the number of color components.
                var rgb = this.image.transparency.rgb;
                var mask = [];

                for (var _iterator = _createForOfIteratorHelperLoose(rgb), _step; !(_step = _iterator()).done;) {
                  var x = _step.value;
                  mask.push(x, x);
                }

                this.obj.data['Mask'] = mask;
              } else if (this.image.transparency.indexed) {
                // Create a transparency SMask for the image based on the data
                // in the PLTE and tRNS sections. See below for details on SMasks.
                dataDecoded = true;
                return this.loadIndexedAlphaChannel();
              } else if (hasAlphaChannel) {
                // For PNG color types 4 and 6, the transparency data is stored as a alpha
                // channel mixed in with the main image data. Separate this data out into an
                // SMask object and store it separately in the PDF.
                dataDecoded = true;
                return this.splitAlphaChannel();
              }

              if (isInterlaced && !dataDecoded) {
                return this.decodeData();
              }

              this.finalize();
            };

            _proto.finalize = function finalize() {
              if (this.alphaChannel) {
                var sMask = this.document.ref({
                  Type: 'XObject',
                  Subtype: 'Image',
                  Height: this.height,
                  Width: this.width,
                  BitsPerComponent: 8,
                  Filter: 'FlateDecode',
                  ColorSpace: 'DeviceGray',
                  Decode: [0, 1]
                });
                sMask.end(this.alphaChannel);
                this.obj.data['SMask'] = sMask;
              } // add the actual image data


              this.obj.end(this.imgData); // free memory

              this.image = null;
              return this.imgData = null;
            };

            _proto.splitAlphaChannel = function splitAlphaChannel() {
              var _this = this;

              return this.image.decodePixels(function (pixels) {
                var a, p;
                var colorCount = _this.image.colors;
                var pixelCount = _this.width * _this.height;
                var imgData = new Buffer(pixelCount * colorCount);
                var alphaChannel = new Buffer(pixelCount);
                var i = p = a = 0;
                var len = pixels.length; // For 16bit images copy only most significant byte (MSB) - PNG data is always stored in network byte order (MSB first)

                var skipByteCount = _this.image.bits === 16 ? 1 : 0;

                while (i < len) {
                  for (var colorIndex = 0; colorIndex < colorCount; colorIndex++) {
                    imgData[p++] = pixels[i++];
                    i += skipByteCount;
                  }

                  alphaChannel[a++] = pixels[i++];
                  i += skipByteCount;
                }

                _this.imgData = zlib.deflateSync(imgData);
                _this.alphaChannel = zlib.deflateSync(alphaChannel);
                return _this.finalize();
              });
            };

            _proto.loadIndexedAlphaChannel = function loadIndexedAlphaChannel() {
              var _this2 = this;

              var transparency = this.image.transparency.indexed;
              return this.image.decodePixels(function (pixels) {
                var alphaChannel = new Buffer(_this2.width * _this2.height);
                var i = 0;

                for (var j = 0, end = pixels.length; j < end; j++) {
                  alphaChannel[i++] = transparency[pixels[j]];
                }

                _this2.alphaChannel = zlib.deflateSync(alphaChannel);
                return _this2.finalize();
              });
            };

            _proto.decodeData = function decodeData() {
              var _this3 = this;

              this.image.decodePixels(function (pixels) {
                _this3.imgData = zlib.deflateSync(pixels);

                _this3.finalize();
              });
            };

            return PNGImage;
          }();
          /*
          PDFImage - embeds images in PDF documents
          By Devon Govett
          */


          var PDFImage = /*#__PURE__*/function () {
            function PDFImage() { }

            (<any>PDFImage).open = function open(src, label) {
              var data;

              if (Buffer.isBuffer(src)) {
                data = src;
              } else if (src instanceof ArrayBuffer) {
                data = new Buffer(new Uint8Array(src));
              } else {
                var match;

                if (match = /^data:.+;base64,(.*)$/.exec(src)) {
                  data = new Buffer(match[1], 'base64');
                } else {
                  //data = fs.readFileSync(src);
                  if (!data) {
                    return;
                  }
                }
              }

              if (data[0] === 0xff && data[1] === 0xd8) {
                return new JPEG(data, label);
              } else if (data[0] === 0x89 && data.toString('ascii', 1, 4) === 'PNG') {
                return new PNGImage(data, label);
              } else {
                throw new Error('Unknown image format.');
              }
            };

            return PDFImage;
          }();

          var ImagesMixin = {
            initImages: function initImages() {
              this._imageRegistry = {};
              return this._imageCount = 0;
            },
            image: function image(src, x, y, options) {
              if (options === void 0) {
                options = {};
              }

              var bh, bp, bw, image, ip, left, left1;

              if (typeof x === 'object') {
                options = x;
                x = null;
              }

              x = (left = x != null ? x : options.x) != null ? left : this.x;
              y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;

              if (typeof src === 'string') {
                image = this._imageRegistry[src];
              }

              if (!image) {
                if (src.width && src.height) {
                  image = src;
                } else {
                  image = this.openImage(src);
                }
              }

              if (!image.obj) {
                image.embed(this);
              }

              if (this.page.xobjects[image.label] == null) {
                this.page.xobjects[image.label] = image.obj;
              }

              var imageWidth = image.width * 0.75; // GrapeCity, px -> pt

              var imageHeight = image.height * 0.75; // GrapeCity, px -> pt

              var w = options.width || imageWidth; // GrapeCity

              var h = options.height || imageHeight; // GrapeCity

              if (options.width && !options.height) {
                var wp = w / imageWidth; // GrapeCity

                w = imageWidth * wp; // GrapeCity

                h = imageHeight * wp; // GrapeCity
              } else if (options.height && !options.width) {
                var hp = h / imageHeight; // GrapeCity

                w = imageWidth * hp; // GrapeCity

                h = imageHeight * hp; // GrapeCity
              } else if (options.scale) {
                w = imageWidth * options.scale; // GrapeCity

                h = imageHeight * options.scale; // GrapeCity
              } else if (options.fit) {
                var _options$fit = options.fit;
                bw = _options$fit[0];
                bh = _options$fit[1];
                bp = bw / bh;
                ip = imageWidth / imageHeight; // GrapeCity

                if (ip > bp) {
                  w = bw;
                  h = bw / ip;
                } else {
                  h = bh;
                  w = bh * ip;
                }
              } else if (options.cover) {
                var _options$cover = options.cover;
                bw = _options$cover[0];
                bh = _options$cover[1];
                bp = bw / bh;
                ip = imageWidth / imageHeight; // GrapeCity

                if (ip > bp) {
                  h = bh;
                  w = bh * ip;
                } else {
                  w = bw;
                  h = bw / ip;
                }
              }

              if (options.fit || options.cover) {
                if (options.align === 'center') {
                  x = x + bw / 2 - w / 2;
                } else if (options.align === 'right') {
                  x = x + bw - w;
                }

                if (options.valign === 'center') {
                  y = y + bh / 2 - h / 2;
                } else if (options.valign === 'bottom') {
                  y = y + bh - h;
                }
              } // create link annotations if the link option is given


              if (options.link != null) {
                this.link(x, y, w, h, options.link);
              }

              if (options.goTo != null) {
                this.goTo(x, y, w, h, options.goTo);
              }

              if (options.destination != null) {
                this.addNamedDestination(options.destination, 'XYZ', x, y, null);
              } // Set the current y position to below the image if it is in the document flow


              if (this.y === y) {
                this.y += h;
              }

              this.save();
              this.transform(w, 0, 0, -h, x, y + h);
              this.addContent("/" + image.label + " Do");
              this.restore();
              return this;
            },
            openImage: function openImage(src) {
              var image;

              if (typeof src === 'string') {
                image = this._imageRegistry[src];
              }

              if (!image) {
                image = (<any>PDFImage).open(src, "I" + ++this._imageCount);

                if (typeof src === 'string') {
                  this._imageRegistry[src] = image;
                }
              }

              return image;
            }
          };
          var AnnotationsMixin = {
            annotate: function annotate(x, y, w, h, options) {
              options.Type = 'Annot';
              options.Rect = this._convertRect(x, y, w, h);
              options.Border = [0, 0, 0];

              if (options.Subtype === 'Link' && typeof options.F === 'undefined') {
                options.F = 1 << 2; // Print Annotation Flag
              }

              if (options.Subtype !== 'Link') {
                if (options.C == null) {
                  options.C = this._normalizeColor(options.color || [0, 0, 0]);
                }
              } // convert colors


              delete options.color;

              if (typeof options.Dest === 'string') {
                options.Dest = new String(options.Dest);
              } // Capitalize keys


              for (var key in options) {
                var val = options[key];
                options[key[0].toUpperCase() + key.slice(1)] = val;
              }

              var ref = this.ref(options);
              this.page.annotations.push(ref);
              ref.end();
              return this;
            },
            note: function note(x, y, w, h, contents, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Text';
              options.Contents = new String(contents);
              options.Name = 'Comment';

              if (options.color == null) {
                options.color = [243, 223, 92];
              }

              return this.annotate(x, y, w, h, options);
            },
            goTo: function goTo(x, y, w, h, name, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Link';
              options.A = this.ref({
                S: 'GoTo',
                D: new String(name)
              });
              options.A.end();
              return this.annotate(x, y, w, h, options);
            },
            link: function link(x, y, w, h, url, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Link';

              if (typeof url === 'number') {
                // Link to a page in the document (the page must already exist)
                var pages = this._root.data.Pages.data;

                if (url >= 0 && url < pages.Kids.length) {
                  options.A = this.ref({
                    S: 'GoTo',
                    D: [pages.Kids[url], 'XYZ', null, null, null]
                  });
                  options.A.end();
                } else {
                  throw new Error("The document has no page " + url);
                }
              } else {
                // Link to an external url
                options.A = this.ref({
                  S: 'URI',
                  URI: new String(url)
                });
                options.A.end();
              }

              return this.annotate(x, y, w, h, options);
            },
            _markup: function _markup(x, y, w, h, options) {
              if (options === void 0) {
                options = {};
              }

              var _this$_convertRect = this._convertRect(x, y, w, h),
                x1 = _this$_convertRect[0],
                y1 = _this$_convertRect[1],
                x2 = _this$_convertRect[2],
                y2 = _this$_convertRect[3];

              options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];
              options.Contents = new String();
              return this.annotate(x, y, w, h, options);
            },
            highlight: function highlight(x, y, w, h, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Highlight';

              if (options.color == null) {
                options.color = [241, 238, 148];
              }

              return this._markup(x, y, w, h, options);
            },
            underline: function underline(x, y, w, h, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Underline';
              return this._markup(x, y, w, h, options);
            },
            strike: function strike(x, y, w, h, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'StrikeOut';
              return this._markup(x, y, w, h, options);
            },
            lineAnnotation: function lineAnnotation(x1, y1, x2, y2, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Line';
              options.Contents = new String();
              options.L = [x1, this.page.height - y1, x2, this.page.height - y2];
              return this.annotate(x1, y1, x2, y2, options);
            },
            rectAnnotation: function rectAnnotation(x, y, w, h, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Square';
              options.Contents = new String();
              return this.annotate(x, y, w, h, options);
            },
            ellipseAnnotation: function ellipseAnnotation(x, y, w, h, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'Circle';
              options.Contents = new String();
              return this.annotate(x, y, w, h, options);
            },
            textAnnotation: function textAnnotation(x, y, w, h, text, options) {
              if (options === void 0) {
                options = {};
              }

              options.Subtype = 'FreeText';
              options.Contents = new String(text);
              options.DA = new String();
              return this.annotate(x, y, w, h, options);
            },
            _convertRect: function _convertRect(x1, y1, w, h) {
              // flip y1 and y2
              var y2 = y1;
              y1 += h; // make x2

              var x2 = x1 + w; // apply current transformation matrix to points

              var _this$_ctm = this._ctm,
                m0 = _this$_ctm[0],
                m1 = _this$_ctm[1],
                m2 = _this$_ctm[2],
                m3 = _this$_ctm[3],
                m4 = _this$_ctm[4],
                m5 = _this$_ctm[5];
              x1 = m0 * x1 + m2 * y1 + m4;
              y1 = m1 * x1 + m3 * y1 + m5;
              x2 = m0 * x2 + m2 * y2 + m4;
              y2 = m1 * x2 + m3 * y2 + m5;
              return [x1, y1, x2, y2];
            }
          };

          var PDFOutline = /*#__PURE__*/function () {
            function PDFOutline(document, parent, title, dest, options?): void {
              if (options === void 0) {
                options = {
                  expanded: false
                };
              }

              this.document = document;
              this.options = options;
              this.outlineData = {};

              if (dest !== null) {
                this.outlineData['Dest'] = [dest.dictionary, 'Fit'];
              }

              if (parent !== null) {
                this.outlineData['Parent'] = parent;
              }

              if (title !== null) {
                this.outlineData['Title'] = new String(title);
              }

              this.dictionary = this.document.ref(this.outlineData);
              this.children = [];
            }

            var _proto = PDFOutline.prototype;

            _proto.addItem = function addItem(title, options) {
              if (options === void 0) {
                options = {
                  expanded: false
                };
              }

              var result = new PDFOutline(this.document, this.dictionary, title, this.document.page, options);
              this.children.push(result);
              return result;
            };

            _proto.endOutline = function endOutline() {
              if (this.children.length > 0) {
                if (this.options.expanded) {
                  this.outlineData.Count = this.children.length;
                }

                var first = this.children[0],
                  last = this.children[this.children.length - 1];
                this.outlineData.First = first.dictionary;
                this.outlineData.Last = last.dictionary;

                for (var i = 0, len = this.children.length; i < len; i++) {
                  var child = this.children[i];

                  if (i > 0) {
                    child.outlineData.Prev = this.children[i - 1].dictionary;
                  }

                  if (i < this.children.length - 1) {
                    child.outlineData.Next = this.children[i + 1].dictionary;
                  }

                  child.endOutline();
                }
              }

              return this.dictionary.end();
            };

            return PDFOutline;
          }();

          var OutlineMixin = {
            initOutline: function initOutline() {
              return this.outline = new PDFOutline(this, null, null, null);
            },
            endOutline: function endOutline() {
              this.outline.endOutline();

              if (this.outline.children.length > 0) {
                this._root.data.Outlines = this.outline.dictionary;
                return this._root.data.PageMode = 'UseOutlines';
              }
            }
          };

          var PDFDocument = /*#__PURE__*/function (_stream$Readable) {
            _inheritsLoose(PDFDocument, _stream$Readable);

            function PDFDocument(options) {
              var _this;

              if (options === void 0) {
                options = {};
              }

              _this = _stream$Readable.call(this, options) || this;
              _this.options = options; // PDF version

              switch (options.pdfVersion) {
                case '1.4':
                  _this.version = 1.4;
                  break;

                case '1.5':
                  _this.version = 1.5;
                  break;

                case '1.6':
                  _this.version = 1.6;
                  break;

                case '1.7':
                case '1.7ext3':
                  _this.version = 1.7;
                  break;

                default:
                  _this.version = 1.3;
                  break;
              } // Whether streams should be compressed


              _this.compress = _this.options.compress != null ? _this.options.compress : true;
              _this._pageBuffer = [];
              _this._pageBufferStart = 0; // The PDF object store

              _this._offsets = [];
              _this._waiting = 0;
              _this._ended = false;
              _this._offset = 0;

              var Pages = _this.ref({
                Type: 'Pages',
                Count: 0,
                Kids: []
              });

              var Names = _this.ref({
                Dests: new PDFNameTree()
              });

              _this._root = _this.ref({
                Type: 'Catalog',
                Pages: Pages,
                Names: Names
              }); // The current page

              _this.page = null; // Initialize mixins

              _this.initColor();

              _this.initVector();

              _this.initFonts(options.font);

              _this.initText();

              _this.initImages();

              _this.initOutline(); // Initialize the metadata


              _this.info = {
                Producer: 'PDFKit',
                Creator: 'PDFKit',
                CreationDate: new Date()
              };

              if (_this.options.info) {
                for (var key in _this.options.info) {
                  var val = _this.options.info[key];
                  _this.info[key] = val;
                }
              } // GrapeCity begin: custom security module


              var PDFSecurity = options.security; // Generate file ID

              _this._id = PDFSecurity && PDFSecurity.generateFileID(_this.info); // Initialize security settings

              _this._security = PDFSecurity && PDFSecurity.create(_assertThisInitialized(_this), options); // // Generate file ID
              // this._id = PDFSecurity.generateFileID(this.info);
              // // Initialize security settings
              // this._security = PDFSecurity.create(this, options);
              // GrapeCity end
              // Write the header
              // PDF version

              _this._write("%PDF-" + _this.version); // 4 binary chars, as recommended by the spec


              _this._write('%\xFF\xFF\xFF\xFF'); // #GrapeCity begin


              if (_this.options.pageAdding) {
                _this.on('pageAdding', _this.options.pageAdding);
              }

              if (_this.options.pageAdded) {
                _this.on('pageAdded', _this.options.pageAdded);
              } // #GrapeCity end
              // Add the first page


              if (_this.options.autoFirstPage !== false) {
                _this.addPage();
              }

              return _this;
            }

            var _proto = PDFDocument.prototype;

            _proto.addPage = function addPage(options) {
              // end the current page if needed
              if (options == null) {
                options = this.options;
              } //GrapeCity begin


              this.emit('pageAdding', this, options); //GrapeCity end

              if (!this.options.bufferPages) {
                this.flushPages();
              } // create a page object


              this.page = new PDFPage(this, options);

              this._pageBuffer.push(this.page); // add the page to the object store


              var pages = this._root.data.Pages.data;
              pages.Kids.push(this.page.dictionary);
              pages.Count++; // reset x and y coordinates

              this.x = this.page.margins.left;
              this.y = this.page.margins.top; // flip PDF coordinate system so that the origin is in
              // the top left rather than the bottom left

              this._ctm = [1, 0, 0, 1, 0, 0];
              this.transform(1, 0, 0, -1, 0, this.page.height); //GrapeCity begin
              //this.emit('pageAdded');

              this.emit('pageAdded', this); //GrapeCity end

              return this;
            };

            _proto.bufferedPageRange = function bufferedPageRange() {
              return {
                start: this._pageBufferStart,
                count: this._pageBuffer.length
              };
            };

            _proto.switchToPage = function switchToPage(n) {
              var page;

              if (!(page = this._pageBuffer[n - this._pageBufferStart])) {
                throw new Error("switchToPage(" + n + ") out of bounds, current buffer covers pages " + this._pageBufferStart + " to " + (this._pageBufferStart + this._pageBuffer.length - 1));
              }

              return this.page = page;
            };

            _proto.flushPages = function flushPages() {
              // this local variable exists so we're future-proof against
              // reentrant calls to flushPages.
              var pages = this._pageBuffer;
              this._pageBuffer = [];
              this._pageBufferStart += pages.length;

              for (var _iterator = _createForOfIteratorHelperLoose(pages), _step; !(_step = _iterator()).done;) {
                var page = _step.value;
                page.end();
              }
            };

            _proto.addNamedDestination = function addNamedDestination(name) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }

              if (args.length === 0) {
                args = ['XYZ', null, null, null];
              }

              if (args[0] === 'XYZ' && args[2] !== null) {
                args[2] = this.page.height - args[2];
              }

              args.unshift(this.page.dictionary);

              this._root.data.Names.data.Dests.add(name, args);
            };

            _proto.addNamedJavaScript = function addNamedJavaScript(name, js) {
              if (!this._root.data.Names.data.JavaScript) {
                this._root.data.Names.data.JavaScript = new PDFNameTree();
              }

              var data = {
                JS: new String(js),
                S: 'JavaScript'
              };

              this._root.data.Names.data.JavaScript.add(name, data);
            };

            _proto.ref = function ref(data) {
              var ref = new PDFReference(this, this._offsets.length + 1, data);

              this._offsets.push(null); // placeholder for this object's offset once it is finalized


              this._waiting++;
              return ref;
            };

            _proto._read = function _read() { } // do nothing, but this method is required by node
              ;

            _proto._write = function _write(data) {
              if (!Buffer.isBuffer(data)) {
                data = new Buffer(data + '\n', 'binary');
              }

              this.push(data);
              return this._offset += data.length;
            };

            _proto.addContent = function addContent(data) {
              this.page.write(data);
              return this;
            };

            _proto._refEnd = function _refEnd(ref) {
              this._offsets[ref.id - 1] = ref.offset;

              if (--this._waiting === 0 && this._ended) {
                this._finalize();

                return this._ended = false;
              }
            } //   write(filename, fn) {
              //     // print a deprecation warning with a stacktrace
              //     const err = new Error(`\
              // PDFDocument#write is deprecated, and will be removed in a future version of PDFKit. \
              // Please pipe the document into a Node stream.\
              // `);
              //     console.warn(err.stack);
              //     this.pipe(fs.createWriteStream(filename));
              //     this.end();
              //     return this.once('end', fn);
              //   }
              ;

            _proto.end = function end() {
              //GrapeCity begin
              this.emit('ending'); //GrapeCity end

              this.flushPages();
              this._info = this.ref();

              for (var key in this.info) {
                var val = this.info[key];

                if (typeof val === 'string') {
                  val = new String(val);
                }

                var entry = this.ref(val);
                entry.end();
                this._info.data[key] = entry;
              }

              this._info.end();

              for (var name in this._fontFamilies) {
                var font = this._fontFamilies[name];
                font.finalize();
              }

              this.endOutline();

              this._root.end();

              this._root.data.Pages.end();

              this._root.data.Names.end(); //this.endAcroForm(); // GrapeCity: no acroform


              if (this._security) {
                this._security.end();
              }

              if (this._waiting === 0) {
                return this._finalize();
              } else {
                return this._ended = true;
              }
            };

            _proto._finalize = function _finalize(fn) {
              // generate xref
              var xRefOffset = this._offset;

              this._write('xref');

              this._write("0 " + (this._offsets.length + 1));

              this._write('0000000000 65535 f ');

              for (var _iterator2 = _createForOfIteratorHelperLoose(this._offsets), _step2; !(_step2 = _iterator2()).done;) {
                var offset = _step2.value;
                offset = ("0000000000" + offset).slice(-10);

                this._write(offset + ' 00000 n ');
              } // trailer


              var trailer: any = {
                Size: this._offsets.length + 1,
                Root: this._root,
                Info: this._info // ID: [this._id, this._id] // GrapeCity

              }; // GrapeCity begin: _this.id can be undefined because security module is optional.

              if (this._id) {
                trailer.ID = [this._id, this._id];
              } // GrapeCity end


              if (this._security) {
                trailer.Encrypt = this._security.dictionary;
              }

              this._write('trailer');

              this._write((<any>PDFObject).convert(trailer));

              this._write('startxref');

              this._write("" + xRefOffset);

              this._write('%%EOF'); // end the stream


              return this.push(null);
            };

            _proto.toString = function toString() {
              return '[object PDFDocument]';
            };

            return PDFDocument;
          }(stream.Readable);

          var mixin = function mixin(methods) {
            _Object$assign(PDFDocument.prototype, methods);
          };

          mixin(ColorMixin);
          mixin(VectorMixin);
          mixin(FontsMixin);
          mixin(TextMixin);
          mixin(ImagesMixin);
          mixin(AnnotationsMixin);
          mixin(OutlineMixin); //mixin(AcroFormMixin); // GrapeCity: no acroform

          (<any>PDFDocument).LineWrapper = LineWrapper;
          localModule.localExports = PDFDocument;
        }).call(this);
      }).call(this, localRequire("buffer").Buffer);
    }, {
      "@babel/runtime-corejs2/core-js/array/is-array": 136,
      "@babel/runtime-corejs2/core-js/json/stringify": 137,
      "@babel/runtime-corejs2/core-js/number/is-finite": 138,
      "@babel/runtime-corejs2/core-js/object/assign": 139,
      "@babel/runtime-corejs2/core-js/object/create": 140,
      "@babel/runtime-corejs2/core-js/object/keys": 141,
      "@babel/runtime-corejs2/core-js/parse-int": 142,
      "buffer": 152,
      "events": 210,
      "fontkit": 1,
      "linebreak": 133,
      "png-js": 227,
      "stream": 244,
      "zlib": 150
    }],
    136: [function (localRequire, localModule, localExports) {
      arguments[4][3][0].apply(localExports, arguments);
    }, {
      "core-js/library/fn/array/is-array": 153,
      "dup": 3
    }],
    137: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/json/stringify");
    }, {
      "core-js/library/fn/json/stringify": 154
    }],
    138: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/number/is-finite");
    }, {
      "core-js/library/fn/number/is-finite": 155
    }],
    139: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/object/assign");
    }, {
      "core-js/library/fn/object/assign": 156
    }],
    140: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/object/create");
    }, {
      "core-js/library/fn/object/create": 157
    }],
    141: [function (localRequire, localModule, localExports) {
      arguments[4][8][0].apply(localExports, arguments);
    }, {
      "core-js/library/fn/object/keys": 158,
      "dup": 8
    }],
    142: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire("core-js/library/fn/parse-int");
    }, {
      "core-js/library/fn/parse-int": 159
    }],
    143: [function (localRequire, localModule, localExports) {
      (function (global) {
        (function () {

          var objectAssign = localRequire('object-assign'); // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
          // original notice:

          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */

          function compare(a, b) {
            if (a === b) {
              return 0;
            }

            var x = a.length;
            var y = b.length;

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }

            if (x < y) {
              return -1;
            }

            if (y < x) {
              return 1;
            }

            return 0;
          }

          function isBuffer(b) {
            if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
              return global.Buffer.isBuffer(b);
            }

            return !!(b != null && b._isBuffer);
          } // based on node assert, original notice:
          // NB: The URL to the CommonJS spec is kept just for tradition.
          //     node-assert has evolved a lot since then, both in API and behavior.
          // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
          //
          // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
          //
          // Originally from narwhal.js (http://narwhaljs.org)
          // Copyright (c) 2009 Thomas Robinson <280north.com>
          //
          // Permission is hereby granted, free of charge, to any person obtaining a copy
          // of this software and associated documentation files (the 'Software'), to
          // deal in the Software without restriction, including without limitation the
          // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          // sell copies of the Software, and to permit persons to whom the Software is
          // furnished to do so, subject to the following conditions:
          //
          // The above copyright notice and this permission notice shall be included in
          // all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
          // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
          // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


          var util = localRequire('util/');
          var hasOwn = Object.prototype.hasOwnProperty;
          var pSlice = Array.prototype.slice;

          var functionsHaveNames = function () {
            //@ts-ignore
            return function foo() { }.name === 'foo';
          }();

          function pToString(obj) {
            return Object.prototype.toString.call(obj);
          }

          function isView(arrbuf) {
            if (isBuffer(arrbuf)) {
              return false;
            }

            if (typeof global.ArrayBuffer !== 'function') {
              return false;
            }

            if (typeof ArrayBuffer.isView === 'function') {
              return ArrayBuffer.isView(arrbuf);
            }

            if (!arrbuf) {
              return false;
            }

            if (arrbuf instanceof DataView) {
              return true;
            }

            if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
              return true;
            }

            return false;
          } // 1. The assert module provides functions that throw
          // AssertionError's when particular conditions are not met. The
          // assert module must conform to the following interface.


          var assert: any = localModule.localExports = ok; // 2. The AssertionError is defined in assert.
          // new assert.AssertionError({ message: message,
          //                             actual: actual,
          //                             expected: expected })

          var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

          function getName(func) {
            if (!util.isFunction(func)) {
              return;
            }

            if (functionsHaveNames) {
              return func.name;
            }

            var str = func.toString();
            var match = str.match(regex);
            return match && match[1];
          }

          assert.AssertionError = function AssertionError(options) {
            this.name = 'AssertionError';
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;

            if (options.message) {
              this.message = options.message;
              this.generatedMessage = false;
            } else {
              this.message = getMessage(this);
              this.generatedMessage = true;
            }

            var stackStartFunction = options.stackStartFunction || fail;

            if ((<any>Error).captureStackTrace) {
              (<any>Error).captureStackTrace(this, stackStartFunction);
            } else {
              // non v8 browsers so we can have a stacktrace
              var err = new Error();

              if (err.stack) {
                var out = err.stack; // try to strip useless frames

                var fn_name = getName(stackStartFunction);
                var idx = out.indexOf('\n' + fn_name);

                if (idx >= 0) {
                  // once we have located the function frame
                  // we need to strip out everything before it (and its line)
                  var next_line = out.indexOf('\n', idx + 1);
                  out = out.substring(next_line + 1);
                }

                this.stack = out;
              }
            }
          }; // assert.AssertionError instanceof Error


          util.inherits(assert.AssertionError, Error);

          function truncate(s, n) {
            if (typeof s === 'string') {
              return s.length < n ? s : s.slice(0, n);
            } else {
              return s;
            }
          }

          function inspect(something) {
            if (functionsHaveNames || !util.isFunction(something)) {
              return util.inspect(something);
            }

            var rawname = getName(something);
            var name = rawname ? ': ' + rawname : '';
            return '[Function' + name + ']';
          }

          function getMessage(self) {
            return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
          } // At present only the three keys mentioned above are used and
          // understood by the spec. Implementations or sub modules can pass
          // other keys to the AssertionError's constructor - they will be
          // ignored.
          // 3. All of the following functions must throw an AssertionError
          // when a corresponding condition is not met, with a message that
          // may be undefined if not provided.  All assertion methods provide
          // both the actual and expected values to the assertion error for
          // display purposes.


          function fail(actual, expected, message, operator?, stackStartFunction?) {
            throw new assert.AssertionError({
              message: message,
              actual: actual,
              expected: expected,
              operator: operator,
              stackStartFunction: stackStartFunction
            });
          } // EXTENSION! allows for well behaved errors defined elsewhere.


          assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
          // by !!guard.
          // assert.ok(guard, message_opt);
          // This statement is equivalent to assert.equal(true, !!guard,
          // message_opt);. To test strictly for the value true, use
          // assert.strictEqual(true, guard, message_opt);.

          function ok(value, message) {
            if (!value) fail(value, true, message, '==', assert.ok);
          }

          assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with
          // ==.
          // assert.equal(actual, expected, message_opt);

          assert.equal = function equal(actual, expected, message) {
            if (actual != expected) fail(actual, expected, message, '==', assert.equal);
          }; // 6. The non-equality assertion tests for whether two objects are not equal
          // with != assert.notEqual(actual, expected, message_opt);


          assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
              fail(actual, expected, message, '!=', assert.notEqual);
            }
          }; // 7. The equivalence assertion tests a deep equality relation.
          // assert.deepEqual(actual, expected, message_opt);


          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, 'deepEqual', assert.deepEqual);
            }
          };

          assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
            }
          };

          function _deepEqual(actual, expected, strict, memos?) {
            // 7.1. All identical values are equivalent, as determined by ===.
            if (actual === expected) {
              return true;
            } else if (isBuffer(actual) && isBuffer(expected)) {
              return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
              // equivalent if it is also a Date object that refers to the same time.
            } else if (util.isDate(actual) && util.isDate(expected)) {
              return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
              // equivalent if it is also a RegExp object with the same source and
              // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
            } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
              return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
              // equivalence is determined by ==.
            } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
              return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
              // ArrayBuffers in a Buffer each to increase performance
              // This optimization requires the arrays to have the same type as checked by
              // Object.prototype.toString (aka pToString). Never perform binary
              // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
              // bit patterns are not identical.
            } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
              return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
              // determined by having the same number of owned properties (as verified
              // with Object.prototype.hasOwnProperty.call), the same set of keys
              // (although not necessarily the same order), equivalent values for every
              // corresponding key, and an identical 'prototype' property. Note: this
              // accounts for both named and indexed properties on Arrays.
            } else if (isBuffer(actual) !== isBuffer(expected)) {
              return false;
            } else {
              memos = memos || {
                actual: [],
                expected: []
              };
              var actualIndex = memos.actual.indexOf(actual);

              if (actualIndex !== -1) {
                if (actualIndex === memos.expected.indexOf(expected)) {
                  return true;
                }
              }

              memos.actual.push(actual);
              memos.expected.push(expected);
              return objEquiv(actual, expected, strict, memos);
            }
          }

          function isArguments(object) {
            return Object.prototype.toString.call(object) == '[object Arguments]';
          }

          function objEquiv(a, b, strict, actualVisitedObjects) {
            if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

            if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
            if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
            var aIsArgs = isArguments(a);
            var bIsArgs = isArguments(b);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

            if (aIsArgs) {
              a = pSlice.call(a);
              b = pSlice.call(b);
              return _deepEqual(a, b, strict);
            }

            var ka = objectKeys(a);
            var kb = objectKeys(b);
            var key, i; // having the same number of owned properties (keys incorporates
            // hasOwnProperty)

            if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

            ka.sort();
            kb.sort(); //~~~cheap key test

            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] !== kb[i]) return false;
            } //equivalent values for every corresponding key, and
            //~~~possibly expensive deep test


            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
            }

            return true;
          } // 8. The non-equivalence assertion tests for any deep inequality.
          // assert.notDeepEqual(actual, expected, message_opt);


          assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
            }
          };

          assert.notDeepStrictEqual = notDeepStrictEqual;

          function notDeepStrictEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
            }
          } // 9. The strict equality assertion tests strict equality, as determined by ===.
          // assert.strictEqual(actual, expected, message_opt);


          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
              fail(actual, expected, message, '===', assert.strictEqual);
            }
          }; // 10. The strict non-equality assertion tests for strict inequality, as
          // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);


          assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
              fail(actual, expected, message, '!==', assert.notStrictEqual);
            }
          };

          function expectedException(actual, expected) {
            if (!actual || !expected) {
              return false;
            }

            if (Object.prototype.toString.call(expected) == '[object RegExp]') {
              return expected.test(actual);
            }

            try {
              if (actual instanceof expected) {
                return true;
              }
            } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
            }

            if (Error.isPrototypeOf(expected)) {
              return false;
            }

            return expected.call({}, actual) === true;
          }

          function _tryBlock(block) {
            var error;

            try {
              block();
            } catch (e) {
              error = e;
            }

            return error;
          }

          function _throws(shouldThrow, block, expected, message) {
            var actual;

            if (typeof block !== 'function') {
              throw new TypeError('"block" argument must be a function');
            }

            if (typeof expected === 'string') {
              message = expected;
              expected = null;
            }

            actual = _tryBlock(block);
            message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

            if (shouldThrow && !actual) {
              fail(actual, expected, 'Missing expected exception' + message);
            }

            var userProvidedMessage = typeof message === 'string';
            var isUnwantedException = !shouldThrow && util.isError(actual);
            var isUnexpectedException = !shouldThrow && actual && !expected;

            if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
              fail(actual, expected, 'Got unwanted exception' + message);
            }

            if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
              throw actual;
            }
          } // 11. Expected to throw an error:
          // assert.throws(block, Error_opt, message_opt);


          assert.throws = function (block,
            /*optional*/
            error,
            /*optional*/
            message) {
            _throws(true, block, error, message);
          }; // EXTENSION! This is annoying to write outside this module.


          assert.doesNotThrow = function (block,
            /*optional*/
            error,
            /*optional*/
            message) {
            _throws(false, block, error, message);
          };

          assert.ifError = function (err) {
            if (err) throw err;
          }; // Expose a strict only variant of assert


          function strict(value, message) {
            if (!value) fail(value, true, message, '==', strict);
          }

          assert.strict = objectAssign(strict, assert, {
            equal: assert.strictEqual,
            deepEqual: assert.deepStrictEqual,
            notEqual: assert.notStrictEqual,
            notDeepEqual: assert.notDeepStrictEqual
          });
          assert.strict.strict = assert.strict;

          var objectKeys = Object.keys || function (obj) {
            var keys = [];

            for (var key in obj) {
              if (hasOwn.call(obj, key)) keys.push(key);
            }

            return keys;
          };
        }).call(this);
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "object-assign": 215,
      "util/": 146
    }],
    144: [function (localRequire, localModule, localExports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        localModule.localExports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        // old school shim for old browsers
        localModule.localExports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;

          var TempCtor = function TempCtor() { };

          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
    }, {}],
    145: [function (localRequire, localModule, localExports) {
      localModule.localExports = function isBuffer(arg) {
        return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
      };
    }, {}],
    146: [function (localRequire, localModule, localExports) {
      (function (process, global) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          var formatRegExp = /%[sdj%]/g;

          localExports.format = function (f) {
            if (!isString(f)) {
              var objects = [];

              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }

              return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, <any>function (x) {
              if (x === '%%') return '%';
              if (i >= len) return x;

              switch (x) {
                case '%s':
                  return String(args[i++]);

                case '%d':
                  return Number(args[i++]);

                case '%j':
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return '[Circular]';
                  }

                default:
                  return x;
              }
            });

            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }

            return str;
          }; // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.


          localExports.deprecate = function (fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
              return function () {
                return localExports.deprecate(fn, msg).apply(this, arguments);
              };
            }

            if (process.noDeprecation === true) {
              return fn;
            }

            var warned = false;

            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }

                warned = true;
              }

              return fn.apply(this, arguments);
            }

            return deprecated;
          };

          var debugs = {};
          var debugEnviron;

          localExports.debuglog = function (set) {
            if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
            set = set.toUpperCase();

            if (!debugs[set]) {
              if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                var pid = process.pid;

                debugs[set] = function () {
                  var msg = localExports.format.apply(localExports, arguments);
                  console.error('%s %d: %s', set, pid, msg);
                };
              } else {
                debugs[set] = function () { };
              }
            }

            return debugs[set];
          };
          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Object} opts Optional options object that alters the output.
           */

          /* legacy: obj, showHidden, depth, colors*/


          function inspect(obj, opts?) {
            // default options
            var ctx: any = {
              seen: [],
              stylize: stylizeNoColor
            }; // legacy...

            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];

            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts;
            } else if (opts) {
              // got an "options" object
              localExports._extend(ctx, opts);
            } // set default options


            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }

          localExports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

          (<any>inspect).colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39]
          }; // Don't use 'blue' not visible on cmd.exe

          (<any>inspect).styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
          };

          function stylizeWithColor(str, styleType) {
            var style = (<any>inspect).styles[styleType];

            if (style) {
              return "\x1B[" + (<any>inspect).colors[style][0] + 'm' + str + "\x1B[" + (<any>inspect).colors[style][1] + 'm';
            } else {
              return str;
            }
          }

          function stylizeNoColor(str, styleType) {
            return str;
          }

          function arrayToHash(array) {
            var hash = {};
            array.forEach(function (val, idx) {
              hash[val] = true;
            });
            return hash;
          }

          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
              value.inspect !== localExports.inspect && // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);

              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }

              return ret;
            } // Primitive types cannot have properties


            var primitive = formatPrimitive(ctx, value);

            if (primitive) {
              return primitive;
            } // Look up the keys of the object.


            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            } // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
              return formatError(value);
            } // Some type of object without properties can be shortcutted.


            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }

              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }

              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }

              if (isError(value)) {
                return formatError(value);
              }
            }

            var base = '',
              array = false,
              braces = ['{', '}']; // Make Array say that they are Array

            if (isArray(value)) {
              array = true;
              braces = ['[', ']'];
            } // Make functions say that they are functions


            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            } // Make RegExps say that they are RegExps


            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            } // Make dates with properties first say the date


            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            } // Make error with message first say the error


            if (isError(value)) {
              base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }

            ctx.seen.push(value);
            var output;

            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function (key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }

            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }

          function formatPrimitive(ctx, value) {
            if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

            if (isString(value)) {
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');
            }

            if (isNumber(value)) return ctx.stylize('' + value, 'number');
            if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

            if (isNull(value)) return ctx.stylize('null', 'null');
          }

          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }

          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];

            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push('');
              }
            }

            keys.forEach(function (key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }

          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key]
            };

            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }

            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }

            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }

                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function (line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function (line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }

            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }

              name = JSON.stringify('' + key);

              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
              }
            }

            return name + ': ' + str;
          }

          function reduceToSingleString(output, base, braces) {
            var length = output.reduce(function (prev, cur) {
              //if (cur.indexOf('\n') >= 0);
              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          } // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.


          function isArray(ar) {
            return Array.isArray(ar);
          }

          localExports.isArray = isArray;

          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }

          localExports.isBoolean = isBoolean;

          function isNull(arg) {
            return arg === null;
          }

          localExports.isNull = isNull;

          function isNullOrUndefined(arg) {
            return arg == null;
          }

          localExports.isNullOrUndefined = isNullOrUndefined;

          function isNumber(arg) {
            return typeof arg === 'number';
          }

          localExports.isNumber = isNumber;

          function isString(arg) {
            return typeof arg === 'string';
          }

          localExports.isString = isString;

          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }

          localExports.isSymbol = isSymbol;

          function isUndefined(arg) {
            return arg === void 0;
          }

          localExports.isUndefined = isUndefined;

          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }

          localExports.isRegExp = isRegExp;

          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }

          localExports.isObject = isObject;

          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }

          localExports.isDate = isDate;

          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }

          localExports.isError = isError;

          function isFunction(arg) {
            return typeof arg === 'function';
          }

          localExports.isFunction = isFunction;

          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
              typeof arg === 'undefined';
          }

          localExports.isPrimitive = isPrimitive;
          localExports.isBuffer = localRequire('./support/isBuffer');

          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }

          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }

          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

          function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
          } // log is just a thin wrapper to console.log that prepends a timestamp


          localExports.log = function () {
            console.log('%s - %s', timestamp(), localExports.format.apply(localExports, arguments));
          };
          /**
           * Inherit the prototype methods from one constructor into another.
           *
           * The Function.prototype.inherits from lang.js rewritten as a standalone
           * function (not on Function.prototype). NOTE: If this file is to be loaded
           * during bootstrapping this function needs to be rewritten using some native
           * functions as prototype setup using normal JavaScript does not work as
           * expected during bootstrapping (see mirror.js in r114903).
           *
           * @param {function} ctor Constructor function which needs to inherit the
           *     prototype.
           * @param {function} superCtor Constructor function to inherit prototype from.
           */


          localExports.inherits = localRequire('inherits');

          localExports._extend = function (origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;
            var keys = Object.keys(add);
            var i = keys.length;

            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }

            return origin;
          };

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
        }).call(this);
      }).call(this, localRequire('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./support/isBuffer": 145,
      "_process": 229,
      "inherits": 144
    }],
    147: [function (localRequire, localModule, localExports) {
      arguments[4][122][0].apply(localExports, arguments);
    }, {
      "dup": 122
    }],
    148: [function (localRequire, localModule, localExports) {
      arguments[4][108][0].apply(localExports, arguments);
    }, {
      "dup": 108
    }],
    149: [function (localRequire, localModule, localExports) {
      (function (process, Buffer) {
        (function () {
          var msg = localRequire('pako/lib/zlib/messages');
          var zstream = localRequire('pako/lib/zlib/zstream');
          var zlib_deflate = localRequire('pako/lib/zlib/deflate.js');
          var zlib_inflate = localRequire('pako/lib/zlib/inflate.js');
          var constants = localRequire('pako/lib/zlib/constants');

          for (var key in constants) {
            localExports[key] = constants[key];
          } // zlib modes


          localExports.NONE = 0;
          localExports.DEFLATE = 1;
          localExports.INFLATE = 2;
          localExports.GZIP = 3;
          localExports.GUNZIP = 4;
          localExports.DEFLATERAW = 5;
          localExports.INFLATERAW = 6;
          localExports.UNZIP = 7;
          /**
           * Emulate Node's zlib C++ layer for use by the JS layer in index.js
           */

          function Zlib(mode) {
            if (mode < localExports.DEFLATE || mode > localExports.UNZIP) throw new TypeError("Bad argument");
            this.mode = mode;
            this.init_done = false;
            this.write_in_progress = false;
            this.pending_close = false;
            this.windowBits = 0;
            this.level = 0;
            this.memLevel = 0;
            this.strategy = 0;
            this.dictionary = null;
          }

          Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
            this.windowBits = windowBits;
            this.level = level;
            this.memLevel = memLevel;
            this.strategy = strategy; // dictionary not supported.

            if (this.mode === localExports.GZIP || this.mode === localExports.GUNZIP) this.windowBits += 16;
            if (this.mode === localExports.UNZIP) this.windowBits += 32;
            if (this.mode === localExports.DEFLATERAW || this.mode === localExports.INFLATERAW) this.windowBits = -this.windowBits;
            this.strm = new zstream();

            switch (this.mode) {
              case localExports.DEFLATE:
              case localExports.GZIP:
              case localExports.DEFLATERAW:
                var status = zlib_deflate.deflateInit2(this.strm, this.level, localExports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;

              case localExports.INFLATE:
              case localExports.GUNZIP:
              case localExports.INFLATERAW:
              case localExports.UNZIP:
                var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                break;

              default:
                throw new Error("Unknown mode " + this.mode);
            }

            if (status !== localExports.Z_OK) {
              this._error(status);

              return;
            }

            this.write_in_progress = false;
            this.init_done = true;
          };

          Zlib.prototype.params = function () {
            throw new Error("deflateParams Not supported");
          };

          Zlib.prototype._writeCheck = function () {
            if (!this.init_done) throw new Error("write before init");
            if (this.mode === localExports.NONE) throw new Error("already finalized");
            if (this.write_in_progress) throw new Error("write already in progress");
            if (this.pending_close) throw new Error("close is pending");
          };

          Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
            this._writeCheck();

            this.write_in_progress = true;
            var self = this;
            process.nextTick(function () {
              self.write_in_progress = false;

              var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);

              self.callback(res[0], res[1]);
              if (self.pending_close) self.close();
            });
            return this;
          }; // set method for Node buffers, used by pako


          function bufferSet(data, offset) {
            for (var i = 0; i < data.length; i++) {
              this[offset + i] = data[i];
            }
          }

          Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
            this._writeCheck();

            return this._write(flush, input, in_off, in_len, out, out_off, out_len);
          };

          Zlib.prototype._write = function (flush, input, in_off, in_len, out, out_off, out_len) {
            this.write_in_progress = true;

            if (flush !== localExports.Z_NO_FLUSH && flush !== localExports.Z_PARTIAL_FLUSH && flush !== localExports.Z_SYNC_FLUSH && flush !== localExports.Z_FULL_FLUSH && flush !== localExports.Z_FINISH && flush !== localExports.Z_BLOCK) {
              throw new Error("Invalid flush value");
            }

            if (input == null) {
              input = new Buffer(0);
              in_len = 0;
              in_off = 0;
            }

            if (out._set) out.set = out._set; else out.set = bufferSet;
            var strm = this.strm;
            strm.avail_in = in_len;
            strm.input = input;
            strm.next_in = in_off;
            strm.avail_out = out_len;
            strm.output = out;
            strm.next_out = out_off;

            switch (this.mode) {
              case localExports.DEFLATE:
              case localExports.GZIP:
              case localExports.DEFLATERAW:
                var status = zlib_deflate.deflate(strm, flush);
                break;

              case localExports.UNZIP:
              case localExports.INFLATE:
              case localExports.GUNZIP:
              case localExports.INFLATERAW:
                var status = zlib_inflate.inflate(strm, flush);
                break;

              default:
                throw new Error("Unknown mode " + this.mode);
            }

            if (status !== localExports.Z_STREAM_END && status !== localExports.Z_OK) {
              this._error(status);
            }

            this.write_in_progress = false;
            return [strm.avail_in, strm.avail_out];
          };

          Zlib.prototype.close = function () {
            if (this.write_in_progress) {
              this.pending_close = true;
              return;
            }

            this.pending_close = false;

            if (this.mode === localExports.DEFLATE || this.mode === localExports.GZIP || this.mode === localExports.DEFLATERAW) {
              zlib_deflate.deflateEnd(this.strm);
            } else {
              zlib_inflate.inflateEnd(this.strm);
            }

            this.mode = localExports.NONE;
          };

          Zlib.prototype.reset = function () {
            switch (this.mode) {
              case localExports.DEFLATE:
              case localExports.DEFLATERAW:
                var status = zlib_deflate.deflateReset(this.strm);
                break;

              case localExports.INFLATE:
              case localExports.INFLATERAW:
                var status = zlib_inflate.inflateReset(this.strm);
                break;
            }

            if (status !== localExports.Z_OK) {
              this._error(status);
            }
          };

          Zlib.prototype._error = function (status) {
            this.onerror(msg[status] + ': ' + this.strm.msg, status);
            this.write_in_progress = false;
            if (this.pending_close) this.close();
          };

          localExports.Zlib = Zlib;
        }).call(this);
      }).call(this, localRequire('_process'), localRequire("buffer").Buffer);
    }, {
      "_process": 229,
      "buffer": 152,
      "pako/lib/zlib/constants": 218,
      "pako/lib/zlib/deflate.js": 220,
      "pako/lib/zlib/inflate.js": 222,
      "pako/lib/zlib/messages": 224,
      "pako/lib/zlib/zstream": 226
    }],
    150: [function (localRequire, localModule, localExports) {
      (function (process, Buffer) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          var Transform = localRequire('_stream_transform');
          var binding = localRequire('./binding');
          var util = localRequire('util');
          var assert = localRequire('assert').ok; // zlib doesn't provide these, so kludge them in following the same
          // const naming scheme zlib uses.

          binding.Z_MIN_WINDOWBITS = 8;
          binding.Z_MAX_WINDOWBITS = 15;
          binding.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.
          // technically it could work with as few as 8, but even 64 bytes
          // is absurdly low.  Usually a MB or more is best.

          binding.Z_MIN_CHUNK = 64;
          binding.Z_MAX_CHUNK = Infinity;
          binding.Z_DEFAULT_CHUNK = 16 * 1024;
          binding.Z_MIN_MEMLEVEL = 1;
          binding.Z_MAX_MEMLEVEL = 9;
          binding.Z_DEFAULT_MEMLEVEL = 8;
          binding.Z_MIN_LEVEL = -1;
          binding.Z_MAX_LEVEL = 9;
          binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION; // expose all the zlib constants

          Object.keys(binding).forEach(function (k) {
            if (k.match(/^Z/)) localExports[k] = binding[k];
          }); // translation table for return codes.

          localExports.codes = {
            Z_OK: binding.Z_OK,
            Z_STREAM_END: binding.Z_STREAM_END,
            Z_NEED_DICT: binding.Z_NEED_DICT,
            Z_ERRNO: binding.Z_ERRNO,
            Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
            Z_DATA_ERROR: binding.Z_DATA_ERROR,
            Z_MEM_ERROR: binding.Z_MEM_ERROR,
            Z_BUF_ERROR: binding.Z_BUF_ERROR,
            Z_VERSION_ERROR: binding.Z_VERSION_ERROR
          };
          Object.keys(localExports.codes).forEach(function (k) {
            localExports.codes[localExports.codes[k]] = k;
          });
          localExports.Deflate = Deflate;
          localExports.Inflate = Inflate;
          localExports.Gzip = Gzip;
          localExports.Gunzip = Gunzip;
          localExports.DeflateRaw = DeflateRaw;
          localExports.InflateRaw = InflateRaw;
          localExports.Unzip = Unzip;

          localExports.createDeflate = function (o) {
            return new Deflate(o);
          };

          localExports.createInflate = function (o) {
            return new Inflate(o);
          };

          localExports.createDeflateRaw = function (o) {
            return new DeflateRaw(o);
          };

          localExports.createInflateRaw = function (o) {
            return new InflateRaw(o);
          };

          localExports.createGzip = function (o) {
            return new Gzip(o);
          };

          localExports.createGunzip = function (o) {
            return new Gunzip(o);
          };

          localExports.createUnzip = function (o) {
            return new Unzip(o);
          }; // Convenience methods.
          // compress/decompress a string or buffer in one step.


          localExports.deflate = function (buffer, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts;
              opts = {};
            }

            return zlibBuffer(new Deflate(opts), buffer, callback);
          };

          localExports.deflateSync = function (buffer, opts) {
            return zlibBufferSync(new Deflate(opts), buffer);
          };

          localExports.gzip = function (buffer, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts;
              opts = {};
            }

            return zlibBuffer(new Gzip(opts), buffer, callback);
          };

          localExports.gzipSync = function (buffer, opts) {
            return zlibBufferSync(new Gzip(opts), buffer);
          };

          localExports.deflateRaw = function (buffer, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts;
              opts = {};
            }

            return zlibBuffer(new DeflateRaw(opts), buffer, callback);
          };

          localExports.deflateRawSync = function (buffer, opts) {
            return zlibBufferSync(new DeflateRaw(opts), buffer);
          };

          localExports.unzip = function (buffer, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts;
              opts = {};
            }

            return zlibBuffer(new Unzip(opts), buffer, callback);
          };

          localExports.unzipSync = function (buffer, opts) {
            return zlibBufferSync(new Unzip(opts), buffer);
          };

          localExports.inflate = function (buffer, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts;
              opts = {};
            }

            return zlibBuffer(new Inflate(opts), buffer, callback);
          };

          localExports.inflateSync = function (buffer, opts) {
            return zlibBufferSync(new Inflate(opts), buffer);
          };

          localExports.gunzip = function (buffer, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts;
              opts = {};
            }

            return zlibBuffer(new Gunzip(opts), buffer, callback);
          };

          localExports.gunzipSync = function (buffer, opts) {
            return zlibBufferSync(new Gunzip(opts), buffer);
          };

          localExports.inflateRaw = function (buffer, opts, callback) {
            if (typeof opts === 'function') {
              callback = opts;
              opts = {};
            }

            return zlibBuffer(new InflateRaw(opts), buffer, callback);
          };

          localExports.inflateRawSync = function (buffer, opts) {
            return zlibBufferSync(new InflateRaw(opts), buffer);
          };

          function zlibBuffer(engine, buffer, callback) {
            var buffers = [];
            var nread = 0;
            engine.on('error', onError);
            engine.on('end', onEnd);
            engine.end(buffer);
            flow();

            function flow() {
              var chunk;

              while (null !== (chunk = engine.read())) {
                buffers.push(chunk);
                nread += chunk.length;
              }

              engine.once('readable', flow);
            }

            function onError(err) {
              engine.removeListener('end', onEnd);
              engine.removeListener('readable', flow);
              callback(err);
            }

            function onEnd() {
              var buf = Buffer.concat(buffers, nread);
              buffers = [];
              callback(null, buf);
              engine.close();
            }
          }

          function zlibBufferSync(engine, buffer) {
            if (typeof buffer === 'string') buffer = new Buffer(buffer);
            if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');
            var flushFlag = binding.Z_FINISH;
            return engine._processChunk(buffer, flushFlag);
          } // generic zlib
          // minimal 2-byte header


          function Deflate(opts): void {
            if (!(this instanceof Deflate)) return new Deflate(opts);
            Zlib.call(this, opts, binding.DEFLATE);
          }

          function Inflate(opts): void {
            if (!(this instanceof Inflate)) return new Inflate(opts);
            Zlib.call(this, opts, binding.INFLATE);
          } // gzip - bigger header, same deflate compression


          function Gzip(opts): void {
            if (!(this instanceof Gzip)) return new Gzip(opts);
            Zlib.call(this, opts, binding.GZIP);
          }

          function Gunzip(opts): void {
            if (!(this instanceof Gunzip)) return new Gunzip(opts);
            Zlib.call(this, opts, binding.GUNZIP);
          } // raw - no header


          function DeflateRaw(opts): void {
            if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
            Zlib.call(this, opts, binding.DEFLATERAW);
          }

          function InflateRaw(opts): void {
            if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
            Zlib.call(this, opts, binding.INFLATERAW);
          } // auto-detect header.


          function Unzip(opts): void {
            if (!(this instanceof Unzip)) return new Unzip(opts);
            Zlib.call(this, opts, binding.UNZIP);
          } // the Zlib class they all inherit from
          // This thing manages the queue of requests, and returns
          // true or false if there is anything in the queue when
          // you call the .write() method.


          function Zlib(opts, mode) {
            this._opts = opts = opts || {};
            this._chunkSize = opts.chunkSize || localExports.Z_DEFAULT_CHUNK;
            Transform.call(this, opts);

            if (opts.flush) {
              if (opts.flush !== binding.Z_NO_FLUSH && opts.flush !== binding.Z_PARTIAL_FLUSH && opts.flush !== binding.Z_SYNC_FLUSH && opts.flush !== binding.Z_FULL_FLUSH && opts.flush !== binding.Z_FINISH && opts.flush !== binding.Z_BLOCK) {
                throw new Error('Invalid flush flag: ' + opts.flush);
              }
            }

            this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

            if (opts.chunkSize) {
              if (opts.chunkSize < localExports.Z_MIN_CHUNK || opts.chunkSize > localExports.Z_MAX_CHUNK) {
                throw new Error('Invalid chunk size: ' + opts.chunkSize);
              }
            }

            if (opts.windowBits) {
              if (opts.windowBits < localExports.Z_MIN_WINDOWBITS || opts.windowBits > localExports.Z_MAX_WINDOWBITS) {
                throw new Error('Invalid windowBits: ' + opts.windowBits);
              }
            }

            if (opts.level) {
              if (opts.level < localExports.Z_MIN_LEVEL || opts.level > localExports.Z_MAX_LEVEL) {
                throw new Error('Invalid compression level: ' + opts.level);
              }
            }

            if (opts.memLevel) {
              if (opts.memLevel < localExports.Z_MIN_MEMLEVEL || opts.memLevel > localExports.Z_MAX_MEMLEVEL) {
                throw new Error('Invalid memLevel: ' + opts.memLevel);
              }
            }

            if (opts.strategy) {
              if (opts.strategy != localExports.Z_FILTERED && opts.strategy != localExports.Z_HUFFMAN_ONLY && opts.strategy != localExports.Z_RLE && opts.strategy != localExports.Z_FIXED && opts.strategy != localExports.Z_DEFAULT_STRATEGY) {
                throw new Error('Invalid strategy: ' + opts.strategy);
              }
            }

            if (opts.dictionary) {
              if (!Buffer.isBuffer(opts.dictionary)) {
                throw new Error('Invalid dictionary: it should be a Buffer instance');
              }
            }

            this._binding = new binding.Zlib(mode);
            var self = this;
            this._hadError = false;

            this._binding.onerror = function (message, errno) {
              // there is no way to cleanly recover.
              // continuing only obscures problems.
              self._binding = null;
              self._hadError = true;
              var error: any = new Error(message);
              error.errno = errno;
              error.code = localExports.codes[errno];
              self.emit('error', error);
            };

            var level = localExports.Z_DEFAULT_COMPRESSION;
            if (typeof opts.level === 'number') level = opts.level;
            var strategy = localExports.Z_DEFAULT_STRATEGY;
            if (typeof opts.strategy === 'number') strategy = opts.strategy;

            this._binding.init(opts.windowBits || localExports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || localExports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

            this._buffer = new Buffer(this._chunkSize);
            this._offset = 0;
            this._closed = false;
            this._level = level;
            this._strategy = strategy;
            this.once('end', this.close);
          }

          util.inherits(Zlib, Transform);

          Zlib.prototype.params = function (level, strategy, callback) {
            if (level < localExports.Z_MIN_LEVEL || level > localExports.Z_MAX_LEVEL) {
              throw new RangeError('Invalid compression level: ' + level);
            }

            if (strategy != localExports.Z_FILTERED && strategy != localExports.Z_HUFFMAN_ONLY && strategy != localExports.Z_RLE && strategy != localExports.Z_FIXED && strategy != localExports.Z_DEFAULT_STRATEGY) {
              throw new TypeError('Invalid strategy: ' + strategy);
            }

            if (this._level !== level || this._strategy !== strategy) {
              var self = this;
              this.flush(binding.Z_SYNC_FLUSH, function () {
                self._binding.params(level, strategy);

                if (!self._hadError) {
                  self._level = level;
                  self._strategy = strategy;
                  if (callback) callback();
                }
              });
            } else {
              process.nextTick(callback);
            }
          };

          Zlib.prototype.reset = function () {
            return this._binding.reset();
          }; // This is the _flush function called by the transform class,
          // internally, when the last chunk has been written.


          Zlib.prototype._flush = function (callback) {
            this._transform(new Buffer(0), '', callback);
          };

          Zlib.prototype.flush = function (kind, callback) {
            var ws = this._writableState;

            if (typeof kind === 'function' || kind === void 0 && !callback) {
              callback = kind;
              kind = binding.Z_FULL_FLUSH;
            }

            if (ws.ended) {
              if (callback) process.nextTick(callback);
            } else if (ws.ending) {
              if (callback) this.once('end', callback);
            } else if (ws.needDrain) {
              var self = this;
              this.once('drain', function () {
                self.flush(callback);
              });
            } else {
              this._flushFlag = kind;
              this.write(new Buffer(0), '', callback);
            }
          };

          Zlib.prototype.close = function (callback) {
            if (callback) process.nextTick(callback);
            if (this._closed) return;
            this._closed = true;

            this._binding.close();

            var self = this;
            process.nextTick(function () {
              self.emit('close');
            });
          };

          Zlib.prototype._transform = function (chunk, encoding, cb) {
            var flushFlag;
            var ws = this._writableState;
            var ending = ws.ending || ws.ended;
            var last = ending && (!chunk || ws.length === chunk.length);
            if (!chunk === null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
            // If it's explicitly flushing at some other time, then we use
            // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
            // goodness.

            if (last) flushFlag = binding.Z_FINISH; else {
              flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and
              // go back to the normal behavior.

              if (chunk.length >= ws.length) {
                this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
              }
            }

            this._processChunk(chunk, flushFlag, cb);
          };

          Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
            var availInBefore = chunk && chunk.length;
            var availOutBefore = this._chunkSize - this._offset;
            var inOff = 0;
            var self = this;
            var async = typeof cb === 'function';

            if (!async) {
              var buffers = [];
              var nread = 0;
              var error;
              this.on('error', function (er) {
                error = er;
              });

              do {
                var res = this._binding.writeSync(flushFlag, chunk, // in
                  inOff, // in_off
                  availInBefore, // in_len
                  this._buffer, // out
                  this._offset, //out_off
                  availOutBefore); // out_len

              } while (!this._hadError && callback(res[0], res[1]));

              if (this._hadError) {
                throw error;
              }

              var buf = Buffer.concat(buffers, nread);
              this.close();
              return buf;
            }

            var req = this._binding.write(flushFlag, chunk, // in
              inOff, // in_off
              availInBefore, // in_len
              this._buffer, // out
              this._offset, //out_off
              availOutBefore); // out_len


            req.buffer = chunk;
            req.callback = callback;

            function callback(availInAfter, availOutAfter) {
              if (self._hadError) return;
              var have = availOutBefore - availOutAfter;
              assert(have >= 0, 'have should not go down');

              if (have > 0) {
                var out = self._buffer.slice(self._offset, self._offset + have);

                self._offset += have; // serve some output to the consumer.

                if (async) {
                  self.push(out);
                } else {
                  buffers.push(out);
                  nread += out.length;
                }
              } // exhausted the output buffer, or used all the input create a new one.


              if (availOutAfter === 0 || self._offset >= self._chunkSize) {
                availOutBefore = self._chunkSize;
                self._offset = 0;
                self._buffer = new Buffer(self._chunkSize);
              }

              if (availOutAfter === 0) {
                // Not actually done.  Need to reprocess.
                // Also, update the availInBefore to the availInAfter value,
                // so that if we have to hit it a third (fourth, etc.) time,
                // it'll have the correct byte counts.
                inOff += availInBefore - availInAfter;
                availInBefore = availInAfter;
                if (!async) return true;

                var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);

                newReq.callback = callback; // this same function

                newReq.buffer = chunk;
                return;
              }

              if (!async) return false; // finished with the chunk.

              cb();
            }
          };

          util.inherits(Deflate, Zlib);
          util.inherits(Inflate, Zlib);
          util.inherits(Gzip, Zlib);
          util.inherits(Gunzip, Zlib);
          util.inherits(DeflateRaw, Zlib);
          util.inherits(InflateRaw, Zlib);
          util.inherits(Unzip, Zlib);
        }).call(this);
      }).call(this, localRequire('_process'), localRequire("buffer").Buffer);
    }, {
      "./binding": 149,
      "_process": 229,
      "_stream_transform": 241,
      "assert": 143,
      "buffer": 152,
      "util": 250
    }],
    151: [function (localRequire, localModule, localExports) {
      arguments[4][108][0].apply(localExports, arguments);
    }, {
      "dup": 108
    }],
    152: [function (localRequire, localModule, localExports) {
      (function (global, Buffer) {
        (function () {

          var base64 = localRequire('base64-js');
          var ieee754 = localRequire('ieee754');
          var isArray = localRequire('isarray');
          localExports.Buffer = Buffer;
          localExports.SlowBuffer = SlowBuffer;
          localExports.INSPECT_MAX_BYTES = 50;
          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Use Object implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * Due to various browser bugs, sometimes the Object implementation will be used even
           * when the browser supports typed arrays.
           *
           * Note:
           *
           *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
           *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
           *
           *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
           *
           *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
           *     incorrect length in some situations.
          
           * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
           * get the Object implementation, which is slower but behaves correctly.
           */

          (<any>Buffer).TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
          /*
           * Export kMaxLength after typed array support is determined.
           */

          localExports.kMaxLength = kMaxLength();

          function typedArraySupport() {
            try {
              var arr: any = new Uint8Array(1);
              arr.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function foo() {
                  return 42;
                }
              };
              return arr.foo() === 42 && // typed array instances can be augmented
                typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
            } catch (e) {
              return false;
            }
          }

          function kMaxLength() {
            return (<any>Buffer).TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
          }

          function createBuffer(that, length) {
            if (kMaxLength() < length) {
              throw new RangeError('Invalid typed array length');
            }

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = new Uint8Array(length);
              that.__proto__ = Buffer.prototype;
            } else {
              // Fallback: Return an object instance of the Buffer class
              if (that === null) {
                that = new Buffer(length);
              }

              that.length = length;
            }

            return that;
          }
          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */

          function Buffer(arg, encodingOrOffset?, length?): void {
            if (!(<any>Buffer).TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
              return new Buffer(arg, encodingOrOffset, length);
            } // Common case.


            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new Error('If encoding is specified then the first argument must be a string');
              }

              return allocUnsafe(this, arg);
            }

            return from(this, arg, encodingOrOffset, length);
          }

          (<any>Buffer).poolSize = 8192; // not used by this implementation
          // TODO: Legacy, not needed anymore. Remove in next major version.

          (<any>Buffer)._augment = function (arr) {
            arr.__proto__ = Buffer.prototype;
            return arr;
          };

          function from(that, value, encodingOrOffset, length) {
            if (typeof value === 'number') {
              throw new TypeError('"value" argument must not be a number');
            }

            if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
              return fromArrayBuffer(that, value, encodingOrOffset, length);
            }

            if (typeof value === 'string') {
              return fromString(that, value, encodingOrOffset);
            }

            return fromObject(that, value);
          }
          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/


          (<any>Buffer).from = function (value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length);
          };

          if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            (<any>Buffer).__proto__ = Uint8Array;

            if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
              // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
              Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true
              });
            }
          }

          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be a number');
            } else if (size < 0) {
              throw new RangeError('"size" argument must not be negative');
            }
          }

          function alloc(that, size, fill, encoding) {
            assertSize(size);

            if (size <= 0) {
              return createBuffer(that, size);
            }

            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
            }

            return createBuffer(that, size);
          }
          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/


          (<any>Buffer).alloc = function (size, fill, encoding) {
            return alloc(null, size, fill, encoding);
          };

          function allocUnsafe(that, size) {
            assertSize(size);
            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

            if (!(<any>Buffer).TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < size; ++i) {
                that[i] = 0;
              }
            }

            return that;
          }
          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */


          (<any>Buffer).allocUnsafe = function (size) {
            return allocUnsafe(null, size);
          };
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */


          (<any>Buffer).allocUnsafeSlow = function (size) {
            return allocUnsafe(null, size);
          };

          function fromString(that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8';
            }

            if (!(<any>Buffer).isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding');
            }

            var length = byteLength(string, encoding) | 0;
            that = createBuffer(that, length);
            var actual = that.write(string, encoding);

            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              that = that.slice(0, actual);
            }

            return that;
          }

          function fromArrayLike(that, array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            that = createBuffer(that, length);

            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }

            return that;
          }

          function fromArrayBuffer(that, array, byteOffset, length) {
            array.byteLength; // this throws if `array` is not a valid ArrayBuffer

            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('\'offset\' is out of bounds');
            }

            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('\'length\' is out of bounds');
            }

            if (byteOffset === undefined && length === undefined) {
              array = new Uint8Array(array);
            } else if (length === undefined) {
              array = new Uint8Array(array, byteOffset);
            } else {
              array = new Uint8Array(array, byteOffset, length);
            }

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = array;
              that.__proto__ = Buffer.prototype;
            } else {
              // Fallback: Return an object instance of the Buffer class
              that = fromArrayLike(that, array);
            }

            return that;
          }

          function fromObject(that, obj) {
            if ((<any>Buffer).isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              that = createBuffer(that, len);

              if (that.length === 0) {
                return that;
              }

              obj.copy(that, 0, 0, len);
              return that;
            }

            if (obj) {
              if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
                if (typeof obj.length !== 'number' || isnan(obj.length)) {
                  return createBuffer(that, 0);
                }

                return fromArrayLike(that, obj);
              }

              if (obj.type === 'Buffer' && isArray(obj.data)) {
                return fromArrayLike(that, obj.data);
              }
            }

            throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
          }

          function checked(length) {
            // Note: cannot use `length < kMaxLength()` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= kMaxLength()) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
            }

            return length | 0;
          }

          function SlowBuffer(length) {
            if (+length != length) {
              // eslint-disable-line eqeqeq
              length = 0;
            }

            return (<any>Buffer).alloc(+length);
          }

          (<any>Buffer).isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };

          (<any>Buffer).compare = function compare(a, b) {
            if (!(<any>Buffer).isBuffer(a) || !(<any>Buffer).isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers');
            }

            if (a === b) return 0;
            var x = a.length;
            var y = b.length;

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          (<any>Buffer).isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;

              default:
                return false;
            }
          };

          (<any>Buffer).concat = function concat(list, length) {
            if (!isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }

            if (list.length === 0) {
              return (<any>Buffer).alloc(0);
            }

            var i;

            if (length === undefined) {
              length = 0;

              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }

            var buffer = (<any>Buffer).allocUnsafe(length);
            var pos = 0;

            for (i = 0; i < list.length; ++i) {
              var buf = list[i];

              if (!(<any>Buffer).isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }

              buf.copy(buffer, pos);
              pos += buf.length;
            }

            return buffer;
          };

          function byteLength(string, encoding) {
            if ((<any>Buffer).isBuffer(string)) {
              return string.length;
            }

            if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
              return string.byteLength;
            }

            if (typeof string !== 'string') {
              string = '' + string;
            }

            var len = string.length;
            if (len === 0) return 0; // Use a for loop to avoid recursion

            var loweredCase = false;

            for (; ;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len;

                case 'utf8':
                case 'utf-8':
                case undefined:
                  return utf8ToBytes(string).length;

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;

                case 'hex':
                  return len >>> 1;

                case 'base64':
                  return base64ToBytes(string).length;

                default:
                  if (loweredCase) return utf8ToBytes(string).length; // assume utf8

                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }

          (<any>Buffer).byteLength = byteLength;

          function slowToString(encoding, start, end) {
            var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.
            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

            if (start === undefined || start < 0) {
              start = 0;
            } // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.


            if (start > this.length) {
              return '';
            }

            if (end === undefined || end > this.length) {
              end = this.length;
            }

            if (end <= 0) {
              return '';
            } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


            end >>>= 0;
            start >>>= 0;

            if (end <= start) {
              return '';
            }

            if (!encoding) encoding = 'utf8';

            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);

                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);

                case 'ascii':
                  return asciiSlice(this, start, end);

                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end);

                case 'base64':
                  return base64Slice(this, start, end);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;
              }
            }
          } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
          // Buffer instances.


          Buffer.prototype._isBuffer = true;

          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }

          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;

            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits');
            }

            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }

            return this;
          };

          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;

            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits');
            }

            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }

            return this;
          };

          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;

            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits');
            }

            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }

            return this;
          };

          Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0) return '';
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };

          Buffer.prototype.equals = function equals(b) {
            if (!(<any>Buffer).isBuffer(b)) throw new TypeError('Argument must be a Buffer');
            if (this === b) return true;
            return (<any>Buffer).compare(this, b) === 0;
          };

          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = localExports.INSPECT_MAX_BYTES;

            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
              if (this.length > max) str += ' ... ';
            }

            return '<Buffer ' + str + '>';
          };

          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (!(<any>Buffer).isBuffer(target)) {
              throw new TypeError('Argument must be a Buffer');
            }

            if (start === undefined) {
              start = 0;
            }

            if (end === undefined) {
              end = target ? target.length : 0;
            }

            if (thisStart === undefined) {
              thisStart = 0;
            }

            if (thisEnd === undefined) {
              thisEnd = this.length;
            }

            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index');
            }

            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }

            if (thisStart >= thisEnd) {
              return -1;
            }

            if (start >= end) {
              return 1;
            }

            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);

            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }

            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf


          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1; // Normalize byteOffset

            if (typeof byteOffset === 'string') {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff;
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000;
            }

            byteOffset = +byteOffset; // Coerce to Number.

            if (isNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1;
            } // Normalize byteOffset: negative offsets start from the end of the buffer


            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

            if (byteOffset >= buffer.length) {
              if (dir) return -1; else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0; else return -1;
            } // Normalize val


            if (typeof val === 'string') {
              val = (<any>Buffer).from(val, encoding);
            } // Finally, search either indexOf (if dir is true) or lastIndexOf


            if ((<any>Buffer).isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1;
              }

              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === 'number') {
              val = val & 0xFF; // Search for a byte value [0-255]

              if ((<any>Buffer).TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }

              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }

            throw new TypeError('val must be string, number or Buffer');
          }

          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;

            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();

              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }

                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }

            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              } else {
                return buf.readUInt16BE(i * indexSize);
              }
            }

            var i;

            if (dir) {
              var foundIndex = -1;

              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

              for (i = byteOffset; i >= 0; i--) {
                var found = true;

                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }

                if (found) return i;
              }
            }

            return -1;
          }

          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };

          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };

          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };

          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;

            if (!length) {
              length = remaining;
            } else {
              length = Number(length);

              if (length > remaining) {
                length = remaining;
              }
            } // must be an even number of digits


            var strLen = string.length;
            if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

            if (length > strLen / 2) {
              length = strLen / 2;
            }

            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }

            return i;
          }

          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }

          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }

          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }

          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }

          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }

          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0; // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0; // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset | 0;

              if (isFinite(length)) {
                length = length | 0;
                if (encoding === undefined) encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              } // legacy write(string, encoding, offset, length) - remove in v0.13

            } else {
              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
            }

            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;

            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds');
            }

            if (!encoding) encoding = 'utf8';
            var loweredCase = false;

            for (; ;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);

                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);

                case 'ascii':
                  return asciiWrite(this, string, offset, length);

                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length);

                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length);

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };

          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };

          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }

          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;

            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }

                    break;

                  case 2:
                    secondByte = buf[i + 1];

                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint;
                      }
                    }

                    break;

                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];

                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint;
                      }
                    }

                    break;

                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];

                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }

                }
              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD;
                bytesPerSequence = 1;
              } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                codePoint = 0xDC00 | codePoint & 0x3FF;
              }

              res.push(codePoint);
              i += bytesPerSequence;
            }

            return decodeCodePointsArray(res);
          } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety


          var MAX_ARGUMENTS_LENGTH = 0x1000;

          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;

            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            } // Decode in chunks to avoid "call stack size exceeded".


            var res = '';
            var i = 0;

            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }

            return res;
          }

          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7F);
            }

            return ret;
          }

          function latin1Slice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }

            return ret;
          }

          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = '';

            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }

            return out;
          }

          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';

            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }

            return res;
          }

          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;

            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }

            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }

            if (end < start) end = start;
            var newBuf;

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer.prototype;
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer(sliceLen, undefined);

              for (var i = 0; i < sliceLen; ++i) {
                newBuf[i] = this[i + start];
              }
            }

            return newBuf;
          };
          /*
           * Need to make sure that buffer isn't trying to write out of bounds.
           */


          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
          }

          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;

            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }

            return val;
          };

          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;

            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }

            var val = this[offset + --byteLength];
            var mul = 1;

            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }

            return val;
          };

          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };

          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };

          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };

          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
          };

          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };

          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;

            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }

            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };

          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset | 0;
            byteLength = byteLength | 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];

            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }

            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };

          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };

          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };

          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };

          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };

          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };

          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };

          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };

          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };

          function checkInt(buf, value, offset, ext, max, min) {
            if (!(<any>Buffer).isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }

          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;

            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var mul = 1;
            var i = 0;
            this[offset] = value & 0xFF;

            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength = byteLength | 0;

            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }

            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xFF;

            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            if (!(<any>Buffer).TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            this[offset] = value & 0xff;
            return offset + 1;
          };

          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffff + value + 1;

            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
              buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }

          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }

            return offset + 2;
          };

          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }

            return offset + 2;
          };

          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffffffff + value + 1;

            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
              buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
            }
          }

          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 0xff;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }

            return offset + 4;
          };

          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }

            return offset + 4;
          };

          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;

            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 0xFF;

            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }

              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset | 0;

            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }

            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 0xFF;

            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }

              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }

            return offset + byteLength;
          };

          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (!(<any>Buffer).TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            if (value < 0) value = 0xff + value + 1;
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }

            return offset + 2;
          };

          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 0xff;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }

            return offset + 2;
          };

          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 0xff;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }

            return offset + 4;
          };

          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;

            if ((<any>Buffer).TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 0xff;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }

            return offset + 4;
          };

          function checkIEEE754(buf, value, offset, ext, max?, min?) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
            if (offset < 0) throw new RangeError('Index out of range');
          }

          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4);
            }

            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }

          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };

          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8);
            }

            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }

          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };

          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }

            if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
            if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

            if (end > this.length) end = this.length;

            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }

            var len = end - start;
            var i;

            if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1000 || !(<any>Buffer).TYPED_ARRAY_SUPPORT) {
              // ascending copy from start
              for (i = 0; i < len; ++i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
            }

            return len;
          }; // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])


          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === 'string') {
                encoding = end;
                end = this.length;
              }

              if (val.length === 1) {
                var code = val.charCodeAt(0);

                if (code < 256) {
                  val = code;
                }
              }

              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string');
              }

              if (typeof encoding === 'string' && !(<any>Buffer).isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding);
              }
            } else if (typeof val === 'number') {
              val = val & 255;
            } // Invalid ranges are not set to a default, so can range check early.


            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index');
            }

            if (end <= start) {
              return this;
            }

            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;
            if (!val) val = 0;
            var i;

            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = (<any>Buffer).isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
              var len = bytes.length;

              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }

            return this;
          }; // HELPER FUNCTIONS
          // ================


          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

          function base64clean(str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

            if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

            while (str.length % 4 !== 0) {
              str = str + '=';
            }

            return str;
          }

          function stringtrim(str) {
            if (str.trim) return str.trim();
            return str.replace(/^\s+|\s+$/g, '');
          }

          function toHex(n) {
            if (n < 16) return '0' + n.toString(16);
            return n.toString(16);
          }

          function utf8ToBytes(string, units?) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];

            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i); // is surrogate component

              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } // valid lead


                  leadSurrogate = codePoint;
                  continue;
                } // 2 leads in a row


                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  leadSurrogate = codePoint;
                  continue;
                } // valid surrogate pair


                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              }

              leadSurrogate = null; // encode utf8

              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else {
                throw new Error('Invalid code point');
              }
            }

            return bytes;
          }

          function asciiToBytes(str) {
            var byteArray = [];

            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xFF);
            }

            return byteArray;
          }

          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];

            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }

            return byteArray;
          }

          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }

          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }

            return i;
          }

          function isnan(val) {
            return val !== val; // eslint-disable-line no-self-compare
          }
        }).call(this);
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, localRequire("buffer").Buffer);
    }, {
      "base64-js": 147,
      "buffer": 152,
      "ieee754": 211,
      "isarray": 214
    }],
    153: [function (localRequire, localModule, localExports) {
      arguments[4][13][0].apply(localExports, arguments);
    }, {
      "../../modules/_core": 164,
      "../../modules/es6.array.is-array": 203,
      "dup": 13
    }],
    154: [function (localRequire, localModule, localExports) {
      var core = localRequire('../../modules/_core');
      var $JSON = core.JSON || (core.JSON = {
        stringify: JSON.stringify
      });

      localModule.localExports = function stringify(it) {
        // eslint-disable-line no-unused-vars
        return $JSON.stringify.apply($JSON, arguments);
      };
    }, {
      "../../modules/_core": 164
    }],
    155: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.number.is-finite');
      localModule.localExports = localRequire('../../modules/_core').Number.isFinite;
    }, {
      "../../modules/_core": 164,
      "../../modules/es6.number.is-finite": 204
    }],
    156: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.object.assign');
      localModule.localExports = localRequire('../../modules/_core').Object.assign;
    }, {
      "../../modules/_core": 164,
      "../../modules/es6.object.assign": 205
    }],
    157: [function (localRequire, localModule, localExports) {
      localRequire('../../modules/es6.object.create');
      var $Object = localRequire('../../modules/_core').Object;

      localModule.localExports = function create(P, D) {
        return $Object.create(P, D);
      };
    }, {
      "../../modules/_core": 164,
      "../../modules/es6.object.create": 206
    }],
    158: [function (localRequire, localModule, localExports) {
      arguments[4][18][0].apply(localExports, arguments);
    }, {
      "../../modules/_core": 164,
      "../../modules/es6.object.keys": 207,
      "dup": 18
    }],
    159: [function (localRequire, localModule, localExports) {
      localRequire('../modules/es6.parse-int');
      localModule.localExports = localRequire('../modules/_core').parseInt;
    }, {
      "../modules/_core": 164,
      "../modules/es6.parse-int": 208
    }],
    160: [function (localRequire, localModule, localExports) {
      arguments[4][22][0].apply(localExports, arguments);
    }, {
      "dup": 22
    }],
    161: [function (localRequire, localModule, localExports) {
      arguments[4][25][0].apply(localExports, arguments);
    }, {
      "./_is-object": 179,
      "dup": 25
    }],
    162: [function (localRequire, localModule, localExports) {
      arguments[4][27][0].apply(localExports, arguments);
    }, {
      "./_to-absolute-index": 196,
      "./_to-iobject": 198,
      "./_to-length": 199,
      "dup": 27
    }],
    163: [function (localRequire, localModule, localExports) {
      arguments[4][32][0].apply(localExports, arguments);
    }, {
      "dup": 32
    }],
    164: [function (localRequire, localModule, localExports) {
      arguments[4][36][0].apply(localExports, arguments);
    }, {
      "dup": 36
    }],
    165: [function (localRequire, localModule, localExports) {
      arguments[4][38][0].apply(localExports, arguments);
    }, {
      "./_a-function": 160,
      "dup": 38
    }],
    166: [function (localRequire, localModule, localExports) {
      arguments[4][39][0].apply(localExports, arguments);
    }, {
      "dup": 39
    }],
    167: [function (localRequire, localModule, localExports) {
      arguments[4][40][0].apply(localExports, arguments);
    }, {
      "./_fails": 171,
      "dup": 40
    }],
    168: [function (localRequire, localModule, localExports) {
      arguments[4][41][0].apply(localExports, arguments);
    }, {
      "./_global": 172,
      "./_is-object": 179,
      "dup": 41
    }],
    169: [function (localRequire, localModule, localExports) {
      arguments[4][42][0].apply(localExports, arguments);
    }, {
      "dup": 42
    }],
    170: [function (localRequire, localModule, localExports) {
      arguments[4][43][0].apply(localExports, arguments);
    }, {
      "./_core": 164,
      "./_ctx": 165,
      "./_global": 172,
      "./_has": 173,
      "./_hide": 174,
      "dup": 43
    }],
    171: [function (localRequire, localModule, localExports) {
      arguments[4][44][0].apply(localExports, arguments);
    }, {
      "dup": 44
    }],
    172: [function (localRequire, localModule, localExports) {
      arguments[4][46][0].apply(localExports, arguments);
    }, {
      "dup": 46
    }],
    173: [function (localRequire, localModule, localExports) {
      arguments[4][47][0].apply(localExports, arguments);
    }, {
      "dup": 47
    }],
    174: [function (localRequire, localModule, localExports) {
      arguments[4][48][0].apply(localExports, arguments);
    }, {
      "./_descriptors": 167,
      "./_object-dp": 183,
      "./_property-desc": 191,
      "dup": 48
    }],
    175: [function (localRequire, localModule, localExports) {
      arguments[4][49][0].apply(localExports, arguments);
    }, {
      "./_global": 172,
      "dup": 49
    }],
    176: [function (localRequire, localModule, localExports) {
      arguments[4][50][0].apply(localExports, arguments);
    }, {
      "./_descriptors": 167,
      "./_dom-create": 168,
      "./_fails": 171,
      "dup": 50
    }],
    177: [function (localRequire, localModule, localExports) {
      arguments[4][52][0].apply(localExports, arguments);
    }, {
      "./_cof": 163,
      "dup": 52
    }],
    178: [function (localRequire, localModule, localExports) {
      arguments[4][54][0].apply(localExports, arguments);
    }, {
      "./_cof": 163,
      "dup": 54
    }],
    179: [function (localRequire, localModule, localExports) {
      arguments[4][55][0].apply(localExports, arguments);
    }, {
      "dup": 55
    }],
    180: [function (localRequire, localModule, localExports) {
      arguments[4][62][0].apply(localExports, arguments);
    }, {
      "dup": 62
    }],
    181: [function (localRequire, localModule, localExports) {

      var DESCRIPTORS = localRequire('./_descriptors');
      var getKeys = localRequire('./_object-keys');
      var gOPS = localRequire('./_object-gops');
      var pIE = localRequire('./_object-pie');
      var toObject = localRequire('./_to-object');
      var IObject = localRequire('./_iobject');
      var $assign = (<any>Object).assign; // should work with symbols and should have deterministic property order (V8 bug)

      localModule.localExports = !$assign || localRequire('./_fails')(function () {
        var A = {};
        var B = {}; // eslint-disable-next-line no-undef

        var S = Symbol();
        var K = 'abcdefghijklmnopqrst';
        A[S] = 7;
        K.split('').forEach(function (k) {
          B[k] = k;
        });
        return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
      }) ? function assign(target, source) {
        // eslint-disable-line no-unused-vars
        var T = toObject(target);
        var aLen = arguments.length;
        var index = 1;
        var getSymbols = gOPS.f;
        var isEnum = pIE.f;

        while (aLen > index) {
          var S = IObject(arguments[index++]);
          var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
          var length = keys.length;
          var j = 0;
          var key;

          while (length > j) {
            key = keys[j++];
            if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
          }
        }

        return T;
      } : $assign;
    }, {
      "./_descriptors": 167,
      "./_fails": 171,
      "./_iobject": 177,
      "./_object-gops": 185,
      "./_object-keys": 187,
      "./_object-pie": 188,
      "./_to-object": 200
    }],
    182: [function (localRequire, localModule, localExports) {
      arguments[4][66][0].apply(localExports, arguments);
    }, {
      "./_an-object": 161,
      "./_dom-create": 168,
      "./_enum-bug-keys": 169,
      "./_html": 175,
      "./_object-dps": 184,
      "./_shared-key": 192,
      "dup": 66
    }],
    183: [function (localRequire, localModule, localExports) {
      arguments[4][67][0].apply(localExports, arguments);
    }, {
      "./_an-object": 161,
      "./_descriptors": 167,
      "./_ie8-dom-define": 176,
      "./_to-primitive": 201,
      "dup": 67
    }],
    184: [function (localRequire, localModule, localExports) {
      arguments[4][68][0].apply(localExports, arguments);
    }, {
      "./_an-object": 161,
      "./_descriptors": 167,
      "./_object-dp": 183,
      "./_object-keys": 187,
      "dup": 68
    }],
    185: [function (localRequire, localModule, localExports) {
      localExports.f = (<any>Object).getOwnPropertySymbols;
    }, {}],
    186: [function (localRequire, localModule, localExports) {
      arguments[4][71][0].apply(localExports, arguments);
    }, {
      "./_array-includes": 162,
      "./_has": 173,
      "./_shared-key": 192,
      "./_to-iobject": 198,
      "dup": 71
    }],
    187: [function (localRequire, localModule, localExports) {
      arguments[4][72][0].apply(localExports, arguments);
    }, {
      "./_enum-bug-keys": 169,
      "./_object-keys-internal": 186,
      "dup": 72
    }],
    188: [function (localRequire, localModule, localExports) {
      arguments[4][73][0].apply(localExports, arguments);
    }, {
      "dup": 73
    }],
    189: [function (localRequire, localModule, localExports) {
      arguments[4][74][0].apply(localExports, arguments);
    }, {
      "./_core": 164,
      "./_export": 170,
      "./_fails": 171,
      "dup": 74
    }],
    190: [function (localRequire, localModule, localExports) {
      var $parseInt = localRequire('./_global').parseInt;
      var $trim = localRequire('./_string-trim').trim;
      var ws = localRequire('./_string-ws');
      var hex = /^[-+]?0[xX]/;
      localModule.localExports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
        var string = $trim(String(str), 3);
        return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
      } : $parseInt;
    }, {
      "./_global": 172,
      "./_string-trim": 194,
      "./_string-ws": 195
    }],
    191: [function (localRequire, localModule, localExports) {
      arguments[4][77][0].apply(localExports, arguments);
    }, {
      "dup": 77
    }],
    192: [function (localRequire, localModule, localExports) {
      arguments[4][84][0].apply(localExports, arguments);
    }, {
      "./_shared": 193,
      "./_uid": 202,
      "dup": 84
    }],
    193: [function (localRequire, localModule, localExports) {
      arguments[4][85][0].apply(localExports, arguments);
    }, {
      "./_core": 164,
      "./_global": 172,
      "./_library": 180,
      "dup": 85
    }],
    194: [function (localRequire, localModule, localExports) {
      var $export = localRequire('./_export');
      var defined = localRequire('./_defined');
      var fails = localRequire('./_fails');
      var spaces = localRequire('./_string-ws');
      var space = '[' + spaces + ']';
      var non: any = "\u200B\x85";
      var ltrim = RegExp('^' + space + space + '*');
      var rtrim = RegExp(space + space + '*$');

      var exporter: any = function exporter(KEY, exec, ALIAS) {
        var exp = {};
        var FORCE = fails(function () {
          return !!spaces[KEY]() || non[KEY]() != non;
        });
        var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
        if (ALIAS) exp[ALIAS] = fn;
        $export($export.P + $export.F * FORCE, 'String', exp);
      }; // 1 -> String#trimLeft
      // 2 -> String#trimRight
      // 3 -> String#trim


      var trim = exporter.trim = function (string, TYPE) {
        string = String(defined(string));
        if (TYPE & 1) string = string.replace(ltrim, '');
        if (TYPE & 2) string = string.replace(rtrim, '');
        return string;
      };

      localModule.localExports = exporter;
    }, {
      "./_defined": 166,
      "./_export": 170,
      "./_fails": 171,
      "./_string-ws": 195
    }],
    195: [function (localRequire, localModule, localExports) {
      localModule.localExports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }, {}],
    196: [function (localRequire, localModule, localExports) {
      arguments[4][89][0].apply(localExports, arguments);
    }, {
      "./_to-integer": 197,
      "dup": 89
    }],
    197: [function (localRequire, localModule, localExports) {
      arguments[4][90][0].apply(localExports, arguments);
    }, {
      "dup": 90
    }],
    198: [function (localRequire, localModule, localExports) {
      arguments[4][91][0].apply(localExports, arguments);
    }, {
      "./_defined": 166,
      "./_iobject": 177,
      "dup": 91
    }],
    199: [function (localRequire, localModule, localExports) {
      arguments[4][92][0].apply(localExports, arguments);
    }, {
      "./_to-integer": 197,
      "dup": 92
    }],
    200: [function (localRequire, localModule, localExports) {
      arguments[4][93][0].apply(localExports, arguments);
    }, {
      "./_defined": 166,
      "dup": 93
    }],
    201: [function (localRequire, localModule, localExports) {
      arguments[4][94][0].apply(localExports, arguments);
    }, {
      "./_is-object": 179,
      "dup": 94
    }],
    202: [function (localRequire, localModule, localExports) {
      arguments[4][95][0].apply(localExports, arguments);
    }, {
      "dup": 95
    }],
    203: [function (localRequire, localModule, localExports) {
      arguments[4][101][0].apply(localExports, arguments);
    }, {
      "./_export": 170,
      "./_is-array": 178,
      "dup": 101
    }],
    204: [function (localRequire, localModule, localExports) {
      // 20.1.2.2 Number.isFinite(number)
      var $export = localRequire('./_export');
      var _isFinite = localRequire('./_global').isFinite;
      $export($export.S, 'Number', {
        isFinite: function isFinite(it) {
          return typeof it == 'number' && _isFinite(it);
        }
      });
    }, {
      "./_export": 170,
      "./_global": 172
    }],
    205: [function (localRequire, localModule, localExports) {
      // 19.1.3.1 Object.assign(target, source)
      var $export = localRequire('./_export');
      $export($export.S + $export.F, 'Object', {
        assign: localRequire('./_object-assign')
      });
    }, {
      "./_export": 170,
      "./_object-assign": 181
    }],
    206: [function (localRequire, localModule, localExports) {
      var $export = localRequire('./_export'); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])

      $export($export.S, 'Object', {
        create: localRequire('./_object-create')
      });
    }, {
      "./_export": 170,
      "./_object-create": 182
    }],
    207: [function (localRequire, localModule, localExports) {
      arguments[4][107][0].apply(localExports, arguments);
    }, {
      "./_object-keys": 187,
      "./_object-sap": 189,
      "./_to-object": 200,
      "dup": 107
    }],
    208: [function (localRequire, localModule, localExports) {
      var $export = localRequire('./_export');
      var $parseInt = localRequire('./_parse-int'); // 18.2.5 parseInt(string, radix)

      $export($export.G + $export.F * <any>(parseInt != $parseInt), {
        parseInt: $parseInt
      });
    }, {
      "./_export": 170,
      "./_parse-int": 190
    }],
    209: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg);
            }

            return objectToString(arg) === '[object Array]';
          }

          localExports.isArray = isArray;

          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }

          localExports.isBoolean = isBoolean;

          function isNull(arg) {
            return arg === null;
          }

          localExports.isNull = isNull;

          function isNullOrUndefined(arg) {
            return arg == null;
          }

          localExports.isNullOrUndefined = isNullOrUndefined;

          function isNumber(arg) {
            return typeof arg === 'number';
          }

          localExports.isNumber = isNumber;

          function isString(arg) {
            return typeof arg === 'string';
          }

          localExports.isString = isString;

          function isSymbol(arg) {
            return typeof arg === 'symbol';
          }

          localExports.isSymbol = isSymbol;

          function isUndefined(arg) {
            return arg === void 0;
          }

          localExports.isUndefined = isUndefined;

          function isRegExp(re) {
            return objectToString(re) === '[object RegExp]';
          }

          localExports.isRegExp = isRegExp;

          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }

          localExports.isObject = isObject;

          function isDate(d) {
            return objectToString(d) === '[object Date]';
          }

          localExports.isDate = isDate;

          function isError(e) {
            return objectToString(e) === '[object Error]' || e instanceof Error;
          }

          localExports.isError = isError;

          function isFunction(arg) {
            return typeof arg === 'function';
          }

          localExports.isFunction = isFunction;

          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
              typeof arg === 'undefined';
          }

          localExports.isPrimitive = isPrimitive;
          localExports.isBuffer = Buffer.isBuffer;

          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }).call(this);
      }).call(this, {
        "isBuffer": localRequire("../../is-buffer/index.js")
      });
    }, {
      "../../is-buffer/index.js": 213
    }],
    210: [function (localRequire, localModule, localExports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
      }

      localModule.localExports = EventEmitter; // Backwards-compat with node 0.10.x

      (<any>EventEmitter).EventEmitter = EventEmitter;
      EventEmitter.prototype._events = undefined;
      EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
      // added to it. This is a useful default which helps finding memory leaks.

      (<any>EventEmitter).defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.

      EventEmitter.prototype.setMaxListeners = function (n) {
        if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
        this._maxListeners = n;
        return this;
      };

      EventEmitter.prototype.emit = function (type) {
        var er, handler, len, args, i, listeners;
        if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.

        if (type === 'error') {
          if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
            er = arguments[1];

            if (er instanceof Error) {
              throw er; // Unhandled 'error' event
            } else {
              // At least give some kind of context to the user
              var err: any = new Error('Uncaught, unspecified "error" event. (' + er + ')');
              err.context = er;
              throw err;
            }
          }
        }

        handler = this._events[type];
        if (isUndefined(handler)) return false;

        if (isFunction(handler)) {
          switch (arguments.length) {
            // fast cases
            case 1:
              handler.call(this);
              break;

            case 2:
              handler.call(this, arguments[1]);
              break;

            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            // slower

            default:
              args = Array.prototype.slice.call(arguments, 1);
              handler.apply(this, args);
          }
        } else if (isObject(handler)) {
          args = Array.prototype.slice.call(arguments, 1);
          listeners = handler.slice();
          len = listeners.length;

          for (i = 0; i < len; i++) {
            listeners[i].apply(this, args);
          }
        }

        return true;
      };

      EventEmitter.prototype.addListener = function (type, listener) {
        var m;
        if (!isFunction(listener)) throw TypeError('listener must be a function');
        if (!this._events) this._events = {}; // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".

        if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
        if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.
          this._events[type] = listener; else if (isObject(this._events[type])) // If we've already got an array, just append.
          this._events[type].push(listener); else // Adding the second element, need to change to array.
          this._events[type] = [this._events[type], listener]; // Check for listener leak

        if (isObject(this._events[type]) && !this._events[type].warned) {
          if (!isUndefined(this._maxListeners)) {
            m = this._maxListeners;
          } else {
            m = (<any>EventEmitter).defaultMaxListeners;
          }

          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);

            if (typeof console.trace === 'function') {
              // not supported in IE 10
              console.trace();
            }
          }
        }

        return this;
      };

      EventEmitter.prototype.on = EventEmitter.prototype.addListener;

      EventEmitter.prototype.once = function (type, listener) {
        if (!isFunction(listener)) throw TypeError('listener must be a function');
        var fired = false;

        function g() {
          this.removeListener(type, g);

          if (!fired) {
            fired = true;
            listener.apply(this, arguments);
          }
        }

        (<any>g).listener = listener;
        this.on(type, g);
        return this;
      }; // emits a 'removeListener' event iff the listener was removed


      EventEmitter.prototype.removeListener = function (type, listener) {
        var list, position, length, i;
        if (!isFunction(listener)) throw TypeError('listener must be a function');
        if (!this._events || !this._events[type]) return this;
        list = this._events[type];
        length = list.length;
        position = -1;

        if (list === listener || isFunction(list.listener) && list.listener === listener) {
          delete this._events[type];
          if (this._events.removeListener) this.emit('removeListener', type, listener);
        } else if (isObject(list)) {
          for (i = length; i-- > 0;) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              position = i;
              break;
            }
          }

          if (position < 0) return this;

          if (list.length === 1) {
            list.length = 0;
            delete this._events[type];
          } else {
            list.splice(position, 1);
          }

          if (this._events.removeListener) this.emit('removeListener', type, listener);
        }

        return this;
      };

      EventEmitter.prototype.removeAllListeners = function (type) {
        var key, listeners;
        if (!this._events) return this; // not listening for removeListener, no need to emit

        if (!this._events.removeListener) {
          if (arguments.length === 0) this._events = {}; else if (this._events[type]) delete this._events[type];
          return this;
        } // emit removeListener for all listeners on all events


        if (arguments.length === 0) {
          for (key in this._events) {
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }

          this.removeAllListeners('removeListener');
          this._events = {};
          return this;
        }

        listeners = this._events[type];

        if (isFunction(listeners)) {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          while (listeners.length) {
            this.removeListener(type, listeners[listeners.length - 1]);
          }
        }

        delete this._events[type];
        return this;
      };

      EventEmitter.prototype.listeners = function (type) {
        var ret;
        if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [this._events[type]]; else ret = this._events[type].slice();
        return ret;
      };

      EventEmitter.prototype.listenerCount = function (type) {
        if (this._events) {
          var evlistener = this._events[type];
          if (isFunction(evlistener)) return 1; else if (evlistener) return evlistener.length;
        }

        return 0;
      };

      (<any>EventEmitter).listenerCount = function (emitter, type) {
        return emitter.listenerCount(type);
      };

      function isFunction(arg) {
        return typeof arg === 'function';
      }

      function isNumber(arg) {
        return typeof arg === 'number';
      }

      function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
      }

      function isUndefined(arg) {
        return arg === void 0;
      }
    }, {}],
    211: [function (localRequire, localModule, localExports) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      localExports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;

        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) { }

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;

        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) { }

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }

        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };

      localExports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);

          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }

          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }

          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }

        e = e << mLen | m;
        eLen += mLen;

        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }

        buffer[offset + i - d] |= s * 128;
      };
    }, {}],
    212: [function (localRequire, localModule, localExports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        localModule.localExports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        // old school shim for old browsers
        localModule.localExports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;

            var TempCtor = function TempCtor() { };

            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }, {}],
    213: [function (localRequire, localModule, localExports) {
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      // The _isBuffer check is for Safari 5-7 support, because it's missing
      // Object.prototype.constructor. Remove this eventually
      localModule.localExports = function (obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };

      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
      } // For Node v0.10 support. Remove this eventually.


      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
      }
    }, {}],
    214: [function (localRequire, localModule, localExports) {
      var toString = {}.toString;

      localModule.localExports = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
      };
    }, {}],
    215: [function (localRequire, localModule, localExports) {
      /* eslint-disable no-unused-vars */

      var getOwnPropertySymbols = (<any>Object).getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;

      function toObject(val) {
        if (val === null || val === undefined) {
          throw new TypeError('Object.assign cannot be called with null or undefined');
        }

        return Object(val);
      }

      function shouldUseNative() {
        try {
          if (!(<any>Object).assign) {
            return false;
          } // Detect buggy property enumeration order in older V8 versions.
          // https://bugs.chromium.org/p/v8/issues/detail?id=4118


          var test1: any = new String('abc'); // eslint-disable-line no-new-wrappers

          test1[5] = 'de';

          if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


          var test2 = {};

          for (var i = 0; i < 10; i++) {
            test2['_' + String.fromCharCode(i)] = i;
          }

          var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
            return test2[n];
          });

          if (order2.join('') !== '0123456789') {
            return false;
          } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


          var test3 = {};
          'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
            test3[letter] = letter;
          });

          if (Object.keys((<any>Object).assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
            return false;
          }

          return true;
        } catch (err) {
          // We don't expect any of the above to throw, but better to be safe.
          return false;
        }
      }

      localModule.localExports = shouldUseNative() ? (<any>Object).assign : function (target, source) {
        var from;
        var to = toObject(target);
        var symbols;

        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }

          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);

            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }

        return to;
      };
    }, {}],
    216: [function (localRequire, localModule, localExports) {

      var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

      localExports.assign = function (obj
        /*from1, from2, from3, ...*/
      ) {
        var sources = Array.prototype.slice.call(arguments, 1);

        while (sources.length) {
          var source = sources.shift();

          if (!source) {
            continue;
          }

          if (typeof source !== 'object') {
            throw new TypeError(source + 'must be non-object');
          }

          for (var p in source) {
            if (source.hasOwnProperty(p)) {
              obj[p] = source[p];
            }
          }
        }

        return obj;
      }; // reduce buffer size, avoiding mem copy


      localExports.shrinkBuf = function (buf, size) {
        if (buf.length === size) {
          return buf;
        }

        if (buf.subarray) {
          return buf.subarray(0, size);
        }

        buf.length = size;
        return buf;
      };

      var fnTyped = {
        arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          } // Fallback to ordinary array


          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function flattenChunks(chunks) {
          var i, l, len, pos, chunk, result; // calculate data length

          len = 0;

          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          } // join chunks


          result = new Uint8Array(len);
          pos = 0;

          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }

          return result;
        }
      };
      var fnUntyped = {
        arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function flattenChunks(chunks) {
          return [].concat.apply([], chunks);
        }
      }; // Enable/Disable typed arrays use, for testing
      //

      localExports.setTyped = function (on) {
        if (on) {
          localExports.Buf8 = Uint8Array;
          localExports.Buf16 = Uint16Array;
          localExports.Buf32 = Int32Array;
          localExports.assign(localExports, fnTyped);
        } else {
          localExports.Buf8 = Array;
          localExports.Buf16 = Array;
          localExports.Buf32 = Array;
          localExports.assign(localExports, fnUntyped);
        }
      };

      localExports.setTyped(TYPED_OK);
    }, {}],
    217: [function (localRequire, localModule, localExports) {
      // It doesn't worth to make additional optimizationa as in original.
      // Small size is preferable.

      function adler32(adler, buf, len, pos) {
        var s1 = adler & 0xffff | 0,
          s2 = adler >>> 16 & 0xffff | 0,
          n = 0;

        while (len !== 0) {
          // Set limit ~ twice less than 5552, to keep
          // s2 in 31-bits, because we force signed ints.
          // in other case %= will fail.
          n = len > 2000 ? 2000 : len;
          len -= n;

          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);

          s1 %= 65521;
          s2 %= 65521;
        }

        return s1 | s2 << 16 | 0;
      }

      localModule.localExports = adler32;
    }, {}],
    218: [function (localRequire, localModule, localExports) {

      localModule.localExports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,

        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,

        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,

        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,

        /* The deflate compression method */
        Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

      };
    }, {}],
    219: [function (localRequire, localModule, localExports) {
      // So write code to minimize size - no pregenerated tables
      // and array tools dependencies.
      // Use ordinary array, since untyped makes no boost here

      function makeTable() {
        var c,
          table = [];

        for (var n = 0; n < 256; n++) {
          c = n;

          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
          }

          table[n] = c;
        }

        return table;
      } // Create table on load. Just 255 signed longs. Not a problem.


      var crcTable = makeTable();

      function crc32(crc, buf, len, pos) {
        var t = crcTable,
          end = pos + len;
        crc ^= -1;

        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
        }

        return crc ^ -1; // >>> 0;
      }

      localModule.localExports = crc32;
    }, {}],
    220: [function (localRequire, localModule, localExports) {

      var utils = localRequire('../utils/common');
      var trees = localRequire('./trees');
      var adler32 = localRequire('./adler32');
      var crc32 = localRequire('./crc32');
      var msg = localRequire('./messages');
      /* Public constants ==========================================================*/

      /* ===========================================================================*/

      /* Allowed flush values; see deflate() and inflate() below for details */

      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5; //var Z_TREES         = 6;

      /* Return codes for the compression/decompression functions. Negative values
       * are errors, positive values are used for special but normal events.
       */

      var Z_OK = 0;
      var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
      //var Z_ERRNO         = -1;

      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

      var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

      /* compression levels */
      //var Z_NO_COMPRESSION      = 0;
      //var Z_BEST_SPEED          = 1;
      //var Z_BEST_COMPRESSION    = 9;

      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      /* Possible values of the data_type field (though see inflate()) */
      //var Z_BINARY              = 0;
      //var Z_TEXT                = 1;
      //var Z_ASCII               = 1; // = Z_TEXT

      var Z_UNKNOWN = 2;
      /* The deflate compression method */

      var Z_DEFLATED = 8;
      /*============================================================================*/

      var MAX_MEM_LEVEL = 9;
      /* Maximum value for memLevel in deflateInit2 */

      var MAX_WBITS = 15;
      /* 32K LZ77 window */

      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      /* number of length codes, not counting the special END_BLOCK code */

      var LITERALS = 256;
      /* number of literal bytes 0..255 */

      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      /* number of Literal or Length codes, including the END_BLOCK code */

      var D_CODES = 30;
      /* number of distance codes */

      var BL_CODES = 19;
      /* number of codes used to transfer the bit lengths */

      var HEAP_SIZE = 2 * L_CODES + 1;
      /* maximum heap size */

      var MAX_BITS = 15;
      /* All codes must not exceed MAX_BITS bits */

      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 0x20;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      /* block not completed, need more input or more output */

      var BS_BLOCK_DONE = 2;
      /* block flush performed */

      var BS_FINISH_STARTED = 3;
      /* finish started, need only more output at next deflate */

      var BS_FINISH_DONE = 4;
      /* finish done, accept no more input or output */

      var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }

      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0);
      }

      function zero(buf) {
        var len = buf.length;

        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      /* =========================================================================
       * Flush as much pending output as possible. All deflate() output goes
       * through this function so some applications may wish to modify it
       * to avoid allocating a large strm->output buffer and copying into it.
       * (See also read_buf()).
       */


      function flush_pending(strm) {
        var s = strm.state; //_tr_flush_bits(s);

        var len = s.pending;

        if (len > strm.avail_out) {
          len = strm.avail_out;
        }

        if (len === 0) {
          return;
        }

        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;

        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }

      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

        s.block_start = s.strstart;
        flush_pending(s.strm);
      }

      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }
      /* =========================================================================
       * Put a short in the pending buffer. The 16-bit value is put in MSB order.
       * IN assertion: the stream state is correct and there is enough room in
       * pending_buf.
       */


      function putShortMSB(s, b) {
        //  put_byte(s, (Byte)(b >> 8));
        //  put_byte(s, (Byte)(b & 0xff));
        s.pending_buf[s.pending++] = b >>> 8 & 0xff;
        s.pending_buf[s.pending++] = b & 0xff;
      }
      /* ===========================================================================
       * Read a new buffer from the current input stream, update the adler32
       * and total number of bytes read.  All deflate() input goes through
       * this function so some applications may wish to modify it to avoid
       * allocating a large strm->input buffer and copying from it.
       * (See also flush_pending()).
       */


      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;

        if (len > size) {
          len = size;
        }

        if (len === 0) {
          return 0;
        }

        strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

        utils.arraySet(buf, strm.input, strm.next_in, len, start);

        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }

        strm.next_in += len;
        strm.total_in += len;
        return len;
      }
      /* ===========================================================================
       * Set match_start to the longest match starting at the given string and
       * return its length. Matches shorter or equal to prev_length are discarded,
       * in which case the result is equal to prev_length and match_start is
       * garbage.
       * IN assertions: cur_match is the head of the hash chain for the current
       *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
       * OUT assertion: the match length is not greater than s->lookahead.
       */


      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        /* max hash chain length */

        var scan = s.strstart;
        /* current string */

        var match;
        /* matched string */

        var len;
        /* length of current match */

        var best_len = s.prev_length;
        /* best match length so far */

        var nice_match = s.nice_match;
        /* stop if match long enough */

        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
          /*NIL*/
          ;
        var _win = s.window; // shortcut

        var wmask = s.w_mask;
        var prev = s.prev;
        /* Stop when cur_match becomes <= limit. To simplify the code,
         * we prevent matches with the string of window index 0.
         */

        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
         * It is easy to get rid of this optimization if necessary.
         */
        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

        /* Do not waste too much time if we already have a good match: */

        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        /* Do not look for matches beyond the end of the input. This is necessary
         * to make deflate deterministic.
         */


        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


        do {
          // Assert(cur_match < s->strstart, "no future");
          match = cur_match;
          /* Skip to next match if the match length cannot increase
           * or if the match length is less than 2.  Note that the checks below
           * for insufficient lookahead only occur occasionally for performance
           * reasons.  Therefore uninitialized memory will be accessed, and
           * conditional jumps will be made that depend on those values.
           * However the length of the match is limited to the lookahead, so
           * the output of deflate is not affected by the uninitialized values.
           */

          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          /* The check at best_len-1 can be removed because it will be made
           * again later. (This heuristic is not always a win.)
           * It is not necessary to compare scan[2] and match[2] since they
           * are always equal when the other bytes match, given that
           * the hash keys are equal and that HASH_BITS >= 8.
           */


          scan += 2;
          match++; // Assert(*scan == *match, "match[2]?");

          /* We check for insufficient lookahead only every 8th comparison;
           * the 256th check will be made at strstart+258.
           */

          do {
            /*jshint noempty:false*/
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;

          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;

            if (len >= nice_match) {
              break;
            }

            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

        if (best_len <= s.lookahead) {
          return best_len;
        }

        return s.lookahead;
      }
      /* ===========================================================================
       * Fill the window when the lookahead becomes insufficient.
       * Updates strstart and lookahead.
       *
       * IN assertion: lookahead < MIN_LOOKAHEAD
       * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
       *    At least one byte has been read, or avail_in == 0; reads are
       *    performed for at least two bytes (required for the zip translate_eol
       *    option -- not supported here).
       */


      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

        do {
          more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

          /* Deal with !@#$% 64K limit: */
          //if (sizeof(int) <= 2) {
          //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
          //        more = wsize;
          //
          //  } else if (more == (unsigned)(-1)) {
          //        /* Very unlikely, but possible on 16 bit machine if
          //         * strstart == 0 && lookahead == 1 (input done a byte at time)
          //         */
          //        more--;
          //    }
          //}

          /* If the window is almost full and there is insufficient lookahead,
           * move the upper half to the lower one to make room in the upper half.
           */

          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            /* we now have strstart >= MAX_DIST */

            s.block_start -= _w_size;
            /* Slide the hash table (could be avoided with 32 bit values
             at the expense of memory usage). We slide even when level == 0
             to keep the hash table consistent if we switch back to level > 0
             later. (Using level 0 permanently is not an optimal usage of
             zlib, so we don't care about this pathological case.)
             */

            n = s.hash_size;
            p = n;

            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);

            n = _w_size;
            p = n;

            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
              /* If n is not on any hash chain, prev[n] is garbage but
               * its value will never be used.
               */
            } while (--n);

            more += _w_size;
          }

          if (s.strm.avail_in === 0) {
            break;
          }
          /* If there was no sliding:
           *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
           *    more == window_size - lookahead - strstart
           * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
           * => more >= window_size - 2*WSIZE + 2
           * In the BIG_MEM or MMAP case (not yet supported),
           *   window_size == input_size + MIN_LOOKAHEAD  &&
           *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
           * Otherwise, window_size == 2*WSIZE so more >= 2.
           * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
           */
          //Assert(more >= 2, "more < 2");


          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          /* Initialize the hash value now that we have some input: */

          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
            //        Call update_hash() MIN_MATCH-3 more times
            //#endif

            while (s.insert) {
              /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;

              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
          /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
           * but this is not important since only literal bytes will be emitted.
           */

        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        /* If the WIN_INIT bytes after the end of the current data have never been
         * written, then zero those bytes in order to avoid memory check reports of
         * the use of uninitialized (or uninitialised as Julian writes) bytes by
         * the longest match routines.  Update the high water mark for the next
         * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
         * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
         */
        //  if (s.high_water < s.window_size) {
        //    var curr = s.strstart + s.lookahead;
        //    var init = 0;
        //
        //    if (s.high_water < curr) {
        //      /* Previous high water mark below current data -- zero WIN_INIT
        //       * bytes or up to end of window, whichever is less.
        //       */
        //      init = s.window_size - curr;
        //      if (init > WIN_INIT)
        //        init = WIN_INIT;
        //      zmemzero(s->window + curr, (unsigned)init);
        //      s->high_water = curr + init;
        //    }
        //    else if (s->high_water < (ulg)curr + WIN_INIT) {
        //      /* High water mark at or above current data, but below current data
        //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
        //       * to end of window, whichever is less.
        //       */
        //      init = (ulg)curr + WIN_INIT - s->high_water;
        //      if (init > s->window_size - s->high_water)
        //        init = s->window_size - s->high_water;
        //      zmemzero(s->window + s->high_water, (unsigned)init);
        //      s->high_water += init;
        //    }
        //  }
        //
        //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
        //    "not enough room for search");

      }
      /* ===========================================================================
       * Copy without compression as much as possible from the input stream, return
       * the current block state.
       * This function does not insert new strings in the dictionary since
       * uncompressible data is probably not useful. This function is used
       * only for the level=0 compression option.
       * NOTE: this function should be optimized to avoid extra copying from
       * window to pending_buf.
       */


      function deflate_stored(s, flush) {
        /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
         * to pending_buf_size, and each stored block has a 5 byte header:
         */
        var max_block_size = 0xffff;

        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        /* Copy as much as possible from input to output: */


        for (; ;) {
          /* Fill the window as much as possible: */
          if (s.lookahead <= 1) {
            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
            //  s->block_start >= (long)s->w_size, "slide too late");
            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
            //        s.block_start >= s.w_size)) {
            //        throw  new Error("slide too late");
            //      }
            fill_window(s);

            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }

            if (s.lookahead === 0) {
              break;
            }
            /* flush the current block */

          } //Assert(s->block_start >= 0L, "block gone");
          //    if (s.block_start < 0) throw new Error("block gone");


          s.strstart += s.lookahead;
          s.lookahead = 0;
          /* Emit a stored block if pending_buf will be full: */

          var max_start = s.block_start + max_block_size;

          if (s.strstart === 0 || s.strstart >= max_start) {
            /* strstart == 0 is possible when wraparound on 16-bit machine */
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            /*** FLUSH_BLOCK(s, 0); ***/

            flush_block_only(s, false);

            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/

          }
          /* Flush if we may have to slide, otherwise block_start may become
           * negative and the data will be gone:
           */


          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);

            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/

          }
        }

        s.insert = 0;

        if (flush === Z_FINISH) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);

          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/


          return BS_FINISH_DONE;
        }

        if (s.strstart > s.block_start) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);

          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/

        }

        return BS_NEED_MORE;
      }
      /* ===========================================================================
       * Compress as much as possible from the input stream, return the current
       * block state.
       * This function does not perform lazy evaluation of matches and inserts
       * new strings in the dictionary only for unmatched strings or for short
       * matches. It is used only for the fast compression options.
       */


      function deflate_fast(s, flush) {
        var hash_head;
        /* head of the hash chain */

        var bflush;
        /* set if current block must be flushed */

        for (; ;) {
          /* Make sure that we always have enough lookahead, except
           * at the end of the input file. We need MAX_MATCH bytes
           * for the next match, plus MIN_MATCH bytes to insert the
           * string following the next match.
           */
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);

            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }

            if (s.lookahead === 0) {
              break;
              /* flush the current block */
            }
          }
          /* Insert the string window[strstart .. strstart+2] in the
           * dictionary, and set hash_head to the head of the hash chain:
           */


          hash_head = 0
            /*NIL*/
            ;

          if (s.lookahead >= MIN_MATCH) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/
          }
          /* Find the longest match, discarding those <= prev_length.
           * At this point we have always match_length < MIN_MATCH
           */


          if (hash_head !== 0
            /*NIL*/
            && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s.match_length = longest_match(s, hash_head);
            /* longest_match() sets match_start */
          }

          if (s.match_length >= MIN_MATCH) {
            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

            /*** _tr_tally_dist(s, s.strstart - s.match_start,
                           s.match_length - MIN_MATCH, bflush); ***/
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */

            if (s.match_length <= s.max_lazy_match
              /*max_insert_length*/
              && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              /* string at strstart already in table */

              do {
                s.strstart++;
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/

                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/

                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                 * always MIN_MATCH bytes ahead.
                 */
              } while (--s.match_length !== 0);

              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
              //                Call UPDATE_HASH() MIN_MATCH-3 more times
              //#endif

              /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
               * matter since it will be recomputed at next deflate call.
               */
            }
          } else {
            /* No match, output a literal byte */
            //Tracevv((stderr,"%c", s.window[s.strstart]));

            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }

          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);

            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/

          }
        }

        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

        if (flush === Z_FINISH) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);

          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/


          return BS_FINISH_DONE;
        }

        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);

          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/

        }

        return BS_BLOCK_DONE;
      }
      /* ===========================================================================
       * Same as above, but achieves better compression. We use a lazy
       * evaluation for matches: a match is finally adopted only if there is
       * no better match at the next window position.
       */


      function deflate_slow(s, flush) {
        var hash_head;
        /* head of hash chain */

        var bflush;
        /* set if current block must be flushed */

        var max_insert;
        /* Process the input block. */

        for (; ;) {
          /* Make sure that we always have enough lookahead, except
           * at the end of the input file. We need MAX_MATCH bytes
           * for the next match, plus MIN_MATCH bytes to insert the
           * string following the next match.
           */
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);

            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }

            if (s.lookahead === 0) {
              break;
            }
            /* flush the current block */

          }
          /* Insert the string window[strstart .. strstart+2] in the
           * dictionary, and set hash_head to the head of the hash chain:
           */


          hash_head = 0
            /*NIL*/
            ;

          if (s.lookahead >= MIN_MATCH) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/
          }
          /* Find the longest match, discarding those <= prev_length.
           */


          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;

          if (hash_head !== 0
            /*NIL*/
            && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
            /*MAX_DIST(s)*/
          ) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s.match_length = longest_match(s, hash_head);
            /* longest_match() sets match_start */

            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096
              /*TOO_FAR*/
            )) {
              /* If prev_match is also MIN_MATCH, match_start is garbage
               * but we will ignore the current match anyway.
               */
              s.match_length = MIN_MATCH - 1;
            }
          }
          /* If there was a match at the previous step and the current
           * match is not better, output the previous match:
           */


          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */
            //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                           s.prev_length - MIN_MATCH, bflush);***/

            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */

            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;

            do {
              if (++s.strstart <= max_insert) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
              }
            } while (--s.prev_length !== 0);

            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;

            if (bflush) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false);

              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
              /***/

            }
          } else if (s.match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            //Tracevv((stderr,"%c", s->window[s->strstart-1]));

            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

            if (bflush) {
              /*** FLUSH_BLOCK_ONLY(s, 0) ***/
              flush_block_only(s, false);
              /***/
            }

            s.strstart++;
            s.lookahead--;

            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        } //Assert (flush != Z_NO_FLUSH, "no flush?");


        if (s.match_available) {
          //Tracevv((stderr,"%c", s->window[s->strstart-1]));

          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }

        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

        if (flush === Z_FINISH) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);

          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/


          return BS_FINISH_DONE;
        }

        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);

          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/

        }

        return BS_BLOCK_DONE;
      }
      /* ===========================================================================
       * For Z_RLE, simply look for runs of bytes, generate matches only of distance
       * one.  Do not maintain a hash table.  (It will be regenerated if this run of
       * deflate switches away from Z_RLE.)
       */


      function deflate_rle(s, flush) {
        var bflush;
        /* set if current block must be flushed */

        var prev;
        /* byte at distance one to match */

        var scan, strend;
        /* scan goes up to strend for length of run */

        var _win = s.window;

        for (; ;) {
          /* Make sure that we always have enough lookahead, except
           * at the end of the input file. We need MAX_MATCH bytes
           * for the longest run, plus one for the unrolled loop.
           */
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);

            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }

            if (s.lookahead === 0) {
              break;
            }
            /* flush the current block */

          }
          /* See how many times the previous byte repeats */


          s.match_length = 0;

          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];

            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;

              do {
                /*jshint noempty:false*/
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

              s.match_length = MAX_MATCH - (strend - scan);

              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

          }
          /* Emit match if have run of MIN_MATCH or longer, else emit literal */


          if (s.match_length >= MIN_MATCH) {
            //check_match(s, s.strstart, s.strstart - 1, s.match_length);

            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            /* No match, output a literal byte */
            //Tracevv((stderr,"%c", s->window[s->strstart]));

            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }

          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);

            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/

          }
        }

        s.insert = 0;

        if (flush === Z_FINISH) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);

          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/


          return BS_FINISH_DONE;
        }

        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);

          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/

        }

        return BS_BLOCK_DONE;
      }
      /* ===========================================================================
       * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
       * (It will be regenerated if this run of deflate switches away from Huffman.)
       */


      function deflate_huff(s, flush) {
        var bflush;
        /* set if current block must be flushed */

        for (; ;) {
          /* Make sure that we have a literal to write. */
          if (s.lookahead === 0) {
            fill_window(s);

            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }

              break;
              /* flush the current block */
            }
          }
          /* Output a literal byte */


          s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;

          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);

            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/

          }
        }

        s.insert = 0;

        if (flush === Z_FINISH) {
          /*** FLUSH_BLOCK(s, 1); ***/
          flush_block_only(s, true);

          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          /***/


          return BS_FINISH_DONE;
        }

        if (s.last_lit) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);

          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/

        }

        return BS_BLOCK_DONE;
      }
      /* Values for max_lazy_match, good_match and max_chain_length, depending on
       * the desired pack level (0..9). The values given below have been tuned to
       * exclude worst case performance for pathological files. Better values may be
       * found for specific files.
       */


      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }

      var configuration_table;
      configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),
        /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),
        /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),
        /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),
        /* 3 */
        new Config(4, 4, 16, 16, deflate_slow),
        /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),
        /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),
        /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),
        /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),
        /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)
        /* 9 max compression */
      ];
      /* ===========================================================================
       * Initialize the "longest match" routines for a new zlib stream
       */

      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        /*** CLEAR_HASH(s); ***/

        zero(s.head); // Fill with NIL (= 0);

        /* Set the default configuration parameters:
         */

        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }

      function DeflateState() {
        this.strm = null;
        /* pointer back to this zlib stream */

        this.status = 0;
        /* as the name implies */

        this.pending_buf = null;
        /* output still pending */

        this.pending_buf_size = 0;
        /* size of pending_buf */

        this.pending_out = 0;
        /* next pending byte to output to the stream */

        this.pending = 0;
        /* nb of bytes in the pending buffer */

        this.wrap = 0;
        /* bit 0 true for zlib, bit 1 true for gzip */

        this.gzhead = null;
        /* gzip header information to write */

        this.gzindex = 0;
        /* where in extra, name, or comment */

        this.method = Z_DEFLATED;
        /* can only be DEFLATED */

        this.last_flush = -1;
        /* value of flush param for previous deflate call */

        this.w_size = 0;
        /* LZ77 window size (32K by default) */

        this.w_bits = 0;
        /* log2(w_size)  (8..16) */

        this.w_mask = 0;
        /* w_size - 1 */

        this.window = null;
        /* Sliding window. Input bytes are read into the second half of the window,
         * and move to the first half later to keep a dictionary of at least wSize
         * bytes. With this organization, matches are limited to a distance of
         * wSize-MAX_MATCH bytes, but this ensures that IO is always
         * performed with a length multiple of the block size.
         */

        this.window_size = 0;
        /* Actual size of window: 2*wSize, except when the user input buffer
         * is directly used as sliding window.
         */

        this.prev = null;
        /* Link to older string with same hash index. To limit the size of this
         * array to 64K, this link is maintained only for the last 32K strings.
         * An index in this array is thus a window index modulo 32K.
         */

        this.head = null;
        /* Heads of the hash chains or NIL. */

        this.ins_h = 0;
        /* hash index of string to be inserted */

        this.hash_size = 0;
        /* number of elements in hash table */

        this.hash_bits = 0;
        /* log2(hash_size) */

        this.hash_mask = 0;
        /* hash_size-1 */

        this.hash_shift = 0;
        /* Number of bits by which ins_h must be shifted at each input
         * step. It must be such that after MIN_MATCH steps, the oldest
         * byte no longer takes part in the hash key, that is:
         *   hash_shift * MIN_MATCH >= hash_bits
         */

        this.block_start = 0;
        /* Window position at the beginning of the current output block. Gets
         * negative when the window is moved backwards.
         */

        this.match_length = 0;
        /* length of best match */

        this.prev_match = 0;
        /* previous match */

        this.match_available = 0;
        /* set if previous match exists */

        this.strstart = 0;
        /* start of string to insert */

        this.match_start = 0;
        /* start of matching string */

        this.lookahead = 0;
        /* number of valid bytes ahead in window */

        this.prev_length = 0;
        /* Length of the best match at previous step. Matches not greater than this
         * are discarded. This is used in the lazy match evaluation.
         */

        this.max_chain_length = 0;
        /* To speed up deflation, hash chains are never searched beyond this
         * length.  A higher limit improves compression ratio but degrades the
         * speed.
         */

        this.max_lazy_match = 0;
        /* Attempt to find a better match only when the current match is strictly
         * smaller than this value. This mechanism is used only for compression
         * levels >= 4.
         */
        // That's alias to max_lazy_match, don't use directly
        //this.max_insert_length = 0;

        /* Insert new strings in the hash table only if the match length is not
         * greater than this length. This saves time but degrades compression.
         * max_insert_length is used only for compression levels <= 3.
         */

        this.level = 0;
        /* compression level (1..9) */

        this.strategy = 0;
        /* favor or force Huffman coding*/

        this.good_match = 0;
        /* Use a faster search when the previous match is longer than this */

        this.nice_match = 0;
        /* Stop searching when current match exceeds this */

        /* used by trees.c: */

        /* Didn't use ct_data typedef below to suppress compiler warning */
        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
        // Use flat array of DOUBLE size, with interleaved fata,
        // because JS does not support effective

        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        /* desc. for literal tree */

        this.d_desc = null;
        /* desc. for distance tree */

        this.bl_desc = null;
        /* desc. for bit length tree */
        //ush bl_count[MAX_BITS+1];

        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        /* number of codes at each bit length for an optimal tree */
        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

        this.heap = new utils.Buf16(2 * L_CODES + 1);
        /* heap used to build the Huffman trees */

        zero(this.heap);
        this.heap_len = 0;
        /* number of elements in the heap */

        this.heap_max = 0;
        /* element of largest frequency */

        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
         * The same heap array is used to build all trees.
         */

        this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];

        zero(this.depth);
        /* Depth of each subtree used as tie breaker for trees of equal frequency
         */

        this.l_buf = 0;
        /* buffer index for literals or lengths */

        this.lit_bufsize = 0;
        /* Size of match buffer for literals/lengths.  There are 4 reasons for
         * limiting lit_bufsize to 64K:
         *   - frequencies can be kept in 16 bit counters
         *   - if compression is not successful for the first block, all input
         *     data is still in the window so we can still emit a stored block even
         *     when input comes from standard input.  (This can also be done for
         *     all blocks if lit_bufsize is not greater than 32K.)
         *   - if compression is not successful for a file smaller than 64K, we can
         *     even emit a stored file instead of a stored block (saving 5 bytes).
         *     This is applicable only for zip (not gzip or zlib).
         *   - creating new Huffman trees less frequently may not provide fast
         *     adaptation to changes in the input data statistics. (Take for
         *     example a binary file with poorly compressible code followed by
         *     a highly compressible string table.) Smaller buffer sizes give
         *     fast adaptation but have of course the overhead of transmitting
         *     trees more frequently.
         *   - I can't count above 4
         */

        this.last_lit = 0;
        /* running index in l_buf */

        this.d_buf = 0;
        /* Buffer index for distances. To simplify the code, d_buf and l_buf have
         * the same number of elements. To use different lengths, an extra flag
         * array would be necessary.
         */

        this.opt_len = 0;
        /* bit length of current block with optimal trees */

        this.static_len = 0;
        /* bit length of current block with static trees */

        this.matches = 0;
        /* number of string matches in current block */

        this.insert = 0;
        /* bytes at end of window left to insert */

        this.bi_buf = 0;
        /* Output buffer. bits are inserted starting at the bottom (least
         * significant bits).
         */

        this.bi_valid = 0;
        /* Number of valid bits in bi_buf.  All bits above the last valid bit
         * are always zero.
         */
        // Used for window memory init. We safely ignore it for JS. That makes
        // sense only for pointers and memory check tools.
        //this.high_water = 0;

        /* High water mark offset in window for initialized bytes -- bytes above
         * this are set to zero in order to avoid memory check warnings when
         * longest match routines access bytes past the input.  This is then
         * updated to the new high water mark.
         */
      }

      function deflateResetKeep(strm) {
        var s;

        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }

        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;

        if (s.wrap < 0) {
          s.wrap = -s.wrap;
          /* was made negative by deflate(..., Z_FINISH); */
        }

        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
          : 1; // adler32(0, Z_NULL, 0)

        s.last_flush = Z_NO_FLUSH;

        trees._tr_init(s);

        return Z_OK;
      }

      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);

        if (ret === Z_OK) {
          lm_init(strm.state);
        }

        return ret;
      }

      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }

        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }

        strm.state.gzhead = head;
        return Z_OK;
      }

      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          // === Z_NULL
          return Z_STREAM_ERROR;
        }

        var wrap = 1;

        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }

        if (windowBits < 0) {
          /* suppress zlib wrapper */
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          /* write gzip wrapper instead */

          windowBits -= 16;
        }

        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }

        if (windowBits === 8) {
          windowBits = 9;
        }
        /* until 256-byte window bug fixed */


        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.
        //s.high_water = 0;  /* nothing written to s->window yet */

        s.lit_bufsize = 1 << memLevel + 6;
        /* 16K elements by default */

        s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
        //s->pending_buf = (uchf *) overlay;

        s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
        //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

        s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      }

      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }

      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val; // for gzip header write only

        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }

        s = strm.state;

        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }

        s.strm = strm;
        /* just in case */

        old_flush = s.last_flush;
        s.last_flush = flush;
        /* Write the header */

        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            // GZIP header
            strm.adler = 0; //crc32(0L, Z_NULL, 0);

            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);

            if (!s.gzhead) {
              // s->gzhead == Z_NULL
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
              put_byte(s, s.gzhead.time & 0xff);
              put_byte(s, s.gzhead.time >> 8 & 0xff);
              put_byte(s, s.gzhead.time >> 16 & 0xff);
              put_byte(s, s.gzhead.time >> 24 & 0xff);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 0xff);

              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 0xff);
                put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
              }

              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }

              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else // DEFLATE header
          {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;

            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }

            header |= level_flags << 6;

            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }

            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            /* Save the adler32 of the preset dictionary: */

            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 0xffff);
            }

            strm.adler = 1; // adler32(0L, Z_NULL, 0);
          }
        } //#ifdef GZIP


        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra
            /* != Z_NULL*/
          ) {
            beg = s.pending;
            /* start of bytes to update crc */

            while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }

                flush_pending(strm);
                beg = s.pending;

                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }

              put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
              s.gzindex++;
            }

            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }

        if (s.status === NAME_STATE) {
          if (s.gzhead.name
            /* != Z_NULL*/
          ) {
            beg = s.pending;
            /* start of bytes to update crc */
            //int val;

            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }

                flush_pending(strm);
                beg = s.pending;

                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              } // JS specific: little magic to add zero terminator to end of string


              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
              } else {
                val = 0;
              }

              put_byte(s, val);
            } while (val !== 0);

            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }

        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment
            /* != Z_NULL*/
          ) {
            beg = s.pending;
            /* start of bytes to update crc */
            //int val;

            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }

                flush_pending(strm);
                beg = s.pending;

                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              } // JS specific: little magic to add zero terminator to end of string


              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
              } else {
                val = 0;
              }

              put_byte(s, val);
            } while (val !== 0);

            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }

        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }

            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 0xff);
              put_byte(s, strm.adler >> 8 & 0xff);
              strm.adler = 0; //crc32(0L, Z_NULL, 0);

              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        } //#endif

        /* Flush as much pending output as possible */


        if (s.pending !== 0) {
          flush_pending(strm);

          if (strm.avail_out === 0) {
            /* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */
            s.last_flush = -1;
            return Z_OK;
          }
          /* Make sure there is something to do and avoid duplicate consecutive
           * flushes. For repeated and useless calls with Z_FINISH, we keep
           * returning Z_STREAM_END instead of Z_BUF_ERROR.
           */

        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        /* User must not provide more input after the first FINISH: */


        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        /* Start a new block or continue the current one.
         */


        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }

          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              /* avoid BUF_ERROR next call, see above */
            }

            return Z_OK;
            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */
          }

          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s);
            } else if (flush !== Z_BLOCK) {
              /* FULL_FLUSH or SYNC_FLUSH */
              trees._tr_stored_block(s, 0, 0, false);
              /* For a full flush, this empty block will be recognized
               * as a special marker by inflate_sync().
               */


              if (flush === Z_FULL_FLUSH) {
                /*** CLEAR_HASH(s); ***/

                /* forget history */
                zero(s.head); // Fill with NIL (= 0);

                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }

            flush_pending(strm);

            if (strm.avail_out === 0) {
              s.last_flush = -1;
              /* avoid BUF_ERROR at next call, see above */

              return Z_OK;
            }
          }
        } //Assert(strm->avail_out > 0, "bug2");
        //if (strm.avail_out <= 0) { throw new Error("bug2");}


        if (flush !== Z_FINISH) {
          return Z_OK;
        }

        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        /* Write the trailer */


        if (s.wrap === 2) {
          put_byte(s, strm.adler & 0xff);
          put_byte(s, strm.adler >> 8 & 0xff);
          put_byte(s, strm.adler >> 16 & 0xff);
          put_byte(s, strm.adler >> 24 & 0xff);
          put_byte(s, strm.total_in & 0xff);
          put_byte(s, strm.total_in >> 8 & 0xff);
          put_byte(s, strm.total_in >> 16 & 0xff);
          put_byte(s, strm.total_in >> 24 & 0xff);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }

        flush_pending(strm);
        /* If avail_out is zero, the application will call deflate again
         * to flush the rest.
         */

        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        /* write the trailer only once! */


        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      }

      function deflateEnd(strm) {
        var status;

        if (!strm
          /*== Z_NULL*/
          || !strm.state
          /*== Z_NULL*/
        ) {
          return Z_STREAM_ERROR;
        }

        status = strm.state.status;

        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }

        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      }
      /* =========================================================================
       * Initializes the compression dictionary from the given byte
       * sequence without producing any compressed output.
       */


      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;

        if (!strm
          /*== Z_NULL*/
          || !strm.state
          /*== Z_NULL*/
        ) {
          return Z_STREAM_ERROR;
        }

        s = strm.state;
        wrap = s.wrap;

        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        /* when using zlib wrappers, compute Adler-32 for provided dictionary */


        if (wrap === 1) {
          /* adler32(strm->adler, dictionary, dictLength); */
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }

        s.wrap = 0;
        /* avoid computing Adler-32 in read_buf */

        /* if dictionary would fill window, just replace the history */

        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            /* already empty otherwise */

            /*** CLEAR_HASH(s); ***/
            zero(s.head); // Fill with NIL (= 0);

            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          /* use the tail */
          // dictionary = dictionary.slice(dictLength - s.w_size);


          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        /* insert dictionary into window and hash */


        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);

        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);

          do {
            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);

          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }

        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      }

      localExports.deflateInit = deflateInit;
      localExports.deflateInit2 = deflateInit2;
      localExports.deflateReset = deflateReset;
      localExports.deflateResetKeep = deflateResetKeep;
      localExports.deflateSetHeader = deflateSetHeader;
      localExports.deflate = deflate;
      localExports.deflateEnd = deflateEnd;
      localExports.deflateSetDictionary = deflateSetDictionary;
      localExports.deflateInfo = 'pako deflate (from Nodeca project)';
      /* Not implemented
      exports.deflateBound = deflateBound;
      exports.deflateCopy = deflateCopy;
      exports.deflateParams = deflateParams;
      exports.deflatePending = deflatePending;
      exports.deflatePrime = deflatePrime;
      exports.deflateTune = deflateTune;
      */
    }, {
      "../utils/common": 216,
      "./adler32": 217,
      "./crc32": 219,
      "./messages": 224,
      "./trees": 225
    }],
    221: [function (localRequire, localModule, localExports) {

      var BAD = 30;
      /* got a data error -- remain here until reset */

      var TYPE = 12;
      /* i: waiting for type bits, including last-flag bit */

      /*
         Decode literal, length, and distance codes and write out the resulting
         literal and match bytes until either not enough input or output is
         available, an end-of-block is encountered, or a data error is encountered.
         When large enough input and output buffers are supplied to inflate(), for
         example, a 16K input buffer and a 64K output buffer, more than 95% of the
         inflate execution time is spent in this routine.
      
         Entry assumptions:
      
              state.mode === LEN
              strm.avail_in >= 6
              strm.avail_out >= 258
              start >= strm.avail_out
              state.bits < 8
      
         On return, state.mode is one of:
      
              LEN -- ran out of enough output space or enough available input
              TYPE -- reached end of block code, inflate() to interpret next block
              BAD -- error in block data
      
         Notes:
      
          - The maximum input bits used by a length/distance pair is 15 bits for the
            length code, 5 bits for the length extra, 15 bits for the distance code,
            and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
            Therefore if strm.avail_in >= 6, then there is enough input to avoid
            checking for available input while decoding.
      
          - The maximum bytes that a single length/distance pair can output is 258
            bytes, which is the maximum length that can be coded.  inflate_fast()
            requires strm.avail_out >= 258 for each loop to avoid checking for
            output space.
       */

      localModule.localExports = function inflate_fast(strm, start) {
        var state;

        var _in;
        /* local strm.input */


        var last;
        /* have enough input while in < last */

        var _out;
        /* local strm.output */


        var beg;
        /* inflate()'s initial strm.output */

        var end;
        /* while out < end, enough space available */
        //#ifdef INFLATE_STRICT

        var dmax;
        /* maximum distance from zlib header */
        //#endif

        var wsize;
        /* window size or zero if not using window */

        var whave;
        /* valid bytes in the window */

        var wnext;
        /* window write index */
        // Use `s_window` instead `window`, avoid conflict with instrumentation tools

        var s_window;
        /* allocated sliding window, if wsize != 0 */

        var hold;
        /* local strm.hold */

        var bits;
        /* local strm.bits */

        var lcode;
        /* local strm.lencode */

        var dcode;
        /* local strm.distcode */

        var lmask;
        /* mask for first level of length codes */

        var dmask;
        /* mask for first level of distance codes */

        var here;
        /* retrieved table entry */

        var op;
        /* code bits, operation, extra bits, or */

        /*  window position, window bytes to copy */

        var len;
        /* match length, unused bytes */

        var dist;
        /* match distance */

        var from;
        /* where to copy match from */

        var from_source;
        var input, output; // JS specific, because we have no pointers

        /* copy state to local variables */

        state = strm.state; //here = state.here;

        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

        dmax = state.dmax; //#endif

        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        /* decode literals and length/distances until end-of-block or not enough
           input data or output space */

        top: do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }

          here = lcode[hold & lmask];

          dolen: for (; ;) {
            // Goto emulation
            op = here >>> 24
              /*here.bits*/
              ;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff
              /*here.op*/
              ;

            if (op === 0) {
              /* literal */
              //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
              //        "inflate:         literal '%c'\n" :
              //        "inflate:         literal 0x%02x\n", here.val));
              output[_out++] = here & 0xffff
                /*here.val*/
                ;
            } else if (op & 16) {
              /* length base */
              len = here & 0xffff
                /*here.val*/
                ;
              op &= 15;
              /* number of extra bits */

              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }

                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              } //Tracevv((stderr, "inflate:         length %u\n", len));


              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }

              here = dcode[hold & dmask];

              dodist: for (; ;) {
                // goto emulation
                op = here >>> 24
                  /*here.bits*/
                  ;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 0xff
                  /*here.op*/
                  ;

                if (op & 16) {
                  /* distance base */
                  dist = here & 0xffff
                    /*here.val*/
                    ;
                  op &= 15;
                  /* number of extra bits */

                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;

                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }

                  dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

                  if (dist > dmax) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  } //#endif


                  hold >>>= op;
                  bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

                  op = _out - beg;
                  /* max distance in output */

                  if (dist > op) {
                    /* see if copy from window */
                    op = dist - op;
                    /* distance back in window */

                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = 'invalid distance too far back';
                        state.mode = BAD;
                        break top;
                      } // (!) This block is disabled in zlib defailts,
                      // don't enable it for binary compatibility
                      //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                      //                if (len <= op - whave) {
                      //                  do {
                      //                    output[_out++] = 0;
                      //                  } while (--len);
                      //                  continue top;
                      //                }
                      //                len -= op - whave;
                      //                do {
                      //                  output[_out++] = 0;
                      //                } while (--op > whave);
                      //                if (op === 0) {
                      //                  from = _out - dist;
                      //                  do {
                      //                    output[_out++] = output[from++];
                      //                  } while (--len);
                      //                  continue top;
                      //                }
                      //#endif

                    }

                    from = 0; // window index

                    from_source = s_window;

                    if (wnext === 0) {
                      /* very common case */
                      from += wsize - op;

                      if (op < len) {
                        /* some from window */
                        len -= op;

                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);

                        from = _out - dist;
                        /* rest from output */

                        from_source = output;
                      }
                    } else if (wnext < op) {
                      /* wrap around window */
                      from += wsize + wnext - op;
                      op -= wnext;

                      if (op < len) {
                        /* some from end of window */
                        len -= op;

                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);

                        from = 0;

                        if (wnext < len) {
                          /* some from start of window */
                          op = wnext;
                          len -= op;

                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);

                          from = _out - dist;
                          /* rest from output */

                          from_source = output;
                        }
                      }
                    } else {
                      /* contiguous in window */
                      from += wnext - op;

                      if (op < len) {
                        /* some from window */
                        len -= op;

                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);

                        from = _out - dist;
                        /* rest from output */

                        from_source = output;
                      }
                    }

                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }

                    if (len) {
                      output[_out++] = from_source[from++];

                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    /* copy direct from output */

                    do {
                      /* minimum length is three */
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);

                    if (len) {
                      output[_out++] = output[from++];

                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  /* 2nd level distance code */
                  here = dcode[(here & 0xffff) + (
                    /*here.val*/
                    hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = 'invalid distance code';
                  state.mode = BAD;
                  break top;
                }

                break; // need to emulate goto via "continue"
              }
            } else if ((op & 64) === 0) {
              /* 2nd level length code */
              here = lcode[(here & 0xffff) + (
                /*here.val*/
                hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              /* end-of-block */
              //Tracevv((stderr, "inflate:         end of block\n"));
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        } while (_in < last && _out < end);
        /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        /* update state and return */

        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }, {}],
    222: [function (localRequire, localModule, localExports) {

      var utils = localRequire('../utils/common');
      var adler32 = localRequire('./adler32');
      var crc32 = localRequire('./crc32');
      var inflate_fast = localRequire('./inffast');
      var inflate_table = localRequire('./inftrees');
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      /* Public constants ==========================================================*/

      /* ===========================================================================*/

      /* Allowed flush values; see deflate() and inflate() below for details */
      //var Z_NO_FLUSH      = 0;
      //var Z_PARTIAL_FLUSH = 1;
      //var Z_SYNC_FLUSH    = 2;
      //var Z_FULL_FLUSH    = 3;

      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      /* Return codes for the compression/decompression functions. Negative values
       * are errors, positive values are used for special but normal events.
       */

      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

      /* The deflate compression method */

      var Z_DEFLATED = 8;
      /* STATES ====================================================================*/

      /* ===========================================================================*/

      var HEAD = 1;
      /* i: waiting for magic header */

      var FLAGS = 2;
      /* i: waiting for method and flags (gzip) */

      var TIME = 3;
      /* i: waiting for modification time (gzip) */

      var OS = 4;
      /* i: waiting for extra flags and operating system (gzip) */

      var EXLEN = 5;
      /* i: waiting for extra length (gzip) */

      var EXTRA = 6;
      /* i: waiting for extra bytes (gzip) */

      var NAME = 7;
      /* i: waiting for end of file name (gzip) */

      var COMMENT = 8;
      /* i: waiting for end of comment (gzip) */

      var HCRC = 9;
      /* i: waiting for header crc (gzip) */

      var DICTID = 10;
      /* i: waiting for dictionary check value */

      var DICT = 11;
      /* waiting for inflateSetDictionary() call */

      var TYPE = 12;
      /* i: waiting for type bits, including last-flag bit */

      var TYPEDO = 13;
      /* i: same, but skip check to exit inflate on new block */

      var STORED = 14;
      /* i: waiting for stored size (length and complement) */

      var COPY_ = 15;
      /* i/o: same as COPY below, but only first time in */

      var COPY = 16;
      /* i/o: waiting for input or output to copy stored block */

      var TABLE = 17;
      /* i: waiting for dynamic block table lengths */

      var LENLENS = 18;
      /* i: waiting for code length code lengths */

      var CODELENS = 19;
      /* i: waiting for length/lit and distance code lengths */

      var LEN_ = 20;
      /* i: same as LEN below, but only first time in */

      var LEN = 21;
      /* i: waiting for length/lit/eob code */

      var LENEXT = 22;
      /* i: waiting for length extra bits */

      var DIST = 23;
      /* i: waiting for distance code */

      var DISTEXT = 24;
      /* i: waiting for distance extra bits */

      var MATCH = 25;
      /* o: waiting for output space to copy string */

      var LIT = 26;
      /* o: waiting for output space to write literal */

      var CHECK = 27;
      /* i: waiting for 32-bit check value */

      var LENGTH = 28;
      /* i: waiting for 32-bit length (gzip) */

      var DONE = 29;
      /* finished check, done -- remain here until reset */

      var BAD = 30;
      /* got a data error -- remain here until reset */

      var MEM = 31;
      /* got an inflate() memory error -- remain here until reset */

      var SYNC = 32;
      /* looking for synchronization bytes to restart inflate() */

      /* ===========================================================================*/

      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

      var MAX_WBITS = 15;
      /* 32K LZ77 window */

      var DEF_WBITS = MAX_WBITS;

      function zswap32(q) {
        return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
      }

      function InflateState() {
        this.mode = 0;
        /* current inflate mode */

        this.last = false;
        /* true if processing last block */

        this.wrap = 0;
        /* bit 0 true for zlib, bit 1 true for gzip */

        this.havedict = false;
        /* true if dictionary provided */

        this.flags = 0;
        /* gzip header method and flags (0 if zlib) */

        this.dmax = 0;
        /* zlib header max distance (INFLATE_STRICT) */

        this.check = 0;
        /* protected copy of check value */

        this.total = 0;
        /* protected copy of output count */
        // TODO: may be {}

        this.head = null;
        /* where to save gzip header information */

        /* sliding window */

        this.wbits = 0;
        /* log base 2 of requested window size */

        this.wsize = 0;
        /* window size or zero if not using window */

        this.whave = 0;
        /* valid bytes in the window */

        this.wnext = 0;
        /* window write index */

        this.window = null;
        /* allocated sliding window, if needed */

        /* bit accumulator */

        this.hold = 0;
        /* input bit accumulator */

        this.bits = 0;
        /* number of bits in "in" */

        /* for string and stored block copying */

        this.length = 0;
        /* literal or length of data to copy */

        this.offset = 0;
        /* distance back to copy string from */

        /* for table and code decoding */

        this.extra = 0;
        /* extra bits needed */

        /* fixed and dynamic code tables */

        this.lencode = null;
        /* starting table for length/literal codes */

        this.distcode = null;
        /* starting table for distance codes */

        this.lenbits = 0;
        /* index bits for lencode */

        this.distbits = 0;
        /* index bits for distcode */

        /* dynamic table building */

        this.ncode = 0;
        /* number of code length code lengths */

        this.nlen = 0;
        /* number of length code lengths */

        this.ndist = 0;
        /* number of distance code lengths */

        this.have = 0;
        /* number of code lengths in lens[] */

        this.next = null;
        /* next available space in codes[] */

        this.lens = new utils.Buf16(320);
        /* temporary storage for code lengths */

        this.work = new utils.Buf16(288);
        /* work area for code table building */

        /*
         because we don't have pointers in js, we use lencode and distcode directly
         as buffers so we don't need codes
        */
        //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

        this.lendyn = null;
        /* dynamic table for length/literal codes (JS specific) */

        this.distdyn = null;
        /* dynamic table for distance codes (JS specific) */

        this.sane = 0;
        /* if false, allow invalid distance too far */

        this.back = 0;
        /* bits back of last unprocessed length/lit */

        this.was = 0;
        /* initial length of match */
      }

      function inflateResetKeep(strm) {
        var state;

        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }

        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = '';
        /*Z_NULL*/

        if (state.wrap) {
          /* to support ill-conceived Java test suite */
          strm.adler = state.wrap & 1;
        }

        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null
          /*Z_NULL*/
          ;
        state.hold = 0;
        state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1; //Tracev((stderr, "inflate: reset\n"));

        return Z_OK;
      }

      function inflateReset(strm) {
        var state;

        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }

        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      }

      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        /* get the state */

        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }

        state = strm.state;
        /* extract wrap request from windowBits parameter */

        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;

          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        /* set number of window bits, free window if different */


        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }

        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        /* update state and reset the rest of it */


        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }

      function inflateInit2(strm, windowBits) {
        var ret;
        var state;

        if (!strm) {
          return Z_STREAM_ERROR;
        } //strm.msg = Z_NULL;                 /* in case we return an error */


        state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
        //Tracev((stderr, "inflate: allocated\n"));

        strm.state = state;
        state.window = null
          /*Z_NULL*/
          ;
        ret = inflateReset2(strm, windowBits);

        if (ret !== Z_OK) {
          strm.state = null
            /*Z_NULL*/
            ;
        }

        return ret;
      }

      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
      }
      /*
       Return state with length and distance decoding tables and index sizes set to
       fixed code decoding.  Normally this returns fixed tables from inffixed.h.
       If BUILDFIXED is defined, then instead this routine builds the tables the
       first time it's called, and returns those tables the first time and
       thereafter.  This reduces the size of the code by about 2K bytes, in
       exchange for a little execution time.  However, BUILDFIXED should not be
       used for threaded applications, since the rewriting of the tables and virgin
       may not be thread-safe.
       */


      var virgin = true;
      var lenfix, distfix; // We have no pointers in JS, so keep tables separate

      function fixedtables(state) {
        /* build fixed huffman tables if first call (may not be thread safe) */
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          /* literal/length table */

          sym = 0;

          while (sym < 144) {
            state.lens[sym++] = 8;
          }

          while (sym < 256) {
            state.lens[sym++] = 9;
          }

          while (sym < 280) {
            state.lens[sym++] = 7;
          }

          while (sym < 288) {
            state.lens[sym++] = 8;
          }

          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
            bits: 9
          });
          /* distance table */

          sym = 0;

          while (sym < 32) {
            state.lens[sym++] = 5;
          }

          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
            bits: 5
          });
          /* do this just once */

          virgin = false;
        }

        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }
      /*
       Update the window with the last wsize (normally 32K) bytes written before
       returning.  If window does not exist yet, create it.  This is only called
       when a window is already in use, or when output has been written during this
       inflate call, but the end of the deflate stream has not been reached yet.
       It is also called to create a window for dictionary data when a dictionary
       is loaded.
      
       Providing output buffers larger than 32K to inflate() should provide a speed
       advantage, since only the last 32K of output is copied to the sliding window
       upon return from inflate(), and since all distances after the first 32K of
       output will fall in the output data, making match copies simpler and faster.
       The advantage may be dependent on the size of the processor's data caches.
       */


      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        /* if it hasn't been done already, allocate space for the window */

        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize);
        }
        /* copy state->wsize or less output bytes into the circular window */


        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;

          if (dist > copy) {
            dist = copy;
          } //zmemcpy(state->window + state->wnext, end - copy, dist);


          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;

          if (copy) {
            //zmemcpy(state->window, end - copy, copy);
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;

            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }

            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }

        return 0;
      }

      function inflate(strm, flush) {
        var state;
        var input, output; // input/output buffers

        var next;
        /* next input INDEX */

        var put;
        /* next output INDEX */

        var have, left;
        /* available input and output */

        var hold;
        /* bit buffer */

        var bits;
        /* bits in bit buffer */

        var _in, _out;
        /* save starting available input and output */


        var copy;
        /* number of stored or match bytes to copy */

        var from;
        /* where to copy match bytes from */

        var from_source;
        var here = 0;
        /* current decoding table entry */

        var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
        //var last;                   /* parent table entry */

        var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

        var len;
        /* length to copy for repeats, bits to drop */

        var ret;
        /* return code */

        var hbuf = new utils.Buf8(4);
        /* buffer for gzip header crc calculation */

        var opts;
        var n; // temporary var for NEED_BITS

        var order =
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }

        state = strm.state;

        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        /* skip check */
        //--- LOAD() ---


        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits; //---

        _in = have;
        _out = left;
        ret = Z_OK;

        inf_leave: // goto emulation
        for (; ;) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              } //=== NEEDBITS(16);


              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              if (state.wrap & 2 && hold === 0x8b1f) {
                /* gzip header */
                state.check = 0
                  /*crc32(0L, Z_NULL, 0)*/
                  ; //=== CRC2(state.check, hold);

                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0); //===//
                //=== INITBITS();

                hold = 0;
                bits = 0; //===//

                state.mode = FLAGS;
                break;
              }

              state.flags = 0;
              /* expect zlib header */

              if (state.head) {
                state.head.done = false;
              }

              if (!(state.wrap & 1) ||
                /* check if zlib header allowed */
                (((hold & 0xff) <<
                  /*BITS(8)*/
                  8) + (hold >> 8)) % 31) {
                strm.msg = 'incorrect header check';
                state.mode = BAD;
                break;
              }

              if ((hold & 0x0f) !==
                /*BITS(4)*/
                Z_DEFLATED) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
              } //--- DROPBITS(4) ---//


              hold >>>= 4;
              bits -= 4; //---//

              len = (hold & 0x0f) +
                /*BITS(4)*/
                8;

              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = 'invalid window size';
                state.mode = BAD;
                break;
              }

              state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

              strm.adler = state.check = 1
                /*adler32(0L, Z_NULL, 0)*/
                ;
              state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();

              hold = 0;
              bits = 0; //===//

              break;

            case FLAGS:
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              state.flags = hold;

              if ((state.flags & 0xff) !== Z_DEFLATED) {
                strm.msg = 'unknown compression method';
                state.mode = BAD;
                break;
              }

              if (state.flags & 0xe000) {
                strm.msg = 'unknown header flags set';
                state.mode = BAD;
                break;
              }

              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }

              if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0); //===//
              } //=== INITBITS();


              hold = 0;
              bits = 0; //===//

              state.mode = TIME;

            /* falls through */

            case TIME:
              //=== NEEDBITS(32); */
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              if (state.head) {
                state.head.time = hold;
              }

              if (state.flags & 0x0200) {
                //=== CRC4(state.check, hold)
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                hbuf[2] = hold >>> 16 & 0xff;
                hbuf[3] = hold >>> 24 & 0xff;
                state.check = crc32(state.check, hbuf, 4, 0); //===
              } //=== INITBITS();


              hold = 0;
              bits = 0; //===//

              state.mode = OS;

            /* falls through */

            case OS:
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              if (state.head) {
                state.head.xflags = hold & 0xff;
                state.head.os = hold >> 8;
              }

              if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0); //===//
              } //=== INITBITS();


              hold = 0;
              bits = 0; //===//

              state.mode = EXLEN;

            /* falls through */

            case EXLEN:
              if (state.flags & 0x0400) {
                //=== NEEDBITS(16); */
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//


                state.length = hold;

                if (state.head) {
                  state.head.extra_len = hold;
                }

                if (state.flags & 0x0200) {
                  //=== CRC2(state.check, hold);
                  hbuf[0] = hold & 0xff;
                  hbuf[1] = hold >>> 8 & 0xff;
                  state.check = crc32(state.check, hbuf, 2, 0); //===//
                } //=== INITBITS();


                hold = 0;
                bits = 0; //===//
              } else if (state.head) {
                state.head.extra = null
                  /*Z_NULL*/
                  ;
              }

              state.mode = EXTRA;

            /* falls through */

            case EXTRA:
              if (state.flags & 0x0400) {
                copy = state.length;

                if (copy > have) {
                  copy = have;
                }

                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;

                    if (!state.head.extra) {
                      // Use untyped array for more conveniend processing later
                      state.head.extra = new Array(state.head.extra_len);
                    }

                    utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len); //zmemcpy(state.head.extra + len, next,
                    //        len + copy > state.head.extra_max ?
                    //        state.head.extra_max - len : copy);
                  }

                  if (state.flags & 0x0200) {
                    state.check = crc32(state.check, input, copy, next);
                  }

                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }

                if (state.length) {
                  break inf_leave;
                }
              }

              state.length = 0;
              state.mode = NAME;

            /* falls through */

            case NAME:
              if (state.flags & 0x0800) {
                if (have === 0) {
                  break inf_leave;
                }

                copy = 0;

                do {
                  // TODO: 2 or 1 bytes?
                  len = input[next + copy++];
                  /* use constant limit because in js we should not preallocate memory */

                  if (state.head && len && state.length < 65536
                    /*state.head.name_max*/
                  ) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);

                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }

                have -= copy;
                next += copy;

                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }

              state.length = 0;
              state.mode = COMMENT;

            /* falls through */

            case COMMENT:
              if (state.flags & 0x1000) {
                if (have === 0) {
                  break inf_leave;
                }

                copy = 0;

                do {
                  len = input[next + copy++];
                  /* use constant limit because in js we should not preallocate memory */

                  if (state.head && len && state.length < 65536
                    /*state.head.comm_max*/
                  ) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);

                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }

                have -= copy;
                next += copy;

                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }

              state.mode = HCRC;

            /* falls through */

            case HCRC:
              if (state.flags & 0x0200) {
                //=== NEEDBITS(16); */
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//


                if (hold !== (state.check & 0xffff)) {
                  strm.msg = 'header crc mismatch';
                  state.mode = BAD;
                  break;
                } //=== INITBITS();


                hold = 0;
                bits = 0; //===//
              }

              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }

              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;

            case DICTID:
              //=== NEEDBITS(32); */
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              strm.adler = state.check = zswap32(hold); //=== INITBITS();

              hold = 0;
              bits = 0; //===//

              state.mode = DICT;

            /* falls through */

            case DICT:
              if (state.havedict === 0) {
                //--- RESTORE() ---
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits; //---

                return Z_NEED_DICT;
              }

              strm.adler = state.check = 1
                /*adler32(0L, Z_NULL, 0)*/
                ;
              state.mode = TYPE;

            /* falls through */

            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }

            /* falls through */

            case TYPEDO:
              if (state.last) {
                //--- BYTEBITS() ---//
                hold >>>= bits & 7;
                bits -= bits & 7; //---//

                state.mode = CHECK;
                break;
              } //=== NEEDBITS(3); */


              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              state.last = hold & 0x01
                /*BITS(1)*/
                ; //--- DROPBITS(1) ---//

              hold >>>= 1;
              bits -= 1; //---//

              switch (hold & 0x03) {
                /*BITS(2)*/
                case 0:
                  /* stored block */
                  //Tracev((stderr, "inflate:     stored block%s\n",
                  //        state.last ? " (last)" : ""));
                  state.mode = STORED;
                  break;

                case 1:
                  /* fixed block */
                  fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
                  //        state.last ? " (last)" : ""));

                  state.mode = LEN_;
                  /* decode codes */

                  if (flush === Z_TREES) {
                    //--- DROPBITS(2) ---//
                    hold >>>= 2;
                    bits -= 2; //---//

                    break inf_leave;
                  }

                  break;

                case 2:
                  /* dynamic block */
                  //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                  //        state.last ? " (last)" : ""));
                  state.mode = TABLE;
                  break;

                case 3:
                  strm.msg = 'invalid block type';
                  state.mode = BAD;
              } //--- DROPBITS(2) ---//


              hold >>>= 2;
              bits -= 2; //---//

              break;

            case STORED:
              //--- BYTEBITS() ---// /* go to byte boundary */
              hold >>>= bits & 7;
              bits -= bits & 7; //---//
              //=== NEEDBITS(32); */

              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
                strm.msg = 'invalid stored block lengths';
                state.mode = BAD;
                break;
              }

              state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
              //        state.length));
              //=== INITBITS();

              hold = 0;
              bits = 0; //===//

              state.mode = COPY_;

              if (flush === Z_TREES) {
                break inf_leave;
              }

            /* falls through */

            case COPY_:
              state.mode = COPY;

            /* falls through */

            case COPY:
              copy = state.length;

              if (copy) {
                if (copy > have) {
                  copy = have;
                }

                if (copy > left) {
                  copy = left;
                }

                if (copy === 0) {
                  break inf_leave;
                } //--- zmemcpy(put, next, copy); ---


                utils.arraySet(output, input, next, copy, put); //---//

                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              } //Tracev((stderr, "inflate:       stored end\n"));


              state.mode = TYPE;
              break;

            case TABLE:
              //=== NEEDBITS(14); */
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//


              state.nlen = (hold & 0x1f) +
                /*BITS(5)*/
                257; //--- DROPBITS(5) ---//

              hold >>>= 5;
              bits -= 5; //---//

              state.ndist = (hold & 0x1f) +
                /*BITS(5)*/
                1; //--- DROPBITS(5) ---//

              hold >>>= 5;
              bits -= 5; //---//

              state.ncode = (hold & 0x0f) +
                /*BITS(4)*/
                4; //--- DROPBITS(4) ---//

              hold >>>= 4;
              bits -= 4; //---//
              //#ifndef PKZIP_BUG_WORKAROUND

              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = 'too many length or distance symbols';
                state.mode = BAD;
                break;
              } //#endif
              //Tracev((stderr, "inflate:       table sizes ok\n"));


              state.have = 0;
              state.mode = LENLENS;

            /* falls through */

            case LENLENS:
              while (state.have < state.ncode) {
                //=== NEEDBITS(3);
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//


                state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
                //--- DROPBITS(3) ---//

                hold >>>= 3;
                bits -= 3; //---//
              }

              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              } // We have separate tables & no pointers. 2 commented lines below not needed.
              //state.next = state.codes;
              //state.lencode = state.next;
              // Switch to use dynamic table


              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;

              if (ret) {
                strm.msg = 'invalid code lengths set';
                state.mode = BAD;
                break;
              } //Tracev((stderr, "inflate:       code lengths ok\n"));


              state.have = 0;
              state.mode = CODELENS;

            /* falls through */

            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ;) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  /*BITS(state.lenbits)*/

                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 0xff;
                  here_val = here & 0xffff;

                  if (here_bits <= bits) {
                    break;
                  } //--- PULLBYTE() ---//


                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8; //---//
                }

                if (here_val < 16) {
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits; //---//

                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    //=== NEEDBITS(here.bits + 2);
                    n = here_bits + 2;

                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//
                    //--- DROPBITS(here.bits) ---//


                    hold >>>= here_bits;
                    bits -= here_bits; //---//

                    if (state.have === 0) {
                      strm.msg = 'invalid bit length repeat';
                      state.mode = BAD;
                      break;
                    }

                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 0x03); //BITS(2);
                    //--- DROPBITS(2) ---//

                    hold >>>= 2;
                    bits -= 2; //---//
                  } else if (here_val === 17) {
                    //=== NEEDBITS(here.bits + 3);
                    n = here_bits + 3;

                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//
                    //--- DROPBITS(here.bits) ---//


                    hold >>>= here_bits;
                    bits -= here_bits; //---//

                    len = 0;
                    copy = 3 + (hold & 0x07); //BITS(3);
                    //--- DROPBITS(3) ---//

                    hold >>>= 3;
                    bits -= 3; //---//
                  } else {
                    //=== NEEDBITS(here.bits + 7);
                    n = here_bits + 7;

                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//
                    //--- DROPBITS(here.bits) ---//


                    hold >>>= here_bits;
                    bits -= here_bits; //---//

                    len = 0;
                    copy = 11 + (hold & 0x7f); //BITS(7);
                    //--- DROPBITS(7) ---//

                    hold >>>= 7;
                    bits -= 7; //---//
                  }

                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }

                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              /* handle error breaks in while */


              if (state.mode === BAD) {
                break;
              }
              /* check for end-of-block code (better have one) */


              if (state.lens[256] === 0) {
                strm.msg = 'invalid code -- missing end-of-block';
                state.mode = BAD;
                break;
              }
              /* build code tables -- note: do not change the lenbits or distbits
                 values here (9 and 6) without reading the comments in inftrees.h
                 concerning the ENOUGH constants, which depend on those values */


              state.lenbits = 9;
              opts = {
                bits: state.lenbits
              };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
              // state.next_index = opts.table_index;

              state.lenbits = opts.bits; // state.lencode = state.next;

              if (ret) {
                strm.msg = 'invalid literal/lengths set';
                state.mode = BAD;
                break;
              }

              state.distbits = 6; //state.distcode.copy(state.codes);
              // Switch to use dynamic table

              state.distcode = state.distdyn;
              opts = {
                bits: state.distbits
              };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
              // state.next_index = opts.table_index;

              state.distbits = opts.bits; // state.distcode = state.next;

              if (ret) {
                strm.msg = 'invalid distances set';
                state.mode = BAD;
                break;
              } //Tracev((stderr, 'inflate:       codes ok\n'));


              state.mode = LEN_;

              if (flush === Z_TREES) {
                break inf_leave;
              }

            /* falls through */

            case LEN_:
              state.mode = LEN;

            /* falls through */

            case LEN:
              if (have >= 6 && left >= 258) {
                //--- RESTORE() ---
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits; //---

                inflate_fast(strm, _out); //--- LOAD() ---

                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits; //---

                if (state.mode === TYPE) {
                  state.back = -1;
                }

                break;
              }

              state.back = 0;

              for (; ;) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                /*BITS(state.lenbits)*/

                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;

                if (here_bits <= bits) {
                  break;
                } //--- PULLBYTE() ---//


                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8; //---//
              }

              if (here_op && (here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;

                for (; ;) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
                    /*BITS(last.bits + last.op)*/
                    last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 0xff;
                  here_val = here & 0xffff;

                  if (last_bits + here_bits <= bits) {
                    break;
                  } //--- PULLBYTE() ---//


                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8; //---//
                } //--- DROPBITS(last.bits) ---//


                hold >>>= last_bits;
                bits -= last_bits; //---//

                state.back += last_bits;
              } //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              state.back += here_bits;
              state.length = here_val;

              if (here_op === 0) {
                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                //        "inflate:         literal '%c'\n" :
                //        "inflate:         literal 0x%02x\n", here.val));
                state.mode = LIT;
                break;
              }

              if (here_op & 32) {
                //Tracevv((stderr, "inflate:         end of block\n"));
                state.back = -1;
                state.mode = TYPE;
                break;
              }

              if (here_op & 64) {
                strm.msg = 'invalid literal/length code';
                state.mode = BAD;
                break;
              }

              state.extra = here_op & 15;
              state.mode = LENEXT;

            /* falls through */

            case LENEXT:
              if (state.extra) {
                //=== NEEDBITS(state.extra);
                n = state.extra;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//


                state.length += hold & (1 << state.extra) - 1
                  /*BITS(state.extra)*/
                  ; //--- DROPBITS(state.extra) ---//

                hold >>>= state.extra;
                bits -= state.extra; //---//

                state.back += state.extra;
              } //Tracevv((stderr, "inflate:         length %u\n", state.length));


              state.was = state.length;
              state.mode = DIST;

            /* falls through */

            case DIST:
              for (; ;) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                /*BITS(state.distbits)*/

                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;

                if (here_bits <= bits) {
                  break;
                } //--- PULLBYTE() ---//


                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8; //---//
              }

              if ((here_op & 0xf0) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;

                for (; ;) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
                    /*BITS(last.bits + last.op)*/
                    last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 0xff;
                  here_val = here & 0xffff;

                  if (last_bits + here_bits <= bits) {
                    break;
                  } //--- PULLBYTE() ---//


                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8; //---//
                } //--- DROPBITS(last.bits) ---//


                hold >>>= last_bits;
                bits -= last_bits; //---//

                state.back += last_bits;
              } //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              state.back += here_bits;

              if (here_op & 64) {
                strm.msg = 'invalid distance code';
                state.mode = BAD;
                break;
              }

              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;

            /* falls through */

            case DISTEXT:
              if (state.extra) {
                //=== NEEDBITS(state.extra);
                n = state.extra;

                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//


                state.offset += hold & (1 << state.extra) - 1
                  /*BITS(state.extra)*/
                  ; //--- DROPBITS(state.extra) ---//

                hold >>>= state.extra;
                bits -= state.extra; //---//

                state.back += state.extra;
              } //#ifdef INFLATE_STRICT


              if (state.offset > state.dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
              } //#endif
              //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


              state.mode = MATCH;

            /* falls through */

            case MATCH:
              if (left === 0) {
                break inf_leave;
              }

              copy = _out - left;

              if (state.offset > copy) {
                /* copy from window */
                copy = state.offset - copy;

                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break;
                  } // (!) This block is disabled in zlib defailts,
                  // don't enable it for binary compatibility
                  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                  //          Trace((stderr, "inflate.c too far\n"));
                  //          copy -= state.whave;
                  //          if (copy > state.length) { copy = state.length; }
                  //          if (copy > left) { copy = left; }
                  //          left -= copy;
                  //          state.length -= copy;
                  //          do {
                  //            output[put++] = 0;
                  //          } while (--copy);
                  //          if (state.length === 0) { state.mode = LEN; }
                  //          break;
                  //#endif

                }

                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }

                if (copy > state.length) {
                  copy = state.length;
                }

                from_source = state.window;
              } else {
                /* copy from output */
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }

              if (copy > left) {
                copy = left;
              }

              left -= copy;
              state.length -= copy;

              do {
                output[put++] = from_source[from++];
              } while (--copy);

              if (state.length === 0) {
                state.mode = LEN;
              }

              break;

            case LIT:
              if (left === 0) {
                break inf_leave;
              }

              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;

            case CHECK:
              if (state.wrap) {
                //=== NEEDBITS(32);
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--; // Use '|' insdead of '+' to make sure that result is signed

                  hold |= input[next++] << bits;
                  bits += 8;
                } //===//


                _out -= left;
                strm.total_out += _out;
                state.total += _out;

                if (_out) {
                  strm.adler = state.check =
                    /*UPDATE(state.check, put - _out, _out);*/
                    state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }

                _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = 'incorrect data check';
                  state.mode = BAD;
                  break;
                } //=== INITBITS();


                hold = 0;
                bits = 0; //===//
                //Tracev((stderr, "inflate:   check matches trailer\n"));
              }

              state.mode = LENGTH;

            /* falls through */

            case LENGTH:
              if (state.wrap && state.flags) {
                //=== NEEDBITS(32);
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }

                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                } //===//


                if (hold !== (state.total & 0xffffffff)) {
                  strm.msg = 'incorrect length check';
                  state.mode = BAD;
                  break;
                } //=== INITBITS();


                hold = 0;
                bits = 0; //===//
                //Tracev((stderr, "inflate:   length matches trailer\n"));
              }

              state.mode = DONE;

            /* falls through */

            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;

            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;

            case MEM:
              return Z_MEM_ERROR;

            case SYNC:
            /* falls through */

            default:
              return Z_STREAM_ERROR;
          }
        } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

        /*
           Return from inflate(), updating the total counts and the check value.
           If there was no progress during the inflate() call, return a buffer
           error.  Call updatewindow() to create and/or update the window state.
           Note: a memory error from inflate() is non-recoverable.
         */
        //--- RESTORE() ---


        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits; //---

        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }

        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;

        if (state.wrap && _out) {
          strm.adler = state.check =
            /*UPDATE(state.check, strm.next_out - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }

        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }

        return ret;
      }

      function inflateEnd(strm) {
        if (!strm || !strm.state
          /*|| strm->zfree == (free_func)0*/
        ) {
          return Z_STREAM_ERROR;
        }

        var state = strm.state;

        if (state.window) {
          state.window = null;
        }

        strm.state = null;
        return Z_OK;
      }

      function inflateGetHeader(strm, head) {
        var state;
        /* check state */

        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }

        state = strm.state;

        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        /* save header structure */


        state.head = head;
        head.done = false;
        return Z_OK;
      }

      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        /* check state */

        if (!strm
          /* == Z_NULL */
          || !strm.state
          /* == Z_NULL */
        ) {
          return Z_STREAM_ERROR;
        }

        state = strm.state;

        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        /* check for correct dictionary identifier */


        if (state.mode === DICT) {
          dictid = 1;
          /* adler32(0, null, 0)*/

          /* dictid = adler32(dictid, dictionary, dictLength); */

          dictid = adler32(dictid, dictionary, dictLength, 0);

          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        /* copy dictionary to window using updatewindow(), which will amend the
         existing dictionary if appropriate */


        ret = updatewindow(strm, dictionary, dictLength, dictLength);

        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }

        state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

        return Z_OK;
      }

      localExports.inflateReset = inflateReset;
      localExports.inflateReset2 = inflateReset2;
      localExports.inflateResetKeep = inflateResetKeep;
      localExports.inflateInit = inflateInit;
      localExports.inflateInit2 = inflateInit2;
      localExports.inflate = inflate;
      localExports.inflateEnd = inflateEnd;
      localExports.inflateGetHeader = inflateGetHeader;
      localExports.inflateSetDictionary = inflateSetDictionary;
      localExports.inflateInfo = 'pako inflate (from Nodeca project)';
      /* Not implemented
      exports.inflateCopy = inflateCopy;
      exports.inflateGetDictionary = inflateGetDictionary;
      exports.inflateMark = inflateMark;
      exports.inflatePrime = inflatePrime;
      exports.inflateSync = inflateSync;
      exports.inflateSyncPoint = inflateSyncPoint;
      exports.inflateUndermine = inflateUndermine;
      */
    }, {
      "../utils/common": 216,
      "./adler32": 217,
      "./crc32": 219,
      "./inffast": 221,
      "./inftrees": 223
    }],
    223: [function (localRequire, localModule, localExports) {

      var utils = localRequire('../utils/common');
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [
        /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
      var lext = [
        /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
      var dbase = [
        /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
      var dext = [
        /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

      localModule.localExports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits; //here = opts.here; /* table entry for duplication */

        var len = 0;
        /* a code's length in bits */

        var sym = 0;
        /* index of code symbols */

        var min = 0,
          max = 0;
        /* minimum and maximum code lengths */

        var root = 0;
        /* number of index bits for root table */

        var curr = 0;
        /* number of index bits for current table */

        var drop = 0;
        /* code bits to drop for sub-table */

        var left = 0;
        /* number of prefix codes available */

        var used = 0;
        /* code entries in table used */

        var huff = 0;
        /* Huffman code */

        var incr;
        /* for incrementing code, index */

        var fill;
        /* index for replicating entries */

        var low;
        /* low bits for current root entry */

        var mask;
        /* mask for low root bits */

        var next;
        /* next available space in table */

        var base = null;
        /* base value table to use */

        var base_index = 0; //  var shoextra;    /* extra bits table to use */

        var end;
        /* use base and extra for symbol > end */

        var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

        var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        /*
         Process a set of code lengths to create a canonical Huffman code.  The
         code lengths are lens[0..codes-1].  Each length corresponds to the
         symbols 0..codes-1.  The Huffman code is generated by first sorting the
         symbols by length from short to long, and retaining the symbol order
         for codes with equal lengths.  Then the code starts with all zero bits
         for the first code of the shortest length, and the codes are integer
         increments for the same length, and zeros are appended as the length
         increases.  For the deflate format, these bits are stored backwards
         from their more natural integer increment ordering, and so when the
         decoding tables are built in the large loop below, the integer codes
         are incremented backwards.
          This routine assumes, but does not check, that all of the entries in
         lens[] are in the range 0..MAXBITS.  The caller must assure this.
         1..MAXBITS is interpreted as that code length.  zero means that that
         symbol does not occur in this code.
          The codes are sorted by computing a count of codes for each length,
         creating from that a table of starting indices for each length in the
         sorted table, and then entering the symbols in order in the sorted
         table.  The sorted table is work[], with that space being provided by
         the caller.
          The length counts are used for other purposes as well, i.e. finding
         the minimum and maximum length codes, determining if there are any
         codes at all, checking for a valid set of lengths, and looking ahead
         at length counts to determine sub-table sizes when building the
         decoding tables.
         */

        /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }

        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        /* bound code lengths, force root to be within code lengths */


        root = bits;

        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }

        if (root > max) {
          root = max;
        }

        if (max === 0) {
          /* no symbols to code at all */
          //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
          //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
          //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
          //table.bits[opts.table_index] = 1;
          //table.val[opts.table_index++] = 0;

          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
          /* no symbols, but wait for decoding to report error */
        }

        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }

        if (root < min) {
          root = min;
        }
        /* check for an over-subscribed or incomplete set of lengths */


        left = 1;

        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];

          if (left < 0) {
            return -1;
          }
          /* over-subscribed */

        }

        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
          /* incomplete set */
        }
        /* generate offsets into symbol table for each length for sorting */


        offs[1] = 0;

        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        /* sort symbols by length, by symbol order within each length */


        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        /*
         Create and fill in decoding tables.  In this loop, the table being
         filled is at next and has curr index bits.  The code being used is huff
         with length len.  That code is converted to an index by dropping drop
         bits off of the bottom.  For codes where len is less than drop + curr,
         those top drop + curr - len bits are incremented through all values to
         fill the table with replicated entries.
          root is the number of index bits for the root table.  When len exceeds
         root, sub-tables are created pointed to by the root entry with an index
         of the low root bits of huff.  This is saved in low to check for when a
         new sub-table should be started.  drop is zero when the root table is
         being filled, and drop is root when sub-tables are being filled.
          When a new sub-table is needed, it is necessary to look ahead in the
         code lengths to determine what size sub-table is needed.  The length
         counts are used for this, and so count[] is decremented as codes are
         entered in the tables.
          used keeps track of how many table entries have been allocated from the
         provided *table space.  It is checked for LENS and DIST tables against
         the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
         the initial root table size constants.  See the comments in inftrees.h
         for more information.
          sym increments through all symbols, and the loop terminates when
         all codes of length max, i.e. all codes, have been processed.  This
         routine permits incomplete codes, so another loop after this one fills
         in the rest of the decoding tables with invalid code markers.
         */

        /* set up for code type */
        // poor man optimization - use if-else instead of switch,
        // to avoid deopts in old v8


        if (type === CODES) {
          base = extra = work;
          /* dummy value--not used */

          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          /* DISTS */
          base = dbase;
          extra = dext;
          end = -1;
        }
        /* initialize opts for loop */


        huff = 0;
        /* starting code */

        sym = 0;
        /* starting code symbol */

        len = min;
        /* starting code length */

        next = table_index;
        /* current table to fill in */

        curr = root;
        /* current table index bits */

        drop = 0;
        /* current bits to drop from code for index */

        low = -1;
        /* trigger new sub-table when len > root */

        used = 1 << root;
        /* use root table entries */

        mask = used - 1;
        /* mask for comparing low */

        /* check available table space */

        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        /* process all codes and make table entries */

        for (; ;) {
          /* create table entry */

          here_bits = len - drop;

          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            /* end of block */

            here_val = 0;
          }
          /* replicate for those indices with low len bits equal to huff */


          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          /* save offset to next table */

          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          /* backwards increment the len-bit code huff */


          incr = 1 << len - 1;

          while (huff & incr) {
            incr >>= 1;
          }

          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          /* go to next symbol, update count, len */


          sym++;

          if (--count[len] === 0) {
            if (len === max) {
              break;
            }

            len = lens[lens_index + work[sym]];
          }
          /* create new sub-table if needed */


          if (len > root && (huff & mask) !== low) {
            /* if first time, transition to sub-tables */
            if (drop === 0) {
              drop = root;
            }
            /* increment past last table */


            next += min;
            /* here min is 1 << curr */

            /* determine length of next table */

            curr = len - drop;
            left = 1 << curr;

            while (curr + drop < max) {
              left -= count[curr + drop];

              if (left <= 0) {
                break;
              }

              curr++;
              left <<= 1;
            }
            /* check for enough space */


            used += 1 << curr;

            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            /* point entry in root table to sub-table */


            low = huff & mask;
            /*table.op[low] = curr;
            table.bits[low] = root;
            table.val[low] = next - opts.table_index;*/

            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        /* fill in remaining table entry if code is incomplete (guaranteed to have
         at most one remaining entry, since if the code is incomplete, the
         maximum code length that was allowed to get this far is one bit) */


        if (huff !== 0) {
          //table.op[next + huff] = 64;            /* invalid code marker */
          //table.bits[next + huff] = len - drop;
          //table.val[next + huff] = 0;
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        /* set return parameters */
        //opts.table_index += used;


        opts.bits = root;
        return 0;
      };
    }, {
      "../utils/common": 216
    }],
    224: [function (localRequire, localModule, localExports) {

      localModule.localExports = {
        2: 'need dictionary',

        /* Z_NEED_DICT       2  */
        1: 'stream end',

        /* Z_STREAM_END      1  */
        0: '',

        /* Z_OK              0  */
        '-1': 'file error',

        /* Z_ERRNO         (-1) */
        '-2': 'stream error',

        /* Z_STREAM_ERROR  (-2) */
        '-3': 'data error',

        /* Z_DATA_ERROR    (-3) */
        '-4': 'insufficient memory',

        /* Z_MEM_ERROR     (-4) */
        '-5': 'buffer error',

        /* Z_BUF_ERROR     (-5) */
        '-6': 'incompatible version'
        /* Z_VERSION_ERROR (-6) */

      };
    }, {}],
    225: [function (localRequire, localModule, localExports) {

      var utils = localRequire('../utils/common');
      /* Public constants ==========================================================*/

      /* ===========================================================================*/
      //var Z_FILTERED          = 1;
      //var Z_HUFFMAN_ONLY      = 2;
      //var Z_RLE               = 3;

      var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

      /* Possible values of the data_type field (though see inflate()) */

      var Z_BINARY = 0;
      var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

      var Z_UNKNOWN = 2;
      /*============================================================================*/

      function zero(buf) {
        var len = buf.length;

        while (--len >= 0) {
          buf[len] = 0;
        }
      } // From zutil.h


      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      /* The three kinds of block type */

      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      /* The minimum and maximum match lengths */
      // From deflate.h

      /* ===========================================================================
       * Internal compression state.
       */

      var LENGTH_CODES = 29;
      /* number of length codes, not counting the special END_BLOCK code */

      var LITERALS = 256;
      /* number of literal bytes 0..255 */

      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      /* number of Literal or Length codes, including the END_BLOCK code */

      var D_CODES = 30;
      /* number of distance codes */

      var BL_CODES = 19;
      /* number of codes used to transfer the bit lengths */

      var HEAP_SIZE = 2 * L_CODES + 1;
      /* maximum heap size */

      var MAX_BITS = 15;
      /* All codes must not exceed MAX_BITS bits */

      var Buf_size = 16;
      /* size of bit buffer in bi_buf */

      /* ===========================================================================
       * Constants
       */

      var MAX_BL_BITS = 7;
      /* Bit length codes must not exceed MAX_BL_BITS bits */

      var END_BLOCK = 256;
      /* end of block literal code */

      var REP_3_6 = 16;
      /* repeat previous bit length 3-6 times (2 bits of repeat count) */

      var REPZ_3_10 = 17;
      /* repeat a zero length 3-10 times  (3 bits of repeat count) */

      var REPZ_11_138 = 18;
      /* repeat a zero length 11-138 times  (7 bits of repeat count) */

      /* eslint-disable comma-spacing,array-bracket-spacing */

      var extra_lbits =
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
      var extra_dbits =
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      var extra_blbits =
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      /* eslint-enable comma-spacing,array-bracket-spacing */

      /* The lengths of the bit length codes are sent in order of decreasing
       * probability, to avoid transmitting the lengths for unused bit length codes.
       */

      /* ===========================================================================
       * Local data. These are initialized only once.
       */
      // We pre-fill arrays with 0 to avoid uninitialized gaps

      var DIST_CODE_LEN = 512;
      /* see definition of array dist_code below */
      // !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1

      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      /* The static literal tree. Since the bit lengths are imposed, there is no
       * need for the L_CODES extra codes used during heap construction. However
       * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
       * below).
       */

      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      /* The static distance tree. (Actually a trivial tree since all codes use
       * 5 bits.)
       */

      var _dist_code = new Array(DIST_CODE_LEN);

      zero(_dist_code);
      /* Distance codes. The first 256 values correspond to the distances
       * 3 .. 258, the last 256 values correspond to the top 8 bits of
       * the 15 bit distances.
       */

      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

      zero(_length_code);
      /* length code for each normalized match length (0 == MIN_MATCH) */

      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      /* First normalized length for each code (0 = MIN_MATCH) */

      var base_dist = new Array(D_CODES);
      zero(base_dist);
      /* First normalized distance for each code (0 = distance of 1) */

      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        /* static tree or NULL */

        this.extra_bits = extra_bits;
        /* extra bits for each code or NULL */

        this.extra_base = extra_base;
        /* base index for extra_bits */

        this.elems = elems;
        /* max number of elements in the tree */

        this.max_length = max_length;
        /* max bit length for the codes */
        // show if `static_tree` has data or dummy - needed for monomorphic objects

        this.has_stree = static_tree && static_tree.length;
      }

      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;

      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        /* the dynamic tree */

        this.max_code = 0;
        /* largest code with non zero frequency */

        this.stat_desc = stat_desc;
        /* the corresponding static tree */
      }

      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }
      /* ===========================================================================
       * Output a short LSB first on the stream.
       * IN assertion: there is enough room in pendingBuf.
       */


      function put_short(s, w) {
        //    put_byte(s, (uch)((w) & 0xff));
        //    put_byte(s, (uch)((ush)(w) >> 8));
        s.pending_buf[s.pending++] = w & 0xff;
        s.pending_buf[s.pending++] = w >>> 8 & 0xff;
      }
      /* ===========================================================================
       * Send a value on a given number of bits.
       * IN assertion: length <= 16 and value fits in length bits.
       */


      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 0xffff;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 0xffff;
          s.bi_valid += length;
        }
      }

      function send_code(s, c, tree) {
        send_bits(s, tree[c * 2]
          /*.Code*/
          , tree[c * 2 + 1]
          /*.Len*/
        );
      }
      /* ===========================================================================
       * Reverse the first len bits of a code, using straightforward code (a faster
       * method would use a table)
       * IN assertion: 1 <= len <= 15
       */


      function bi_reverse(code, len) {
        var res = 0;

        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);

        return res >>> 1;
      }
      /* ===========================================================================
       * Flush the bit buffer, keeping at most 7 bits in it.
       */


      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 0xff;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }
      /* ===========================================================================
       * Compute the optimal bit lengths for a tree and update the total bit length
       * for the current block.
       * IN assertion: the fields freq and dad are set, heap[heap_max] and
       *    above are the tree nodes sorted by increasing frequency.
       * OUT assertions: the field len is set to the optimal bit length, the
       *     array bl_count contains the frequencies for each bit length.
       *     The length opt_len is updated; static_len is also updated if stree is
       *     not null.
       */


      function gen_bitlen(s, desc) //    deflate_state *s;
      //    tree_desc *desc;    /* the tree descriptor */
      {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        /* heap index */

        var n, m;
        /* iterate over the tree elements */

        var bits;
        /* bit length */

        var xbits;
        /* extra bits */

        var f;
        /* frequency */

        var overflow = 0;
        /* number of elements with bit length too large */

        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        /* In a first pass, compute the optimal bit lengths (which may
         * overflow in the case of the bit length tree).
         */


        tree[s.heap[s.heap_max] * 2 + 1]
          /*.Len*/
          = 0;
        /* root of the heap */

        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1]
            /*.Dad*/
            * 2 + 1]
            /*.Len*/
            + 1;

          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }

          tree[n * 2 + 1]
            /*.Len*/
            = bits;
          /* We overwrite tree[n].Dad which is no longer needed */

          if (n > max_code) {
            continue;
          }
          /* not a leaf node */


          s.bl_count[bits]++;
          xbits = 0;

          if (n >= base) {
            xbits = extra[n - base];
          }

          f = tree[n * 2]
            /*.Freq*/
            ;
          s.opt_len += f * (bits + xbits);

          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1]
              /*.Len*/
              + xbits);
          }
        }

        if (overflow === 0) {
          return;
        } // Trace((stderr,"\nbit length overflow\n"));

        /* This happens for example on obj2 and pic of the Calgary corpus */

        /* Find the first bit length which could increase: */


        do {
          bits = max_length - 1;

          while (s.bl_count[bits] === 0) {
            bits--;
          }

          s.bl_count[bits]--;
          /* move one leaf down the tree */

          s.bl_count[bits + 1] += 2;
          /* move one overflow item as its brother */

          s.bl_count[max_length]--;
          /* The brother of the overflow item also moves one step up,
           * but this does not affect bl_count[max_length]
           */

          overflow -= 2;
        } while (overflow > 0);
        /* Now recompute all bit lengths, scanning in increasing frequency.
         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
         * lengths instead of fixing only the wrong ones. This idea is taken
         * from 'ar' written by Haruhiko Okumura.)
         */


        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];

          while (n !== 0) {
            m = s.heap[--h];

            if (m > max_code) {
              continue;
            }

            if (tree[m * 2 + 1]
              /*.Len*/
              !== bits) {
              // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
              s.opt_len += (bits - tree[m * 2 + 1]
                /*.Len*/
              ) * tree[m * 2]
                /*.Freq*/
                ;
              tree[m * 2 + 1]
                /*.Len*/
                = bits;
            }

            n--;
          }
        }
      }
      /* ===========================================================================
       * Generate the codes for a given tree and bit counts (which need not be
       * optimal).
       * IN assertion: the array bl_count contains the bit length statistics for
       * the given tree and the field len is set for all tree elements.
       * OUT assertion: the field code is set for all tree elements of non
       *     zero code length.
       */


      function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
      //    int max_code;              /* largest code with non zero frequency */
      //    ushf *bl_count;            /* number of codes at each bit length */
      {
        var next_code = new Array(MAX_BITS + 1);
        /* next code value for each bit length */

        var code = 0;
        /* running code value */

        var bits;
        /* bit index */

        var n;
        /* code index */

        /* The distribution counts are first used to generate the code values
         * without bit reversal.
         */

        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        /* Check that the bit counts in bl_count are consistent. The last code
         * must be all ones.
         */
        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
        //        "inconsistent bit counts");
        //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1]
            /*.Len*/
            ;

          if (len === 0) {
            continue;
          }
          /* Now reverse the bits */


          tree[n * 2]
            /*.Code*/
            = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
          //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
        }
      }
      /* ===========================================================================
       * Initialize the various 'constant' tables.
       */


      function tr_static_init() {
        var n;
        /* iterates over tree elements */

        var bits;
        /* bit counter */

        var length;
        /* length value */

        var code;
        /* code value */

        var dist;
        /* distance index */

        var bl_count = new Array(MAX_BITS + 1);
        /* number of codes at each bit length for an optimal tree */
        // do check in _tr_init()
        //if (static_init_done) return;

        /* For some embedded targets, global variables are not initialized: */

        /*#ifdef NO_INIT_GLOBAL_POINTERS
          static_l_desc.static_tree = static_ltree;
          static_l_desc.extra_bits = extra_lbits;
          static_d_desc.static_tree = static_dtree;
          static_d_desc.extra_bits = extra_dbits;
          static_bl_desc.extra_bits = extra_blbits;
        #endif*/

        /* Initialize the mapping length (0..255) -> length code (0..28) */

        length = 0;

        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;

          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        } //Assert (length == 256, "tr_static_init: length != 256");

        /* Note that the length 255 (match length 258) can be represented
         * in two different ways: code 284 + 5 bits or code 285, so we
         * overwrite length_code[255] to use the best encoding:
         */


        _length_code[length - 1] = code;
        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

        dist = 0;

        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;

          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        } //Assert (dist == 256, "tr_static_init: dist != 256");


        dist >>= 7;
        /* from now on, all distances are divided by 128 */

        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;

          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

        /* Construct the codes of the static literal tree */


        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }

        n = 0;

        while (n <= 143) {
          static_ltree[n * 2 + 1]
            /*.Len*/
            = 8;
          n++;
          bl_count[8]++;
        }

        while (n <= 255) {
          static_ltree[n * 2 + 1]
            /*.Len*/
            = 9;
          n++;
          bl_count[9]++;
        }

        while (n <= 279) {
          static_ltree[n * 2 + 1]
            /*.Len*/
            = 7;
          n++;
          bl_count[7]++;
        }

        while (n <= 287) {
          static_ltree[n * 2 + 1]
            /*.Len*/
            = 8;
          n++;
          bl_count[8]++;
        }
        /* Codes 286 and 287 do not exist, but we must include them in the
         * tree construction to get a canonical Huffman tree (longest code
         * all ones)
         */


        gen_codes(static_ltree, L_CODES + 1, bl_count);
        /* The static distance tree is trivial: */

        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1]
            /*.Len*/
            = 5;
          static_dtree[n * 2]
            /*.Code*/
            = bi_reverse(n, 5);
        } // Now data ready and we can init static trees


        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
      }
      /* ===========================================================================
       * Initialize a new block.
       */


      function init_block(s) {
        var n;
        /* iterates over tree elements */

        /* Initialize the trees. */

        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2]
            /*.Freq*/
            = 0;
        }

        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2]
            /*.Freq*/
            = 0;
        }

        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2]
            /*.Freq*/
            = 0;
        }

        s.dyn_ltree[END_BLOCK * 2]
          /*.Freq*/
          = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }
      /* ===========================================================================
       * Flush the bit buffer and align the output on a byte boundary
       */


      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          //put_byte(s, (Byte)s->bi_buf);
          s.pending_buf[s.pending++] = s.bi_buf;
        }

        s.bi_buf = 0;
        s.bi_valid = 0;
      }
      /* ===========================================================================
       * Copy a stored block, storing first the length and its
       * one's complement if requested.
       */


      function copy_block(s, buf, len, header) //DeflateState *s;
      //charf    *buf;    /* the input data */
      //unsigned len;     /* its length */
      //int      header;  /* true if block header must be written */
      {
        bi_windup(s);
        /* align on byte boundary */

        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        } //  while (len--) {
        //    put_byte(s, *buf++);
        //  }


        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }
      /* ===========================================================================
       * Compares to subtrees, using the tree depth as tie breaker when
       * the subtrees have equal frequency. This minimizes the worst case length.
       */


      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;

        var _m2 = m * 2;

        return tree[_n2]
          /*.Freq*/
          < tree[_m2]
          /*.Freq*/
          || tree[_n2]
          /*.Freq*/
          === tree[_m2]
          /*.Freq*/
          && depth[n] <= depth[m];
      }
      /* ===========================================================================
       * Restore the heap property by moving down the tree starting at node k,
       * exchanging a node with the smallest of its two sons if necessary, stopping
       * when the heap property is re-established (each father smaller than its
       * two sons).
       */


      function pqdownheap(s, tree, k) //    deflate_state *s;
      //    ct_data *tree;  /* the tree to restore */
      //    int k;               /* node to move down */
      {
        var v = s.heap[k];
        var j = k << 1;
        /* left son of k */

        while (j <= s.heap_len) {
          /* Set j to the smallest of the two sons: */
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          /* Exit if v is smaller than both sons */


          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          /* Exchange v with the smallest son */


          s.heap[k] = s.heap[j];
          k = j;
          /* And continue down the tree, setting j to the left son of k */

          j <<= 1;
        }

        s.heap[k] = v;
      } // inlined manually
      // var SMALLEST = 1;

      /* ===========================================================================
       * Send the block data compressed using the given Huffman trees
       */


      function compress_block(s, ltree, dtree) //    deflate_state *s;
      //    const ct_data *ltree; /* literal tree */
      //    const ct_data *dtree; /* distance tree */
      {
        var dist;
        /* distance of matched string */

        var lc;
        /* match length or unmatched char (if dist == 0) */

        var lx = 0;
        /* running index in l_buf */

        var code;
        /* the code to send */

        var extra;
        /* number of extra bits to send */

        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;

            if (dist === 0) {
              send_code(s, lc, ltree);
              /* send a literal byte */
              //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
            } else {
              /* Here, lc is the match length - MIN_MATCH */
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              /* send the length code */

              extra = extra_lbits[code];

              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
                /* send the extra length bits */
              }

              dist--;
              /* dist is now the match distance - 1 */

              code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

              send_code(s, code, dtree);
              /* send the distance code */

              extra = extra_dbits[code];

              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
                /* send the extra distance bits */
              }
            }
            /* literal or match pair ? */

            /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
            //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
            //       "pendingBuf overflow");

          } while (lx < s.last_lit);
        }

        send_code(s, END_BLOCK, ltree);
      }
      /* ===========================================================================
       * Construct one Huffman tree and assigns the code bit strings and lengths.
       * Update the total bit length for the current block.
       * IN assertion: the field freq is set for all tree elements.
       * OUT assertions: the fields len and code are set to the optimal bit length
       *     and corresponding code. The length opt_len is updated; static_len is
       *     also updated if stree is not null. The field max_code is set.
       */


      function build_tree(s, desc) //    deflate_state *s;
      //    tree_desc *desc; /* the tree descriptor */
      {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        /* iterate over heap elements */

        var max_code = -1;
        /* largest code with non zero frequency */

        var node;
        /* new node being created */

        /* Construct the initial heap, with least frequent element in
         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
         * heap[0] is not used.
         */

        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;

        for (n = 0; n < elems; n++) {
          if (tree[n * 2]
            /*.Freq*/
            !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1]
              /*.Len*/
              = 0;
          }
        }
        /* The pkzip format requires that at least one distance code exists,
         * and that at least one bit should be sent even if there is only one
         * possible code. So to avoid special checks later on we force at least
         * two codes of non zero frequency.
         */


        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2]
            /*.Freq*/
            = 1;
          s.depth[node] = 0;
          s.opt_len--;

          if (has_stree) {
            s.static_len -= stree[node * 2 + 1]
              /*.Len*/
              ;
          }
          /* node is 0 or 1 so it does not have extra bits */

        }

        desc.max_code = max_code;
        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
         * establish sub-heaps of increasing lengths:
         */

        for (n = s.heap_len >> 1
          /*int /2*/
          ; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        /* Construct the Huffman tree by repeatedly combining the least two
         * frequent nodes.
         */


        node = elems;
        /* next internal node of the tree */

        do {
          //pqremove(s, tree, n);  /* n = node of least frequency */

          /*** pqremove ***/
          n = s.heap[1
            /*SMALLEST*/
          ];
          s.heap[1
            /*SMALLEST*/
          ] = s.heap[s.heap_len--];
          pqdownheap(s, tree, 1
            /*SMALLEST*/
          );
          /***/

          m = s.heap[1
            /*SMALLEST*/
          ];
          /* m = node of next least frequency */

          s.heap[--s.heap_max] = n;
          /* keep the nodes sorted by frequency */

          s.heap[--s.heap_max] = m;
          /* Create a new node father of n and m */

          tree[node * 2]
            /*.Freq*/
            = tree[n * 2]
            /*.Freq*/
            + tree[m * 2]
            /*.Freq*/
            ;
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1]
            /*.Dad*/
            = tree[m * 2 + 1]
            /*.Dad*/
            = node;
          /* and insert the new node in the heap */

          s.heap[1
            /*SMALLEST*/
          ] = node++;
          pqdownheap(s, tree, 1
            /*SMALLEST*/
          );
        } while (s.heap_len >= 2);

        s.heap[--s.heap_max] = s.heap[1
          /*SMALLEST*/
        ];
        /* At this point, the fields freq and dad are set. We can now
         * generate the bit lengths.
         */

        gen_bitlen(s, desc);
        /* The field len is now set, we can generate the bit codes */

        gen_codes(tree, max_code, s.bl_count);
      }
      /* ===========================================================================
       * Scan a literal or distance tree to determine the frequencies of the codes
       * in the bit length tree.
       */


      function scan_tree(s, tree, max_code) //    deflate_state *s;
      //    ct_data *tree;   /* the tree to be scanned */
      //    int max_code;    /* and its largest code of non zero frequency */
      {
        var n;
        /* iterates over all tree elements */

        var prevlen = -1;
        /* last emitted length */

        var curlen;
        /* length of current code */

        var nextlen = tree[0 * 2 + 1]
          /*.Len*/
          ;
        /* length of next code */

        var count = 0;
        /* repeat count of the current code */

        var max_count = 7;
        /* max repeat count */

        var min_count = 4;
        /* min repeat count */

        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }

        tree[(max_code + 1) * 2 + 1]
          /*.Len*/
          = 0xffff;
        /* guard */

        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1]
            /*.Len*/
            ;

          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2]
              /*.Freq*/
              += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2] /*.Freq*/++;
            }

            s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
          } else {
            s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
          }

          count = 0;
          prevlen = curlen;

          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      /* ===========================================================================
       * Send a literal or distance tree in compressed form, using the codes in
       * bl_tree.
       */


      function send_tree(s, tree, max_code) //    deflate_state *s;
      //    ct_data *tree; /* the tree to be scanned */
      //    int max_code;       /* and its largest code of non zero frequency */
      {
        var n;
        /* iterates over all tree elements */

        var prevlen = -1;
        /* last emitted length */

        var curlen;
        /* length of current code */

        var nextlen = tree[0 * 2 + 1]
          /*.Len*/
          ;
        /* length of next code */

        var count = 0;
        /* repeat count of the current code */

        var max_count = 7;
        /* max repeat count */

        var min_count = 4;
        /* min repeat count */

        /* tree[max_code+1].Len = -1; */

        /* guard already set */

        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }

        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1]
            /*.Len*/
            ;

          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            } //Assert(count >= 3 && count <= 6, " 3_6?");


            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }

          count = 0;
          prevlen = curlen;

          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      /* ===========================================================================
       * Construct the Huffman tree for the bit lengths and return the index in
       * bl_order of the last bit length code to send.
       */


      function build_bl_tree(s) {
        var max_blindex;
        /* index of last bit length code of non zero freq */

        /* Determine the bit length frequencies for literal and distance trees */

        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        /* Build the bit length tree: */

        build_tree(s, s.bl_desc);
        /* opt_len now includes the length of the tree representations, except
         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
         */

        /* Determine the number of bit length codes to send. The pkzip format
         * requires that at least 4 bit length codes be sent. (appnote.txt says
         * 3 but the actual value used is 4.)
         */

        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
            /*.Len*/
            !== 0) {
            break;
          }
        }
        /* Update opt_len to include the bit length tree and counts */


        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
        //        s->opt_len, s->static_len));

        return max_blindex;
      }
      /* ===========================================================================
       * Send the header for a block using dynamic Huffman trees: the counts, the
       * lengths of the bit length codes, the literal tree and the distance tree.
       * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
       */


      function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
      //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
      {
        var rank;
        /* index in bl_order */
        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
        //        "too many codes");
        //Tracev((stderr, "\nbl counts: "));

        send_bits(s, lcodes - 257, 5);
        /* not +255 as stated in appnote.txt */

        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        /* not -3 as stated in appnote.txt */

        for (rank = 0; rank < blcodes; rank++) {
          //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
            /*.Len*/
            , 3);
        } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


        send_tree(s, s.dyn_ltree, lcodes - 1);
        /* literal tree */
        //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

        send_tree(s, s.dyn_dtree, dcodes - 1);
        /* distance tree */
        //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
      }
      /* ===========================================================================
       * Check if the data type is TEXT or BINARY, using the following algorithm:
       * - TEXT if the two conditions below are satisfied:
       *    a) There are no non-portable control characters belonging to the
       *       "black list" (0..6, 14..25, 28..31).
       *    b) There is at least one printable character belonging to the
       *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
       * - BINARY otherwise.
       * - The following partially-portable control characters form a
       *   "gray list" that is ignored in this detection algorithm:
       *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
       * IN assertion: the fields Freq of dyn_ltree are set.
       */


      function detect_data_type(s) {
        /* black_mask is the bit mask of black-listed bytes
         * set bits 0..6, 14..25, and 28..31
         * 0xf3ffc07f = binary 11110011111111111100000001111111
         */
        var black_mask = 0xf3ffc07f;
        var n;
        /* Check for non-textual ("black-listed") bytes. */

        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2]
            /*.Freq*/
            !== 0) {
            return Z_BINARY;
          }
        }
        /* Check for textual ("white-listed") bytes. */


        if (s.dyn_ltree[9 * 2]
          /*.Freq*/
          !== 0 || s.dyn_ltree[10 * 2]
          /*.Freq*/
          !== 0 || s.dyn_ltree[13 * 2]
          /*.Freq*/
          !== 0) {
          return Z_TEXT;
        }

        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2]
            /*.Freq*/
            !== 0) {
            return Z_TEXT;
          }
        }
        /* There are no "black-listed" or "white-listed" bytes:
         * this stream either is empty or has tolerated ("gray-listed") bytes only.
         */


        return Z_BINARY;
      }

      var static_init_done = false;
      /* ===========================================================================
       * Initialize the tree data structures for a new zlib stream.
       */

      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }

        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        /* Initialize the first block of the first file: */

        init_block(s);
      }
      /* ===========================================================================
       * Send a stored block
       */


      function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
      //charf *buf;       /* input block */
      //ulg stored_len;   /* length of input block */
      //int last;         /* one if this is the last block for a file */
      {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        /* send block type */

        copy_block(s, buf, stored_len, true);
        /* with header */
      }
      /* ===========================================================================
       * Send one empty static block to give enough lookahead for inflate.
       * This takes 10 bits, of which 7 may remain in the bit buffer.
       */


      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }
      /* ===========================================================================
       * Determine the best encoding for the current block: dynamic trees, static
       * trees or store, and output the encoded block to the zip file.
       */


      function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
      //charf *buf;       /* input block, or NULL if too old */
      //ulg stored_len;   /* length of input block */
      //int last;         /* one if this is the last block for a file */
      {
        var opt_lenb, static_lenb;
        /* opt_len and static_len in bytes */

        var max_blindex = 0;
        /* index of last bit length code of non zero freq */

        /* Build the Huffman trees unless a stored block is forced */

        if (s.level > 0) {
          /* Check if the file is binary or text */
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          /* Construct the literal and distance trees */


          build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
          //        s->static_len));

          build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
          //        s->static_len));

          /* At this point, opt_len and static_len are the total bit lengths of
           * the compressed block data, excluding the tree representations.
           */

          /* Build the bit length tree for the above two trees, and get the index
           * in bl_order of the last bit length code to send.
           */

          max_blindex = build_bl_tree(s);
          /* Determine the best encoding. Compute the block lengths in bytes. */

          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
          //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
          //        s->last_lit));

          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          // Assert(buf != (char*)0, "lost buf");
          opt_lenb = static_lenb = stored_len + 5;
          /* force a stored block */
        }

        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          /* 4: two words for the lengths */

          /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
           * Otherwise we can't have processed more than WSIZE input bytes since
           * the last block flush, because compression would have been
           * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
           * transform a block into a stored block.
           */
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

        /* The above check is made mod 2^32, for files larger than 512 MB
         * and uLong implemented on 32 bits.
         */


        init_block(s);

        if (last) {
          bi_windup(s);
        } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
        //       s->compressed_len-7*last));

      }
      /* ===========================================================================
       * Save the match info and tally the frequency counts. Return true if
       * the current block must be flushed.
       */


      function _tr_tally(s, dist, lc) //    deflate_state *s;
      //    unsigned dist;  /* distance of matched string */
      //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
      {
        //var out_length, in_length, dcode;
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
        s.last_lit++;

        if (dist === 0) {
          /* lc is the unmatched char */
          s.dyn_ltree[lc * 2] /*.Freq*/++;
        } else {
          s.matches++;
          /* Here, lc is the match length - MIN_MATCH */

          dist--;
          /* dist = match distance - 1 */
          //Assert((ush)dist < (ush)MAX_DIST(s) &&
          //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
          //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
          s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
        } // (!) This block is disabled in zlib defailts,
        // don't enable it for binary compatibility
        //#ifdef TRUNCATE_BLOCK
        //  /* Try to guess if it is profitable to stop the current block here */
        //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
        //    /* Compute an upper bound for the compressed length */
        //    out_length = s.last_lit*8;
        //    in_length = s.strstart - s.block_start;
        //
        //    for (dcode = 0; dcode < D_CODES; dcode++) {
        //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
        //    }
        //    out_length >>>= 3;
        //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
        //    //       s->last_lit, in_length, out_length,
        //    //       100L - out_length*100L/in_length));
        //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
        //      return true;
        //    }
        //  }
        //#endif


        return s.last_lit === s.lit_bufsize - 1;
        /* We avoid equality with lit_bufsize because of wraparound at 64K
         * on 16 bit machines and because stored blocks are restricted to
         * 64K-1 bytes.
         */
      }

      localExports._tr_init = _tr_init;
      localExports._tr_stored_block = _tr_stored_block;
      localExports._tr_flush_block = _tr_flush_block;
      localExports._tr_tally = _tr_tally;
      localExports._tr_align = _tr_align;
    }, {
      "../utils/common": 216
    }],
    226: [function (localRequire, localModule, localExports) {

      function ZStream() {
        /* next input byte */
        this.input = null; // JS specific, because we have no pointers

        this.next_in = 0;
        /* number of bytes available at input */

        this.avail_in = 0;
        /* total number of input bytes read so far */

        this.total_in = 0;
        /* next output byte should be put there */

        this.output = null; // JS specific, because we have no pointers

        this.next_out = 0;
        /* remaining free space at output */

        this.avail_out = 0;
        /* total number of bytes output so far */

        this.total_out = 0;
        /* last error message, NULL if no error */

        this.msg = ''
          /*Z_NULL*/
          ;
        /* not visible by applications */

        this.state = null;
        /* best guess about the data type: binary or text */

        this.data_type = 2
          /*Z_UNKNOWN*/
          ;
        /* adler32 value of the uncompressed data */

        this.adler = 0;
      }

      localModule.localExports = ZStream;
    }, {}],
    227: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {
          /*
           * MIT LICENSE
           * Copyright (c) 2011 Devon Govett
           *
           * Permission is hereby granted, free of charge, to any person obtaining a copy of this
           * software and associated documentation files (the "Software"), to deal in the Software
           * without restriction, including without limitation the rights to use, copy, modify, merge,
           * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
           * to whom the Software is furnished to do so, subject to the following conditions:
           *
           * The above copyright notice and this permission notice shall be included in all copies or
           * substantial portions of the Software.
           *
           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
           * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
           * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
           * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
           * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
           */

          var fs = localRequire('fs');
          var zlib = localRequire('zlib');

          localModule.localExports = /*#__PURE__*/function () {
            (<any>PNG).decode = function decode(path, fn) {
              return fs.readFile(path, function (err, file) {
                var png = new PNG(file);
                return png.decode(function (pixels) {
                  return fn(pixels);
                });
              });
            };

            (<any>PNG).load = function load(path) {
              var file = fs.readFileSync(path);
              return new PNG(file);
            };

            function PNG(data) {
              var i;
              this.data = data;
              this.pos = 8; // Skip the default header

              this.palette = [];
              this.imgData = [];
              this.transparency = {};
              this.text = {};

              while (true) {
                var chunkSize = this.readUInt32();
                var section = '';

                for (i = 0; i < 4; i++) {
                  section += String.fromCharCode(this.data[this.pos++]);
                }

                switch (section) {
                  case 'IHDR':
                    // we can grab  interesting values from here (like width, height, etc)
                    this.width = this.readUInt32();
                    this.height = this.readUInt32();
                    this.bits = this.data[this.pos++];
                    this.colorType = this.data[this.pos++];
                    this.compressionMethod = this.data[this.pos++];
                    this.filterMethod = this.data[this.pos++];
                    this.interlaceMethod = this.data[this.pos++];
                    break;

                  case 'PLTE':
                    this.palette = this.read(chunkSize);
                    break;

                  case 'IDAT':
                    for (i = 0; i < chunkSize; i++) {
                      this.imgData.push(this.data[this.pos++]);
                    }

                    break;

                  case 'tRNS':
                    // This chunk can only occur once and it must occur after the
                    // PLTE chunk and before the IDAT chunk.
                    this.transparency = {};

                    switch (this.colorType) {
                      case 3:
                        // Indexed color, RGB. Each byte in this chunk is an alpha for
                        // the palette index in the PLTE ("palette") chunk up until the
                        // last non-opaque entry. Set up an array, stretching over all
                        // palette entries which will be 0 (opaque) or 1 (transparent).
                        this.transparency.indexed = this.read(chunkSize);
                        var short = 255 - this.transparency.indexed.length;

                        if (short > 0) {
                          for (i = 0; i < short; i++) {
                            this.transparency.indexed.push(255);
                          }
                        }

                        break;

                      case 0:
                        // Greyscale. Corresponding to entries in the PLTE chunk.
                        // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1
                        this.transparency.grayscale = this.read(chunkSize)[0];
                        break;

                      case 2:
                        // True color with proper alpha channel.
                        this.transparency.rgb = this.read(chunkSize);
                        break;
                    }

                    break;

                  case 'tEXt':
                    var text = this.read(chunkSize);
                    var index = text.indexOf(0);
                    var key = String.fromCharCode.apply(String, text.slice(0, index));
                    this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                    break;

                  case 'IEND':
                    // we've got everything we need!
                    switch (this.colorType) {
                      case 0:
                      case 3:
                      case 4:
                        this.colors = 1;
                        break;

                      case 2:
                      case 6:
                        this.colors = 3;
                        break;
                    }

                    this.hasAlphaChannel = [4, 6].indexOf(this.colorType) !== -1;
                    var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                    this.pixelBitlength = this.bits * colors;

                    switch (this.colors) {
                      case 1:
                        this.colorSpace = 'DeviceGray';
                        break;

                      case 3:
                        this.colorSpace = 'DeviceRGB';
                        break;
                    }

                    this.imgData = new Buffer(this.imgData);
                    return;

                  default:
                    // unknown (or unimportant) section, skip it
                    this.pos += chunkSize;
                }

                this.pos += 4; // Skip the CRC

                if (this.pos > this.data.length) {
                  throw new Error('Incomplete or corrupt PNG file');
                }
              }
            }

            var _proto = PNG.prototype;

            _proto.read = function read(bytes) {
              var result = new Array(bytes);

              for (var _i = 0; _i < bytes; _i++) {
                result[_i] = this.data[this.pos++];
              }

              return result;
            };

            _proto.readUInt32 = function readUInt32() {
              var b1 = this.data[this.pos++] << 24;
              var b2 = this.data[this.pos++] << 16;
              var b3 = this.data[this.pos++] << 8;
              var b4 = this.data[this.pos++];
              return b1 | b2 | b3 | b4;
            };

            _proto.readUInt16 = function readUInt16() {
              var b1 = this.data[this.pos++] << 8;
              var b2 = this.data[this.pos++];
              return b1 | b2;
            };

            _proto.decodePixels = function decodePixels(fn) {
              var _this = this;

              return zlib.inflate(this.imgData, function (err, data) {
                if (err) {
                  throw err;
                }

                var width = _this.width,
                  height = _this.height;
                var pixelBytes = _this.pixelBitlength / 8;
                var pixels = new Buffer(width * height * pixelBytes);
                var length = data.length;
                var pos = 0;

                function pass(x0, y0, dx, dy, singlePass?) {
                  if (singlePass === void 0) {
                    singlePass = false;
                  }

                  var w = Math.ceil((width - x0) / dx);
                  var h = Math.ceil((height - y0) / dy);
                  var scanlineLength = pixelBytes * w;
                  var buffer = singlePass ? pixels : new Buffer(scanlineLength * h);
                  var row = 0;
                  var c = 0;

                  while (row < h && pos < length) {
                    var byte, col, i, left, upper;

                    switch (data[pos++]) {
                      case 0:
                        // None
                        for (i = 0; i < scanlineLength; i++) {
                          buffer[c++] = data[pos++];
                        }

                        break;

                      case 1:
                        // Sub
                        for (i = 0; i < scanlineLength; i++) {
                          byte = data[pos++];
                          left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                          buffer[c++] = (byte + left) % 256;
                        }

                        break;

                      case 2:
                        // Up
                        for (i = 0; i < scanlineLength; i++) {
                          byte = data[pos++];
                          col = (i - i % pixelBytes) / pixelBytes;
                          upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                          buffer[c++] = (upper + byte) % 256;
                        }

                        break;

                      case 3:
                        // Average
                        for (i = 0; i < scanlineLength; i++) {
                          byte = data[pos++];
                          col = (i - i % pixelBytes) / pixelBytes;
                          left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                          upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                          buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;
                        }

                        break;

                      case 4:
                        // Paeth
                        for (i = 0; i < scanlineLength; i++) {
                          var paeth, upperLeft;
                          byte = data[pos++];
                          col = (i - i % pixelBytes) / pixelBytes;
                          left = i < pixelBytes ? 0 : buffer[c - pixelBytes];

                          if (row === 0) {
                            upper = upperLeft = 0;
                          } else {
                            upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                            upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                          }

                          var p = left + upper - upperLeft;
                          var pa = Math.abs(p - left);
                          var pb = Math.abs(p - upper);
                          var pc = Math.abs(p - upperLeft);

                          if (pa <= pb && pa <= pc) {
                            paeth = left;
                          } else if (pb <= pc) {
                            paeth = upper;
                          } else {
                            paeth = upperLeft;
                          }

                          buffer[c++] = (byte + paeth) % 256;
                        }

                        break;

                      default:
                        throw new Error("Invalid filter algorithm: " + data[pos - 1]);
                    }

                    if (!singlePass) {
                      var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
                      var bufferPos = row * scanlineLength;

                      for (i = 0; i < w; i++) {
                        for (var j = 0; j < pixelBytes; j++) {
                          pixels[pixelsPos++] = buffer[bufferPos++];
                        }

                        pixelsPos += (dx - 1) * pixelBytes;
                      }
                    }

                    row++;
                  }
                }

                if (_this.interlaceMethod === 1) {
                  /*
                    1 6 4 6 2 6 4 6
                    7 7 7 7 7 7 7 7
                    5 6 5 6 5 6 5 6
                    7 7 7 7 7 7 7 7
                    3 6 4 6 3 6 4 6
                    7 7 7 7 7 7 7 7
                    5 6 5 6 5 6 5 6
                    7 7 7 7 7 7 7 7
                  */
                  pass(0, 0, 8, 8); // 1

                  pass(4, 0, 8, 8); // 2

                  pass(0, 4, 4, 8); // 3

                  pass(2, 0, 4, 4); // 4

                  pass(0, 2, 2, 4); // 5

                  pass(1, 0, 2, 2); // 6

                  pass(0, 1, 1, 2); // 7
                } else {
                  pass(0, 0, 1, 1, true);
                }

                return fn(pixels);
              });
            };

            _proto.decodePalette = function decodePalette() {
              var palette = this.palette;
              var length = palette.length;
              var transparency = this.transparency.indexed || [];
              var ret = new Buffer(transparency.length + length);
              var pos = 0;
              var c = 0;

              for (var _i2 = 0; _i2 < length; _i2 += 3) {
                var left;
                ret[pos++] = palette[_i2];
                ret[pos++] = palette[_i2 + 1];
                ret[pos++] = palette[_i2 + 2];
                ret[pos++] = (left = transparency[c++]) != null ? left : 255;
              }

              return ret;
            };

            _proto.copyToImageData = function copyToImageData(imageData, pixels) {
              var j, k;
              var colors = this.colors;
              var palette = null;
              var alpha = this.hasAlphaChannel;

              if (this.palette.length) {
                palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
                colors = 4;
                alpha = true;
              }

              var data = imageData.data || imageData;
              var length = data.length;
              var input = palette || pixels;
              var i = j = 0;

              if (colors === 1) {
                while (i < length) {
                  k = palette ? pixels[i / 4] * 4 : j;
                  var v = input[k++];
                  data[i++] = v;
                  data[i++] = v;
                  data[i++] = v;
                  data[i++] = alpha ? input[k++] : 255;
                  j = k;
                }
              } else {
                while (i < length) {
                  k = palette ? pixels[i / 4] * 4 : j;
                  data[i++] = input[k++];
                  data[i++] = input[k++];
                  data[i++] = input[k++];
                  data[i++] = alpha ? input[k++] : 255;
                  j = k;
                }
              }
            };

            _proto.decode = function decode(fn) {
              var _this2 = this;

              var ret = new Buffer(this.width * this.height * 4);
              return this.decodePixels(function (pixels) {
                _this2.copyToImageData(ret, pixels);

                return fn(ret);
              });
            };

            return PNG;
          }();
        }).call(this);
      }).call(this, localRequire("buffer").Buffer);
    }, {
      "buffer": 152,
      "fs": 151,
      "zlib": 150
    }],
    228: [function (localRequire, localModule, localExports) {
      (function (process) {
        (function () {

          if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
            localModule.localExports = {
              nextTick: nextTick
            };
          } else {
            localModule.localExports = process;
          }

          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== 'function') {
              throw new TypeError('"callback" argument must be a function');
            }

            var len = arguments.length;
            var args, i;

            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn);

              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1);
                });

              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2);
                });

              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3);
                });

              default:
                args = new Array(len - 1);
                i = 0;

                while (i < args.length) {
                  args[i++] = arguments[i];
                }

                return process.nextTick(function afterTick() {
                  fn.apply(null, args);
                });
            }
          }
        }).call(this);
      }).call(this, localRequire('_process'));
    }, {
      "_process": 229
    }],
    229: [function (localRequire, localModule, localExports) {
      // shim for using process in browser
      var process: any = localModule.localExports = {}; // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }

      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }

      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }

        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();

      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        } // if setTimeout wasn't available but was latter defined


        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }

      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        } // if clearTimeout wasn't available but was latter defined


        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }

        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }

      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }

        draining = false;

        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }

        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }

        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;

        while (len) {
          currentQueue = queue;
          queue = [];

          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }

          queueIndex = -1;
          len = queue.length;
        }

        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);

        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }

        queue.push(new Item(fun, args));

        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }; // v8 likes predictible objects


      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }

      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };

      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues

      process.versions = {};

      function noop() { }

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };

      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };

      process.umask = function () {
        return 0;
      };
    }, {}],
    230: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire('./lib/_stream_duplex.js');
    }, {
      "./lib/_stream_duplex.js": 231
    }],
    231: [function (localRequire, localModule, localExports) {
      /*<replacement>*/

      var pna = localRequire('process-nextick-args');
      /*</replacement>*/

      /*<replacement>*/

      var objectKeys = Object.keys || function (obj) {
        var keys = [];

        for (var key in obj) {
          keys.push(key);
        }

        return keys;
      };
      /*</replacement>*/


      localModule.localExports = Duplex;
      /*<replacement>*/

      var util = Object.create(localRequire('core-util-is'));
      util.inherits = localRequire('inherits');
      /*</replacement>*/

      var Readable = localRequire('./_stream_readable');
      var Writable = localRequire('./_stream_writable');
      util.inherits(Duplex, Readable);
      {
        // avoid scope creep, the keys array can then be collected
        var keys = objectKeys(Writable.prototype);

        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
      }

      function Duplex(options): void {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false) this.readable = false;
        if (options && options.writable === false) this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
        this.once('end', onend);
      }

      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      }); // the no-half-open enforcer

      function onend() {
        // if we allow half-open state, or if the writable side ended,
        // then we're ok.
        if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
        // But allow more writes to happen in this tick.

        pna.nextTick(onEndNT, this);
      }

      function onEndNT(self) {
        self.end();
      }

      Object.defineProperty(Duplex.prototype, 'destroyed', {
        get: function get() {
          if (this._readableState === undefined || this._writableState === undefined) {
            return false;
          }

          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          // we ignore the value if the stream
          // has not been initialized yet
          if (this._readableState === undefined || this._writableState === undefined) {
            return;
          } // backward compatibility, the user is explicitly
          // managing destroyed


          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });

      Duplex.prototype._destroy = function (err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
      };
    }, {
      "./_stream_readable": 233,
      "./_stream_writable": 235,
      "core-util-is": 209,
      "inherits": 212,
      "process-nextick-args": 228
    }],
    232: [function (localRequire, localModule, localExports) {

      localModule.localExports = PassThrough;
      var Transform = localRequire('./_stream_transform');
      /*<replacement>*/

      var util = Object.create(localRequire('core-util-is'));
      util.inherits = localRequire('inherits');
      /*</replacement>*/

      util.inherits(PassThrough, Transform);

      function PassThrough(options): void {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }

      PassThrough.prototype._transform = function (chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, {
      "./_stream_transform": 234,
      "core-util-is": 209,
      "inherits": 212
    }],
    233: [function (localRequire, localModule, localExports) {
      (function (process, global) {
        (function () {
          /*<replacement>*/

          var pna = localRequire('process-nextick-args');
          /*</replacement>*/

          localModule.localExports = Readable;
          /*<replacement>*/

          var isArray = localRequire('isarray');
          /*</replacement>*/

          /*<replacement>*/

          var Duplex;
          /*</replacement>*/

          (<any>Readable).ReadableState = ReadableState;
          /*<replacement>*/

          var EE = localRequire('events').EventEmitter;

          var EElistenerCount = function EElistenerCount(emitter, type) {
            return emitter.listeners(type).length;
          };
          /*</replacement>*/

          /*<replacement>*/


          var Stream = localRequire('./internal/streams/stream');
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = localRequire('safe-buffer').Buffer;

          var OurUint8Array = global.Uint8Array || function () { };

          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }

          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          /*</replacement>*/

          /*<replacement>*/


          var util = Object.create(localRequire('core-util-is'));
          util.inherits = localRequire('inherits');
          /*</replacement>*/

          /*<replacement>*/

          var debugUtil = localRequire('util');
          var debug = void 0;

          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog('stream');
          } else {
            debug = function debug() { };
          }
          /*</replacement>*/


          var BufferList = localRequire('./internal/streams/BufferList');
          var destroyImpl = localRequire('./internal/streams/destroy');
          var StringDecoder;
          util.inherits(Readable, Stream);
          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.

            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [fn, emitter._events[event]];
          }

          function ReadableState(options, stream) {
            Duplex = Duplex || localRequire('./_stream_duplex');
            options = options || {}; // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.

            var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away

            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"

            var hwm = options.highWaterMark;
            var readableHwm = options.readableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm; else this.highWaterMark = defaultHwm; // cast to ints.

            this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()

            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.

            this.sync = true; // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.

            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false; // has it been destroyed

            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.

            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;

            if (options.encoding) {
              if (!StringDecoder) StringDecoder = localRequire('string_decoder/').StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }

          function Readable(options): void {
            Duplex = Duplex || localRequire('./_stream_duplex');
            if (!(this instanceof Readable)) return new Readable(options);
            this._readableState = new ReadableState(options, this); // legacy

            this.readable = true;

            if (options) {
              if (typeof options.read === 'function') this._read = options.read;
              if (typeof options.destroy === 'function') this._destroy = options.destroy;
            }

            Stream.call(this);
          }

          Object.defineProperty(Readable.prototype, 'destroyed', {
            get: function get() {
              if (this._readableState === undefined) {
                return false;
              }

              return this._readableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed


              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;

          Readable.prototype._destroy = function (err, cb) {
            this.push(null);
            cb(err);
          }; // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.


          Readable.prototype.push = function (chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;

            if (!state.objectMode) {
              if (typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding;

                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = '';
                }

                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }

            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          }; // Unshift should *always* be something directly out of read()


          Readable.prototype.unshift = function (chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };

          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState;

            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck) er = chunkInvalid(state, chunk);

              if (er) {
                stream.emit('error', er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }

                if (addToFront) {
                  if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event')); else addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  stream.emit('error', new Error('stream.push() after EOF'));
                } else {
                  state.reading = false;

                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
              }
            }

            return needMoreData(state);
          }

          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);
              if (state.needReadable) emitReadable(stream);
            }

            maybeReadMore(stream, state);
          }

          function chunkInvalid(state, chunk) {
            var er;

            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }

            return er;
          } // if it's past the high water mark, we can push in some more.
          // Also, if we have no data yet, we can stand some
          // more bytes.  This is to work around cases where hwm=0,
          // such as the repl.  Also, if the push() triggered a
          // readable event, and the user called read(largeNumber) such that
          // needReadable was set, then we ought to push more, so that another
          // 'readable' event will be triggered.


          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }

          Readable.prototype.isPaused = function () {
            return this._readableState.flowing === false;
          }; // backwards compatibility.


          Readable.prototype.setEncoding = function (enc) {
            if (!StringDecoder) StringDecoder = localRequire('string_decoder/').StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
          }; // Don't raise the hwm > 8MB


          var MAX_HWM = 0x800000;

          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }

            return n;
          } // This function is designed to be inlinable, so please take care when making
          // changes to the function body.


          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended) return 0;
            if (state.objectMode) return 1;

            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;
            } // If we're asking for more than the current hwm, then raise the hwm.


            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length) return n; // Don't have enough

            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }

            return state.length;
          } // you can override either this method, or the async _read(n) below.


          Readable.prototype.read = function (n) {
            debug('read', n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.

            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              debug('read: emitReadable', state.length, state.ended);
              if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this);
              return null;
            }

            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this);
              return null;
            } // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.
            // if we need a readable event, then we need to do some reading.


            var doRead = state.needReadable;
            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug('length less than watermark', doRead);
            } // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.


            if (state.ended || state.reading) {
              doRead = false;
              debug('reading or ended', doRead);
            } else if (doRead) {
              debug('do read');
              state.reading = true;
              state.sync = true; // if the length is currently zero, then we *need* a readable event.

              if (state.length === 0) state.needReadable = true; // call internal read method

              this._read(state.highWaterMark);

              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.

              if (!state.reading) n = howMuchToRead(nOrig, state);
            }

            var ret;
            if (n > 0) ret = fromList(n, state); else ret = null;

            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
            }

            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

              if (nOrig !== n && state.ended) endReadable(this);
            }

            if (ret !== null) this.emit('data', ret);
            return ret;
          };

          function onEofChunk(stream, state) {
            if (state.ended) return;

            if (state.decoder) {
              var chunk = state.decoder.end();

              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }

            state.ended = true; // emit 'readable' now to make sure it gets picked up.

            emitReadable(stream);
          } // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.


          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;

            if (!state.emittedReadable) {
              debug('emitReadable', state.flowing);
              state.emittedReadable = true;
              if (state.sync) pna.nextTick(emitReadable_, stream); else emitReadable_(stream);
            }
          }

          function emitReadable_(stream) {
            debug('emit readable');
            stream.emit('readable');
            flow(stream);
          } // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.


          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              pna.nextTick(maybeReadMore_, stream, state);
            }
          }

          function maybeReadMore_(stream, state) {
            var len = state.length;

            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              debug('maybeReadMore read 0');
              stream.read(0);
              if (len === state.length) // didn't get any data, stop spinning.
                break; else len = state.length;
            }

            state.readingMore = false;
          } // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.


          Readable.prototype._read = function (n) {
            this.emit('error', new Error('_read() is not implemented'));
          };

          Readable.prototype.pipe = function (dest, pipeOpts) {
            var src = this;
            var state = this._readableState;

            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;

              case 1:
                state.pipes = [state.pipes, dest];
                break;

              default:
                state.pipes.push(dest);
                break;
            }

            state.pipesCount += 1;
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted) pna.nextTick(endFn); else src.once('end', endFn);
            dest.on('unpipe', onunpipe);

            function onunpipe(readable, unpipeInfo) {
              debug('onunpipe');

              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }

            function onend() {
              debug('onend');
              dest.end();
            } // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.


            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);
            var cleanedUp = false;

            function cleanup() {
              debug('cleanup'); // cleanup event handlers once the pipe is broken

              dest.removeListener('close', onclose);
              dest.removeListener('finish', onfinish);
              dest.removeListener('drain', ondrain);
              dest.removeListener('error', onerror);
              dest.removeListener('unpipe', onunpipe);
              src.removeListener('end', onend);
              src.removeListener('end', unpipe);
              src.removeListener('data', ondata);
              cleanedUp = true; // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.

              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
            } // If the user pushes more data while we're writing to dest then we'll end up
            // in ondata again. However, we only want to increase awaitDrain once because
            // dest will only emit one 'drain' event for the multiple writes.
            // => Introduce a guard on increasing awaitDrain.


            var increasedAwaitDrain = false;
            src.on('data', ondata);

            function ondata(chunk) {
              debug('ondata');
              increasedAwaitDrain = false;
              var ret = dest.write(chunk);

              if (false === ret && !increasedAwaitDrain) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug('false write response, pause', src._readableState.awaitDrain);
                  src._readableState.awaitDrain++;
                  increasedAwaitDrain = true;
                }

                src.pause();
              }
            } // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.


            function onerror(er) {
              debug('onerror', er);
              unpipe();
              dest.removeListener('error', onerror);
              if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
            } // Make sure our error handler is attached before userland ones.


            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

            function onclose() {
              dest.removeListener('finish', onfinish);
              unpipe();
            }

            dest.once('close', onclose);

            function onfinish() {
              debug('onfinish');
              dest.removeListener('close', onclose);
              unpipe();
            }

            dest.once('finish', onfinish);

            function unpipe() {
              debug('unpipe');
              src.unpipe(dest);
            } // tell the dest that it's being piped to


            dest.emit('pipe', src); // start the flow if it hasn't been started already.

            if (!state.flowing) {
              debug('pipe resume');
              src.resume();
            }

            return dest;
          };

          function pipeOnDrain(src) {
            return function () {
              var state = src._readableState;
              debug('pipeOnDrain', state.awaitDrain);
              if (state.awaitDrain) state.awaitDrain--;

              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                state.flowing = true;
                flow(src);
              }
            };
          }

          Readable.prototype.unpipe = function (dest) {
            var state = this._readableState;
            var unpipeInfo = {
              hasUnpiped: false
            }; // if we're not piping anywhere, then do nothing.

            if (state.pipesCount === 0) return this; // just one destination.  most common case.

            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this;
              if (!dest) dest = state.pipes; // got a match.

              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest) dest.emit('unpipe', this, unpipeInfo);
              return this;
            } // slow case. multiple pipe destinations.


            if (!dest) {
              // remove all.
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;

              for (var i = 0; i < len; i++) {
                dests[i].emit('unpipe', this, unpipeInfo);
              }

              return this;
            } // try to find the right one.


            var index = indexOf(state.pipes, dest);
            if (index === -1) return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1) state.pipes = state.pipes[0];
            dest.emit('unpipe', this, unpipeInfo);
            return this;
          }; // set up data events if they are asked for
          // Ensure readable listeners eventually get something


          Readable.prototype.on = function (ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);

            if (ev === 'data') {
              // Start flowing on next tick if stream isn't explicitly paused
              if (this._readableState.flowing !== false) this.resume();
            } else if (ev === 'readable') {
              var state = this._readableState;

              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.emittedReadable = false;

                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this);
                } else if (state.length) {
                  emitReadable(this);
                }
              }
            }

            return res;
          };

          Readable.prototype.addListener = Readable.prototype.on;

          function nReadingNextTick(self) {
            debug('readable nexttick read 0');
            self.read(0);
          } // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.


          Readable.prototype.resume = function () {
            var state = this._readableState;

            if (!state.flowing) {
              debug('resume');
              state.flowing = true;
              resume(this, state);
            }

            return this;
          };

          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              pna.nextTick(resume_, stream, state);
            }
          }

          function resume_(stream, state) {
            if (!state.reading) {
              debug('resume read 0');
              stream.read(0);
            }

            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit('resume');
            flow(stream);
            if (state.flowing && !state.reading) stream.read(0);
          }

          Readable.prototype.pause = function () {
            debug('call pause flowing=%j', this._readableState.flowing);

            if (false !== this._readableState.flowing) {
              debug('pause');
              this._readableState.flowing = false;
              this.emit('pause');
            }

            return this;
          };

          function flow(stream) {
            var state = stream._readableState;
            debug('flow', state.flowing);

            while (state.flowing && stream.read() !== null) { }
          } // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.


          Readable.prototype.wrap = function (stream) {
            var _this = this;

            var state = this._readableState;
            var paused = false;
            stream.on('end', function () {
              debug('wrapped end');

              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) _this.push(chunk);
              }

              _this.push(null);
            });
            stream.on('data', function (chunk) {
              debug('wrapped data');
              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

              if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return;

              var ret = _this.push(chunk);

              if (!ret) {
                paused = true;
                stream.pause();
              }
            }); // proxy all the other methods.
            // important when wrapping filters and duplexes.

            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === 'function') {
                this[i] = function (method) {
                  return function () {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            } // proxy certain important events.


            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            } // when we try to consume some more bytes, simply unpause the
            // underlying stream.


            this._read = function (n) {
              debug('wrapped _read', n);

              if (paused) {
                paused = false;
                stream.resume();
              }
            };

            return this;
          };

          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          }); // exposed for testing purposes only.

          (<any>Readable)._fromList = fromList; // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.

          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null;
            var ret;
            if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join(''); else if (state.buffer.length === 1) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              // read part of list
              ret = fromListPartial(n, state.buffer, state.decoder);
            }
            return ret;
          } // Extracts only enough buffered data to satisfy the amount requested.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.


          function fromListPartial(n, list, hasStrings) {
            var ret;

            if (n < list.head.data.length) {
              // slice is the same for buffers and strings
              ret = list.head.data.slice(0, n);
              list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
              // first chunk is a perfect match
              ret = list.shift();
            } else {
              // result spans more than one buffer
              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            }

            return ret;
          } // Copies a specified amount of characters from the list of buffered data
          // chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.


          function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;

            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str; else ret += str.slice(0, n);
              n -= nb;

              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) list.head = p.next; else list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = str.slice(nb);
                }

                break;
              }

              ++c;
            }

            list.length -= c;
            return ret;
          } // Copies a specified amount of bytes from the list of buffered data chunks.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.


          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;

            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;

              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) list.head = p.next; else list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = buf.slice(nb);
                }

                break;
              }

              ++c;
            }

            list.length -= c;
            return ret;
          }

          function endReadable(stream) {
            var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
            // bug in node.  Should never happen.

            if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

            if (!state.endEmitted) {
              state.ended = true;
              pna.nextTick(endReadableNT, state, stream);
            }
          }

          function endReadableNT(state, stream) {
            // Check that we didn't get one last unshift.
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit('end');
            }
          }

          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i;
            }

            return -1;
          }
        }).call(this);
      }).call(this, localRequire('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "./_stream_duplex": 231,
      "./internal/streams/BufferList": 236,
      "./internal/streams/destroy": 237,
      "./internal/streams/stream": 238,
      "_process": 229,
      "core-util-is": 209,
      "events": 210,
      "inherits": 212,
      "isarray": 214,
      "process-nextick-args": 228,
      "safe-buffer": 243,
      "string_decoder/": 245,
      "util": 148
    }],
    234: [function (localRequire, localModule, localExports) {

      localModule.localExports = Transform;
      var Duplex = localRequire('./_stream_duplex');
      /*<replacement>*/

      var util = Object.create(localRequire('core-util-is'));
      util.inherits = localRequire('inherits');
      /*</replacement>*/

      util.inherits(Transform, Duplex);

      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;

        if (!cb) {
          return this.emit('error', new Error('write callback called multiple times'));
        }

        ts.writechunk = null;
        ts.writecb = null;
        if (data != null) // single equals check for both `null` and `undefined`
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;

        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }

      function Transform(options): void {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }; // start out asking for a readable event once data is transformed.

        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.

        this._readableState.sync = false;

        if (options) {
          if (typeof options.transform === 'function') this._transform = options.transform;
          if (typeof options.flush === 'function') this._flush = options.flush;
        } // When the writable side finishes, then flush out anything remaining.


        this.on('prefinish', prefinish);
      }

      function prefinish() {
        var _this = this;

        if (typeof this._flush === 'function') {
          this._flush(function (er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }

      Transform.prototype.push = function (chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      }; // This is the part where you do stuff!
      // override this function in implementation classes.
      // 'chunk' is an input chunk.
      //
      // Call `push(newChunk)` to pass along transformed output
      // to the readable side.  You may call 'push' zero or more times.
      //
      // Call `cb(err)` when you are done with this chunk.  If you pass
      // an error, then that'll put the hurt on the whole operation.  If you
      // never call cb(), then you'll never get another chunk.


      Transform.prototype._transform = function (chunk, encoding, cb) {
        throw new Error('_transform() is not implemented');
      };

      Transform.prototype._write = function (chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;

        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      }; // Doesn't matter what the args are here.
      // _transform does all the work.
      // That we got here means that the readable side wants more data.


      Transform.prototype._read = function (n) {
        var ts = this._transformState;

        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;

          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          // mark that we need a transform, so that any data that comes in
          // will get processed, now that we've asked for it.
          ts.needTransform = true;
        }
      };

      Transform.prototype._destroy = function (err, cb) {
        var _this2 = this;

        Duplex.prototype._destroy.call(this, err, function (err2) {
          cb(err2);

          _this2.emit('close');
        });
      };

      function done(stream, er, data) {
        if (er) return stream.emit('error', er);
        if (data != null) // single equals check for both `null` and `undefined`
          stream.push(data); // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided

        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
        return stream.push(null);
      }
    }, {
      "./_stream_duplex": 231,
      "core-util-is": 209,
      "inherits": 212
    }],
    235: [function (localRequire, localModule, localExports) {
      (function (process, global, setImmediate) {
        (function () {
          /*<replacement>*/

          var pna = localRequire('process-nextick-args');
          /*</replacement>*/

          localModule.localExports = Writable;
          // there will be only 2 of these for each stream


          function CorkedRequest(state) {
            var _this = this;

            this.next = null;
            this.entry = null;

            this.finish = function () {
              onCorkedFinish(_this, state);
            };
          }
          /* </replacement> */

          /*<replacement>*/


          var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
          /*</replacement>*/

          /*<replacement>*/

          var Duplex;
          /*</replacement>*/

          (<any>Writable).WritableState = WritableState;
          /*<replacement>*/

          var util = Object.create(localRequire('core-util-is'));
          util.inherits = localRequire('inherits');
          /*</replacement>*/

          /*<replacement>*/

          var internalUtil = {
            deprecate: localRequire('util-deprecate')
          };
          /*</replacement>*/

          /*<replacement>*/

          var Stream = localRequire('./internal/streams/stream');
          /*</replacement>*/

          /*<replacement>*/

          var Buffer = localRequire('safe-buffer').Buffer;

          var OurUint8Array = global.Uint8Array || function () { };

          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }

          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          /*</replacement>*/


          var destroyImpl = localRequire('./internal/streams/destroy');
          util.inherits(Writable, Stream);

          function nop() { }

          function WritableState(options, stream) {
            Duplex = Duplex || localRequire('./_stream_duplex');
            options = options || {}; // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.

            var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
            // contains buffers or objects.

            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()

            var hwm = options.highWaterMark;
            var writableHwm = options.writableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0) this.highWaterMark = hwm; else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm; else this.highWaterMark = defaultHwm; // cast to ints.

            this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

            this.finalCalled = false; // drain event flag.

            this.needDrain = false; // at the start of calling end()

            this.ending = false; // when end() has been called, and returned

            this.ended = false; // when 'finish' is emitted

            this.finished = false; // has it been destroyed

            this.destroyed = false; // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.

            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.

            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.

            this.length = 0; // a flag to see when we're in the middle of a write.

            this.writing = false; // when true all writes will be buffered until .uncork() call

            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.

            this.sync = true; // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.

            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

            this.onwrite = function (er) {
              onwrite(stream, er);
            }; // the callback that the user supplies to write(chunk,encoding,cb)


            this.writecb = null; // the amount that is being written when _write is called.

            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted

            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams

            this.prefinished = false; // True if the error was already emitted and should not be thrown again

            this.errorEmitted = false; // count buffered requests

            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two

            this.corkedRequestsFree = new CorkedRequest(this);
          }

          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];

            while (current) {
              out.push(current);
              current = current.next;
            }

            return out;
          };

          (function () {
            try {
              Object.defineProperty(WritableState.prototype, 'buffer', {
                get: internalUtil.deprecate(function () {
                  return this.getBuffer();
                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
              });
            } catch (_) { }
          })(); // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.


          var realHasInstance;

          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function value(object) {
                if (realHasInstance.call(this, object)) return true;
                if (this !== Writable) return false;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function realHasInstance(object) {
              return object instanceof this;
            };
          }

          function Writable(options): void {
            Duplex = Duplex || localRequire('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.
            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.

            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
              return new Writable(options);
            }

            this._writableState = new WritableState(options, this); // legacy.

            this.writable = true;

            if (options) {
              if (typeof options.write === 'function') this._write = options.write;
              if (typeof options.writev === 'function') this._writev = options.writev;
              if (typeof options.destroy === 'function') this._destroy = options.destroy;
              if (typeof options.final === 'function') this._final = options.final;
            }

            Stream.call(this);
          } // Otherwise people can pipe Writable streams, which is just wrong.


          Writable.prototype.pipe = function () {
            this.emit('error', new Error('Cannot pipe, not readable'));
          };

          function writeAfterEnd(stream, cb) {
            var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

            stream.emit('error', er);
            pna.nextTick(cb, er);
          } // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.


          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er: any = false;

            if (chunk === null) {
              er = new TypeError('May not write null values to stream');
            } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new TypeError('Invalid non-string/buffer chunk');
            }

            if (er) {
              stream.emit('error', er);
              pna.nextTick(cb, er);
              valid = false;
            }

            return valid;
          }

          Writable.prototype.write = function (chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;

            var isBuf = !state.objectMode && _isUint8Array(chunk);

            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }

            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }

            if (isBuf) encoding = 'buffer'; else if (!encoding) encoding = state.defaultEncoding;
            if (typeof cb !== 'function') cb = nop;
            if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };

          Writable.prototype.cork = function () {
            var state = this._writableState;
            state.corked++;
          };

          Writable.prototype.uncork = function () {
            var state = this._writableState;

            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
            }
          };

          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === 'string') encoding = encoding.toLowerCase();
            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };

          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = Buffer.from(chunk, encoding);
            }

            return chunk;
          }

          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          }); // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.

          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);

              if (chunk !== newChunk) {
                isBuf = true;
                encoding = 'buffer';
                chunk = newChunk;
              }
            }

            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

            if (!ret) state.needDrain = true;

            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              };

              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }

              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }

            return ret;
          }

          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }

          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;

            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              pna.nextTick(cb, er); // this can emit finish, and it will always happen
              // after error

              pna.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              stream.emit('error', er);
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er);
              stream._writableState.errorEmitted = true;
              stream.emit('error', er); // this can emit finish, but finish must
              // always follow error

              finishMaybe(stream, state);
            }
          }

          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }

          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er) onwriteError(stream, state, sync, er, cb); else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state);

              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }

              if (sync) {
                /*<replacement>*/
                asyncWrite(afterWrite, stream, state, finished, cb);
                /*</replacement>*/
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }

          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          } // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.


          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          } // if there's something in the buffer waiting, then process it


          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;

            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;

              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf) allBuffers = false;
                entry = entry.next;
                count += 1;
              }

              (<any>buffer).allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite

              state.pendingcb++;
              state.lastBufferedRequest = null;

              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }

              state.bufferedRequestCount = 0;
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.

                if (state.writing) {
                  break;
                }
              }

              if (entry === null) state.lastBufferedRequest = null;
            }

            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }

          Writable.prototype._write = function (chunk, encoding, cb) {
            cb(new Error('_write() is not implemented'));
          };

          Writable.prototype._writev = null;

          Writable.prototype.end = function (chunk, encoding, cb) {
            var state = this._writableState;

            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }

            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

            if (state.corked) {
              state.corked = 1;
              this.uncork();
            } // ignore unnecessary end() calls.


            if (!state.ending && !state.finished) endWritable(this, state, cb);
          };

          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }

          function callFinal(stream, state) {
            stream._final(function (err) {
              state.pendingcb--;

              if (err) {
                stream.emit('error', err);
              }

              state.prefinished = true;
              stream.emit('prefinish');
              finishMaybe(stream, state);
            });
          }

          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === 'function') {
                state.pendingcb++;
                state.finalCalled = true;
                pna.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit('prefinish');
              }
            }
          }

          function finishMaybe(stream, state) {
            var need = needFinish(state);

            if (need) {
              prefinish(stream, state);

              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit('finish');
              }
            }

            return need;
          }

          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);

            if (cb) {
              if (state.finished) pna.nextTick(cb); else stream.once('finish', cb);
            }

            state.ended = true;
            stream.writable = false;
          }

          function onCorkedFinish(corkReq, state, err?) {
            var entry = corkReq.entry;
            corkReq.entry = null;

            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }

            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq;
            } else {
              state.corkedRequestsFree = corkReq;
            }
          }

          Object.defineProperty(Writable.prototype, 'destroyed', {
            get: function get() {
              if (this._writableState === undefined) {
                return false;
              }

              return this._writableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed


              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;

          Writable.prototype._destroy = function (err, cb) {
            this.end();
            cb(err);
          };
        }).call(this);
      }).call(this, localRequire('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, localRequire("timers").setImmediate);
    }, {
      "./_stream_duplex": 231,
      "./internal/streams/destroy": 237,
      "./internal/streams/stream": 238,
      "_process": 229,
      "core-util-is": 209,
      "inherits": 212,
      "process-nextick-args": 228,
      "safe-buffer": 243,
      "timers": 246,
      "util-deprecate": 247
    }],
    236: [function (localRequire, localModule, localExports) {

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var Buffer = localRequire('safe-buffer').Buffer;
      var util = localRequire('util');

      function copyBuffer(src, target, offset) {
        src.copy(target, offset);
      }

      localModule.localExports = function () {
        function BufferList() {
          _classCallCheck(this, BufferList);

          this.head = null;
          this.tail = null;
          this.length = 0;
        }

        BufferList.prototype.push = function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry; else this.head = entry;
          this.tail = entry;
          ++this.length;
        };

        BufferList.prototype.unshift = function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        };

        BufferList.prototype.shift = function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next;
          --this.length;
          return ret;
        };

        BufferList.prototype.clear = function clear() {
          this.head = this.tail = null;
          this.length = 0;
        };

        BufferList.prototype.join = function join(s) {
          if (this.length === 0) return '';
          var p = this.head;
          var ret = '' + p.data;

          while (p = p.next) {
            ret += s + p.data;
          }

          return ret;
        };

        BufferList.prototype.concat = function concat(n) {
          if (this.length === 0) return Buffer.alloc(0);
          if (this.length === 1) return this.head.data;
          var ret = Buffer.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;

          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }

          return ret;
        };

        return BufferList;
      }();

      if (util && util.inspect && util.inspect.custom) {
        localModule.localExports.prototype[util.inspect.custom] = function () {
          var obj = util.inspect({
            length: this.length
          });
          return this.constructor.name + ' ' + obj;
        };
      }
    }, {
      "safe-buffer": 243,
      "util": 148
    }],
    237: [function (localRequire, localModule, localExports) {
      /*<replacement>*/

      var pna = localRequire('process-nextick-args');
      /*</replacement>*/
      // undocumented cb() API, needed for core, not for public API

      function destroy(err, cb) {
        var _this = this;

        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;

        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
            pna.nextTick(emitErrorNT, this, err);
          }

          return this;
        } // we set destroyed to true before firing error callbacks in order
        // to make it re-entrance safe in case destroy() is called within callbacks


        if (this._readableState) {
          this._readableState.destroyed = true;
        } // if this is a duplex stream mark the writable part as destroyed as well


        if (this._writableState) {
          this._writableState.destroyed = true;
        }

        this._destroy(err || null, function (err) {
          if (!cb && err) {
            pna.nextTick(emitErrorNT, _this, err);

            if (_this._writableState) {
              _this._writableState.errorEmitted = true;
            }
          } else if (cb) {
            cb(err);
          }
        });

        return this;
      }

      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }

        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }

      function emitErrorNT(self, err) {
        self.emit('error', err);
      }

      localModule.localExports = {
        destroy: destroy,
        undestroy: undestroy
      };
    }, {
      "process-nextick-args": 228
    }],
    238: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire('events').EventEmitter;
    }, {
      "events": 210
    }],
    239: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire('./readable').PassThrough;
    }, {
      "./readable": 240
    }],
    240: [function (localRequire, localModule, localExports) {
      localExports = localModule.localExports = localRequire('./lib/_stream_readable.js');
      localExports.Stream = localExports;
      localExports.Readable = localExports;
      localExports.Writable = localRequire('./lib/_stream_writable.js');
      localExports.Duplex = localRequire('./lib/_stream_duplex.js');
      localExports.Transform = localRequire('./lib/_stream_transform.js');
      localExports.PassThrough = localRequire('./lib/_stream_passthrough.js');
    }, {
      "./lib/_stream_duplex.js": 231,
      "./lib/_stream_passthrough.js": 232,
      "./lib/_stream_readable.js": 233,
      "./lib/_stream_transform.js": 234,
      "./lib/_stream_writable.js": 235
    }],
    241: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire('./readable').Transform;
    }, {
      "./readable": 240
    }],
    242: [function (localRequire, localModule, localExports) {
      localModule.localExports = localRequire('./lib/_stream_writable.js');
    }, {
      "./lib/_stream_writable.js": 235
    }],
    243: [function (localRequire, localModule, localExports) {
      /* eslint-disable node/no-deprecated-api */
      var buffer = localRequire('buffer');
      var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }

      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        localModule.localExports = buffer;
      } else {
        // Copy properties from require('buffer')
        copyProps(buffer, localExports);
        localExports.Buffer = SafeBuffer;
      }

      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      } // Copy static methods from Buffer


      copyProps(Buffer, SafeBuffer);

      (<any>SafeBuffer).from = function (arg, encodingOrOffset, length) {
        if (typeof arg === 'number') {
          throw new TypeError('Argument must not be a number');
        }

        return Buffer(arg, encodingOrOffset, length);
      };

      (<any>SafeBuffer).alloc = function (size, fill, encoding) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        var buf = Buffer(size);

        if (fill !== undefined) {
          if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }

        return buf;
      };

      (<any>SafeBuffer).allocUnsafe = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        return Buffer(size);
      };

      (<any>SafeBuffer).allocUnsafeSlow = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }

        return buffer.SlowBuffer(size);
      };
    }, {
      "buffer": 152
    }],
    244: [function (localRequire, localModule, localExports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      localModule.localExports = Stream;
      var EE = localRequire('events').EventEmitter;
      var inherits = localRequire('inherits');
      inherits(Stream, EE);
      (<any>Stream).Readable = localRequire('readable-stream/readable.js');
      (<any>Stream).Writable = localRequire('readable-stream/writable.js');
      (<any>Stream).Duplex = localRequire('readable-stream/duplex.js');
      (<any>Stream).Transform = localRequire('readable-stream/transform.js');
      (<any>Stream).PassThrough = localRequire('readable-stream/passthrough.js'); // Backwards-compat with node 0.4.x

      (<any>Stream).Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
      // part of this class) is overridden in the Readable class.

      function Stream() {
        EE.call(this);
      }

      Stream.prototype.pipe = function (dest, options) {
        var source = this;

        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }

        source.on('data', ondata);

        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }

        dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
        // source gets the 'end' or 'close' events.  Only dest.end() once.

        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on('end', onend);
          source.on('close', onclose);
        }

        var didOnEnd = false;

        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }

        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === 'function') dest.destroy();
        } // don't leave dangling pipes when there are errors.


        function onerror(er) {
          cleanup();

          if (EE.listenerCount(this, 'error') === 0) {
            throw er; // Unhandled stream error in pipe.
          }
        }

        source.on('error', onerror);
        dest.on('error', onerror); // remove all the event listeners that were added.

        function cleanup() {
          source.removeListener('data', ondata);
          dest.removeListener('drain', ondrain);
          source.removeListener('end', onend);
          source.removeListener('close', onclose);
          source.removeListener('error', onerror);
          dest.removeListener('error', onerror);
          source.removeListener('end', cleanup);
          source.removeListener('close', cleanup);
          dest.removeListener('close', cleanup);
        }

        source.on('end', cleanup);
        source.on('close', cleanup);
        dest.on('close', cleanup);
        dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

        return dest;
      };
    }, {
      "events": 210,
      "inherits": 212,
      "readable-stream/duplex.js": 230,
      "readable-stream/passthrough.js": 239,
      "readable-stream/readable.js": 240,
      "readable-stream/transform.js": 241,
      "readable-stream/writable.js": 242
    }],
    245: [function (localRequire, localModule, localExports) {
      /*<replacement>*/

      var Buffer = localRequire('safe-buffer').Buffer;
      /*</replacement>*/

      var isEncoding = Buffer.isEncoding || function (encoding) {
        encoding = '' + encoding;

        switch (encoding && encoding.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return true;

          default:
            return false;
        }
      };

      function _normalizeEncoding(enc) {
        if (!enc) return 'utf8';
        var retried;

        while (true) {
          switch (enc) {
            case 'utf8':
            case 'utf-8':
              return 'utf8';

            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 'utf16le';

            case 'latin1':
            case 'binary':
              return 'latin1';

            case 'base64':
            case 'ascii':
            case 'hex':
              return enc;

            default:
              if (retried) return; // undefined

              enc = ('' + enc).toLowerCase();
              retried = true;
          }
        }
      }
      // modules monkey-patch it to support additional encodings

      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);

        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
        return nenc || enc;
      } // StringDecoder provides an interface for efficiently splitting a series of
      // buffers into a series of JS strings without breaking apart multi-byte
      // characters.


      localExports.StringDecoder = StringDecoder;

      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;

        switch (this.encoding) {
          case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;

          case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;

          case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;

          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }

        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
      }

      StringDecoder.prototype.write = function (buf) {
        if (buf.length === 0) return '';
        var r;
        var i;

        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === undefined) return '';
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }

        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || '';
      };

      StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

      StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

      StringDecoder.prototype.fillLast = function (buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }

        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
      // continuation byte. If an invalid byte is detected, -2 is returned.


      function utf8CheckByte(byte) {
        if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4;
        return byte >> 6 === 0x02 ? -1 : -2;
      } // Checks at most 3 bytes at the end of a Buffer in order to detect an
      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
      // needed to complete the UTF-8 character (if applicable) are returned.


      function utf8CheckIncomplete(self, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);

        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 1;
          return nb;
        }

        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);

        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 2;
          return nb;
        }

        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);

        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0; else self.lastNeed = nb - 3;
          }

          return nb;
        }

        return 0;
      } // Validates as many continuation bytes for a multi-byte UTF-8 character as
      // needed or are available. If we see a non-continuation byte where we expect
      // one, we "replace" the validated continuation bytes we've seen so far with
      // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
      // behavior. The continuation byte check is included three times in the case
      // where all of the continuation bytes for a character exist in the same buffer.
      // It is also done this way as a slight performance increase instead of using a
      // loop.


      function utf8CheckExtraBytes(self, buf, p?) {
        if ((buf[0] & 0xC0) !== 0x80) {
          self.lastNeed = 0;
          return "\uFFFD";
        }

        if (self.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "\uFFFD";
          }

          if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
              self.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf);
        if (r !== undefined) return r;

        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }

        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
      // partial character, the character's bytes are buffered until the required
      // number of bytes are available.


      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString('utf8', i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString('utf8', i, end);
      } // For UTF-8, a replacement character is added when ending on a partial
      // character.


      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + "\uFFFD";
        return r;
      } // UTF-16LE typically needs two bytes per character, but even if we have an even
      // number of bytes available, we need to check if we end on a leading/high
      // surrogate. In that case, we need to wait for the next two bytes in order to
      // decode the last character properly.


      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString('utf16le', i);

          if (r) {
            var c = r.charCodeAt(r.length - 1);

            if (c >= 0xD800 && c <= 0xDBFF) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }

          return r;
        }

        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString('utf16le', i, buf.length - 1);
      } // For UTF-16LE we do not explicitly append special replacement characters if we
      // end on a partial character, we simply let v8 handle that.


      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';

        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString('utf16le', 0, end);
        }

        return r;
      }

      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString('base64', i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;

        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }

        return buf.toString('base64', i, buf.length - n);
      }

      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
        return r;
      } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }

      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : '';
      }
    }, {
      "safe-buffer": 243
    }],
    246: [function (localRequire, localModule, localExports) {
      (function (setImmediate, clearImmediate) {
        (function () {
          var nextTick = localRequire('process/browser.js').nextTick;
          var apply = Function.prototype.apply;
          var slice = Array.prototype.slice;
          var immediateIds = {};
          var nextImmediateId = 0; // DOM APIs, for completeness

          localExports.setTimeout = function () {
            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
          };

          localExports.setInterval = function () {
            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
          };

          localExports.clearTimeout = localExports.clearInterval = function (timeout) {
            timeout.close();
          };

          function Timeout(id, clearFn) {
            this._id = id;
            this._clearFn = clearFn;
          }

          Timeout.prototype.unref = Timeout.prototype.ref = function () { };

          Timeout.prototype.close = function () {
            this._clearFn.call(window, this._id);
          }; // Does not start the time, just sets up the members needed.


          localExports.enroll = function (item, msecs) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = msecs;
          };

          localExports.unenroll = function (item) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = -1;
          };

          localExports._unrefActive = localExports.active = function (item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;

            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout) item._onTimeout();
              }, msecs);
            }
          }; // That's not how node.js implements it but the exposed api is the same.


          localExports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
            var id = nextImmediateId++;
            var args = arguments.length < 2 ? false : slice.call(arguments, 1);
            immediateIds[id] = true;
            nextTick(function onNextTick() {
              if (immediateIds[id]) {
                // fn.call() is faster so we optimize for the common use-case
                // @see http://jsperf.com/call-apply-segu
                if (args) {
                  fn.apply(null, args);
                } else {
                  fn.call(null);
                } // Prevent ids from leaking


                localExports.clearImmediate(id);
              }
            });
            return id;
          };
          localExports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
            delete immediateIds[id];
          };
        }).call(this);
      }).call(this, localRequire("timers").setImmediate, localRequire("timers").clearImmediate);
    }, {
      "process/browser.js": 229,
      "timers": 246
    }],
    247: [function (localRequire, localModule, localExports) {
      (function (global) {
        (function () {
          /**
           * Module exports.
           */
          localModule.localExports = deprecate;
          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config('noDeprecation')) {
              return fn;
            }

            var warned = false;

            function deprecated() {
              if (!warned) {
                if (config('throwDeprecation')) {
                  throw new Error(msg);
                } else if (config('traceDeprecation')) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }

                warned = true;
              }

              return fn.apply(this, arguments);
            }

            return deprecated;
          }
          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */


          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false;
            } catch (_) {
              return false;
            }

            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === 'true';
          }
        }).call(this);
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    248: [function (localRequire, localModule, localExports) {
      arguments[4][144][0].apply(localExports, arguments);
    }, {
      "dup": 144
    }],
    249: [function (localRequire, localModule, localExports) {
      arguments[4][145][0].apply(localExports, arguments);
    }, {
      "dup": 145
    }],
    250: [function (localRequire, localModule, localExports) {
      arguments[4][146][0].apply(localExports, arguments);
    }, {
      "./support/isBuffer": 249,
      "_process": 229,
      "dup": 146,
      "inherits": 248
    }],
    251: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var key, val, _ref, _ref1;

        localExports.EncodeStream = localRequire('./src/EncodeStream');
        localExports.DecodeStream = localRequire('./src/DecodeStream');
        localExports.Array = localRequire('./src/Array');
        localExports.LazyArray = localRequire('./src/LazyArray');
        localExports.Bitfield = localRequire('./src/Bitfield');
        localExports.Boolean = localRequire('./src/Boolean');
        localExports.Buffer = localRequire('./src/Buffer');
        localExports.Enum = localRequire('./src/Enum');
        localExports.Optional = localRequire('./src/Optional');
        localExports.Reserved = localRequire('./src/Reserved');
        localExports.String = localRequire('./src/String');
        localExports.Struct = localRequire('./src/Struct');
        localExports.VersionedStruct = localRequire('./src/VersionedStruct');
        _ref = localRequire('./src/Number');

        for (key in _ref) {
          val = _ref[key];
          localExports[key] = val;
        }

        _ref1 = localRequire('./src/Pointer');

        for (key in _ref1) {
          val = _ref1[key];
          localExports[key] = val;
        }
      }).call(this);
    }, {
      "./src/Array": 252,
      "./src/Bitfield": 253,
      "./src/Boolean": 254,
      "./src/Buffer": 255,
      "./src/DecodeStream": 256,
      "./src/EncodeStream": 257,
      "./src/Enum": 258,
      "./src/LazyArray": 259,
      "./src/Number": 260,
      "./src/Optional": 261,
      "./src/Pointer": 262,
      "./src/Reserved": 263,
      "./src/String": 264,
      "./src/Struct": 265,
      "./src/VersionedStruct": 266
    }],
    252: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var ArrayT, NumberT, utils;
        NumberT = localRequire('./Number').Number;
        utils = localRequire('./utils');

        ArrayT = function () {
          function ArrayT(type, length, lengthType) {
            this.type = type;
            this.length = length;
            this.lengthType = lengthType != null ? lengthType : 'count';
          }

          ArrayT.prototype.decode = function (stream, parent) {
            var ctx, i, length, pos, res, target, _i;

            pos = stream.pos;
            res = [];
            ctx = parent;

            if (this.length != null) {
              length = utils.resolveLength(this.length, stream, parent);
            }

            if (this.length instanceof NumberT) {
              Object.defineProperties(res, {
                parent: {
                  value: parent
                },
                _startOffset: {
                  value: pos
                },
                _currentOffset: {
                  value: 0,
                  writable: true
                },
                _length: {
                  value: length
                }
              });
              ctx = res;
            }

            if (length == null || this.lengthType === 'bytes') {
              target = length != null ? stream.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;

              while (stream.pos < target) {
                res.push(this.type.decode(stream, ctx));
              }
            } else {
              for (i = _i = 0; _i < length; i = _i += 1) {
                res.push(this.type.decode(stream, ctx));
              }
            }

            return res;
          };

          ArrayT.prototype.size = function (array, ctx) {
            var item, size, _i, _len;

            if (!array) {
              return this.type.size(null, ctx) * utils.resolveLength(this.length, null, ctx);
            }

            size = 0;

            if (this.length instanceof NumberT) {
              size += this.length.size();
              ctx = {
                parent: ctx
              };
            }

            for (_i = 0, _len = array.length; _i < _len; _i++) {
              item = array[_i];
              size += this.type.size(item, ctx);
            }

            return size;
          };

          ArrayT.prototype.encode = function (stream, array, parent) {
            var ctx, i, item, ptr, _i, _len;

            ctx = parent;

            if (this.length instanceof NumberT) {
              ctx = {
                pointers: [],
                startOffset: stream.pos,
                parent: parent
              };
              ctx.pointerOffset = stream.pos + this.size(array, ctx);
              this.length.encode(stream, array.length);
            }

            for (_i = 0, _len = array.length; _i < _len; _i++) {
              item = array[_i];
              this.type.encode(stream, item, ctx);
            }

            if (this.length instanceof NumberT) {
              i = 0;

              while (i < ctx.pointers.length) {
                ptr = ctx.pointers[i++];
                ptr.type.encode(stream, ptr.val);
              }
            }
          };

          return ArrayT;
        }();

        localModule.localExports = ArrayT;
      }).call(this);
    }, {
      "./Number": 260,
      "./utils": 267
    }],
    253: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var Bitfield;

        Bitfield = function () {
          function Bitfield(type, flags) {
            this.type = type;
            this.flags = flags != null ? flags : [];
          }

          Bitfield.prototype.decode = function (stream) {
            var flag, i, res, val, _i, _len, _ref;

            val = this.type.decode(stream);
            res = {};
            _ref = this.flags;

            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              flag = _ref[i];

              if (flag != null) {
                res[flag] = !!(val & 1 << i);
              }
            }

            return res;
          };

          Bitfield.prototype.size = function () {
            return this.type.size();
          };

          Bitfield.prototype.encode = function (stream, keys) {
            var flag, i, val, _i, _len, _ref;

            val = 0;
            _ref = this.flags;

            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              flag = _ref[i];

              if (flag != null) {
                if (keys[flag]) {
                  val |= 1 << i;
                }
              }
            }

            return this.type.encode(stream, val);
          };

          return Bitfield;
        }();

        localModule.localExports = Bitfield;
      }).call(this);
    }, {}],
    254: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var BooleanT;

        BooleanT = function () {
          function BooleanT(type) {
            this.type = type;
          }

          BooleanT.prototype.decode = function (stream, parent) {
            return !!this.type.decode(stream, parent);
          };

          BooleanT.prototype.size = function (val, parent) {
            return this.type.size(val, parent);
          };

          BooleanT.prototype.encode = function (stream, val, parent) {
            return this.type.encode(stream, +val, parent);
          };

          return BooleanT;
        }();

        localModule.localExports = BooleanT;
      }).call(this);
    }, {}],
    255: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var BufferT, NumberT, utils;
        utils = localRequire('./utils');
        NumberT = localRequire('./Number').Number;

        BufferT = function () {
          function BufferT(length) {
            this.length = length;
          }

          BufferT.prototype.decode = function (stream, parent) {
            var length;
            length = utils.resolveLength(this.length, stream, parent);
            return stream.readBuffer(length);
          };

          BufferT.prototype.size = function (val, parent) {
            if (!val) {
              return utils.resolveLength(this.length, null, parent);
            }

            return val.length;
          };

          BufferT.prototype.encode = function (stream, buf, parent) {
            if (this.length instanceof NumberT) {
              this.length.encode(stream, buf.length);
            }

            return stream.writeBuffer(buf);
          };

          return BufferT;
        }();

        localModule.localExports = BufferT;
      }).call(this);
    }, {
      "./Number": 260,
      "./utils": 267
    }],
    256: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {
          // Generated by CoffeeScript 1.7.1
          (function () {
            var DecodeStream, iconv;

            try {
              iconv = localRequire('iconv-lite');
            } catch (_error) { }

            DecodeStream = function () {
              var key;

              function DecodeStream(buffer) {
                this.buffer = buffer;
                this.pos = 0;
                this.length = this.buffer.length;
              }

              (<any>DecodeStream).TYPES = {
                UInt8: 1,
                UInt16: 2,
                UInt24: 3,
                UInt32: 4,
                Int8: 1,
                Int16: 2,
                Int24: 3,
                Int32: 4,
                Float: 4,
                Double: 8
              };

              for (key in Buffer.prototype) {
                if (key.slice(0, 4) === 'read') {
                  (function (key) {
                    var bytes;
                    bytes = (<any>DecodeStream).TYPES[key.replace(/read|[BL]E/g, '')];
                    return DecodeStream.prototype[key] = function () {
                      var ret;
                      ret = this.buffer[key](this.pos);
                      this.pos += bytes;
                      return ret;
                    };
                  })(key);
                }
              }

              DecodeStream.prototype.readString = function (length, encoding) {
                var buf, byte, i, _i, _ref;

                if (encoding == null) {
                  encoding = 'ascii';
                }

                switch (encoding) {
                  case 'utf16le':
                  case 'ucs2':
                  case 'utf8':
                  case 'ascii':
                    return this.buffer.toString(encoding, this.pos, this.pos += length);

                  case 'utf16be':
                    buf = new Buffer(this.readBuffer(length));

                    for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                      byte = buf[i];
                      buf[i] = buf[i + 1];
                      buf[i + 1] = byte;
                    }

                    return buf.toString('utf16le');

                  default:
                    buf = this.readBuffer(length);

                    if (iconv) {
                      try {
                        return iconv.decode(buf, encoding);
                      } catch (_error) { }
                    }

                    return buf;
                }
              };

              DecodeStream.prototype.readBuffer = function (length) {
                return this.buffer.slice(this.pos, this.pos += length);
              };

              DecodeStream.prototype.readUInt24BE = function () {
                return (this.readUInt16BE() << 8) + this.readUInt8();
              };

              DecodeStream.prototype.readUInt24LE = function () {
                return this.readUInt16LE() + (this.readUInt8() << 16);
              };

              DecodeStream.prototype.readInt24BE = function () {
                return (this.readInt16BE() << 8) + this.readUInt8();
              };

              DecodeStream.prototype.readInt24LE = function () {
                return this.readUInt16LE() + (this.readInt8() << 16);
              };

              return DecodeStream;
            }();

            localModule.localExports = DecodeStream;
          }).call(this);
        }).call(this);
      }).call(this, localRequire("buffer").Buffer);
    }, {
      "buffer": 152,
      "iconv-lite": 151
    }],
    257: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {
          // Generated by CoffeeScript 1.7.1
          (function () {
            var DecodeStream,
              EncodeStream,
              iconv,
              stream,
              __hasProp = {}.hasOwnProperty,
              __extends = function __extends(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                  this.constructor = child;
                }

                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };

            stream = localRequire('stream');
            DecodeStream = localRequire('./DecodeStream');

            try {
              iconv = localRequire('iconv-lite');
            } catch (_error) { }

            EncodeStream = function (_super) {
              var key;

              __extends(EncodeStream, _super);

              function EncodeStream(bufferSize) {
                if (bufferSize == null) {
                  bufferSize = 65536;
                }

                (<any>EncodeStream).__super__.constructor.apply(this, arguments);

                this.buffer = new Buffer(bufferSize);
                this.bufferOffset = 0;
                this.pos = 0;
              }

              for (key in Buffer.prototype) {
                if (key.slice(0, 5) === 'write') {
                  (function (key) {
                    var bytes;
                    bytes = +DecodeStream.TYPES[key.replace(/write|[BL]E/g, '')];
                    return EncodeStream.prototype[key] = function (value) {
                      this.ensure(bytes);
                      this.buffer[key](value, this.bufferOffset);
                      this.bufferOffset += bytes;
                      return this.pos += bytes;
                    };
                  })(key);
                }
              }

              EncodeStream.prototype._read = function () { };

              EncodeStream.prototype.ensure = function (bytes) {
                if (this.bufferOffset + bytes > this.buffer.length) {
                  return this.flush();
                }
              };

              EncodeStream.prototype.flush = function () {
                if (this.bufferOffset > 0) {
                  this.push(new Buffer(this.buffer.slice(0, this.bufferOffset)));
                  return this.bufferOffset = 0;
                }
              };

              EncodeStream.prototype.writeBuffer = function (buffer) {
                this.flush();
                this.push(buffer);
                return this.pos += buffer.length;
              };

              EncodeStream.prototype.writeString = function (string, encoding) {
                var buf, byte, i, _i, _ref;

                if (encoding == null) {
                  encoding = 'ascii';
                }

                switch (encoding) {
                  case 'utf16le':
                  case 'ucs2':
                  case 'utf8':
                  case 'ascii':
                    return this.writeBuffer(new Buffer(string, encoding));

                  case 'utf16be':
                    buf = new Buffer(string, 'utf16le');

                    for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                      byte = buf[i];
                      buf[i] = buf[i + 1];
                      buf[i + 1] = byte;
                    }

                    return this.writeBuffer(buf);

                  default:
                    if (iconv) {
                      return this.writeBuffer(iconv.encode(string, encoding));
                    } else {
                      throw new Error('Install iconv-lite to enable additional string encodings.');
                    }

                }
              };

              EncodeStream.prototype.writeUInt24BE = function (val) {
                this.ensure(3);
                this.buffer[this.bufferOffset++] = val >>> 16 & 0xff;
                this.buffer[this.bufferOffset++] = val >>> 8 & 0xff;
                this.buffer[this.bufferOffset++] = val & 0xff;
                return this.pos += 3;
              };

              EncodeStream.prototype.writeUInt24LE = function (val) {
                this.ensure(3);
                this.buffer[this.bufferOffset++] = val & 0xff;
                this.buffer[this.bufferOffset++] = val >>> 8 & 0xff;
                this.buffer[this.bufferOffset++] = val >>> 16 & 0xff;
                return this.pos += 3;
              };

              EncodeStream.prototype.writeInt24BE = function (val) {
                if (val >= 0) {
                  return this.writeUInt24BE(val);
                } else {
                  return this.writeUInt24BE(val + 0xffffff + 1);
                }
              };

              EncodeStream.prototype.writeInt24LE = function (val) {
                if (val >= 0) {
                  return this.writeUInt24LE(val);
                } else {
                  return this.writeUInt24LE(val + 0xffffff + 1);
                }
              };

              EncodeStream.prototype.fill = function (val, length) {
                var buf;

                if (length < this.buffer.length) {
                  this.ensure(length);
                  this.buffer.fill(val, this.bufferOffset, this.bufferOffset + length);
                  this.bufferOffset += length;
                  return this.pos += length;
                } else {
                  buf = new Buffer(length);
                  buf.fill(val);
                  return this.writeBuffer(buf);
                }
              };

              EncodeStream.prototype.end = function () {
                this.flush();
                return this.push(null);
              };

              return EncodeStream;
            }(stream.Readable);

            localModule.localExports = EncodeStream;
          }).call(this);
        }).call(this);
      }).call(this, localRequire("buffer").Buffer);
    }, {
      "./DecodeStream": 256,
      "buffer": 152,
      "iconv-lite": 151,
      "stream": 244
    }],
    258: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var Enum;

        Enum = function () {
          function Enum(type, options) {
            this.type = type;
            this.options = options != null ? options : [];
          }

          Enum.prototype.decode = function (stream) {
            var index;
            index = this.type.decode(stream);
            return this.options[index] || index;
          };

          Enum.prototype.size = function () {
            return this.type.size();
          };

          Enum.prototype.encode = function (stream, val) {
            var index;
            index = this.options.indexOf(val);

            if (index === -1) {
              throw new Error("Unknown option in enum: " + val);
            }

            return this.type.encode(stream, index);
          };

          return Enum;
        }();

        localModule.localExports = Enum;
      }).call(this);
    }, {}],
    259: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var ArrayT,
          LazyArray,
          LazyArrayT,
          NumberT,
          inspect,
          utils,
          __hasProp = {}.hasOwnProperty,
          __extends = function __extends(child, parent) {
            for (var key in parent) {
              if (__hasProp.call(parent, key)) child[key] = parent[key];
            }

            function ctor() {
              this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          };

        ArrayT = localRequire('./Array');
        NumberT = localRequire('./Number').Number;
        utils = localRequire('./utils');
        inspect = localRequire('util').inspect;

        LazyArrayT = function (_super) {
          __extends(LazyArrayT, _super);

          function LazyArrayT() {
            return (<any>LazyArrayT).__super__.constructor.apply(this, arguments);
          }

          LazyArrayT.prototype.decode = function (stream, parent) {
            var length, pos, res;
            pos = stream.pos;
            length = utils.resolveLength(this.length, stream, parent);

            if (this.length instanceof NumberT) {
              parent = {
                parent: parent,
                _startOffset: pos,
                _currentOffset: 0,
                _length: length
              };
            }

            res = new LazyArray(this.type, length, stream, parent);
            stream.pos += length * this.type.size(null, parent);
            return res;
          };

          LazyArrayT.prototype.size = function (val, ctx) {
            if (val instanceof LazyArray) {
              val = val.toArray();
            }

            return (<any>LazyArrayT).__super__.size.call(this, val, ctx);
          };

          LazyArrayT.prototype.encode = function (stream, val, ctx) {
            if (val instanceof LazyArray) {
              val = val.toArray();
            }

            return (<any>LazyArrayT).__super__.encode.call(this, stream, val, ctx);
          };

          return LazyArrayT;
        }(ArrayT);

        LazyArray = function () {
          function LazyArray(type, length, stream, ctx) {
            this.type = type;
            this.length = length;
            this.stream = stream;
            this.ctx = ctx;
            this.base = this.stream.pos;
            this.items = [];
          }

          LazyArray.prototype.get = function (index) {
            var pos;

            if (index < 0 || index >= this.length) {
              return void 0;
            }

            if (this.items[index] == null) {
              pos = this.stream.pos;
              this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
              this.items[index] = this.type.decode(this.stream, this.ctx);
              this.stream.pos = pos;
            }

            return this.items[index];
          };

          LazyArray.prototype.toArray = function () {
            var i, _i, _ref, _results;

            _results = [];

            for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 1) {
              _results.push(this.get(i));
            }

            return _results;
          };

          LazyArray.prototype.inspect = function () {
            return inspect(this.toArray());
          };

          return LazyArray;
        }();

        localModule.localExports = LazyArrayT;
      }).call(this);
    }, {
      "./Array": 252,
      "./Number": 260,
      "./utils": 267,
      "util": 250
    }],
    260: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var DecodeStream,
          Fixed,
          NumberT,
          __hasProp = {}.hasOwnProperty,
          __extends = function __extends(child, parent) {
            for (var key in parent) {
              if (__hasProp.call(parent, key)) child[key] = parent[key];
            }

            function ctor() {
              this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          };

        DecodeStream = localRequire('./DecodeStream');

        NumberT = function () {
          function NumberT(type, endian) {
            this.type = type;
            this.endian = endian != null ? endian : 'BE';
            this.fn = this.type;

            if (this.type[this.type.length - 1] !== '8') {
              this.fn += this.endian;
            }
          }

          NumberT.prototype.size = function () {
            return DecodeStream.TYPES[this.type];
          };

          NumberT.prototype.decode = function (stream) {
            return stream['read' + this.fn]();
          };

          NumberT.prototype.encode = function (stream, val) {
            return stream['write' + this.fn](val);
          };

          return NumberT;
        }();

        localExports.Number = NumberT;
        localExports.uint8 = new NumberT('UInt8');
        localExports.uint16be = localExports.uint16 = new NumberT('UInt16', 'BE');
        localExports.uint16le = new NumberT('UInt16', 'LE');
        localExports.uint24be = localExports.uint24 = new NumberT('UInt24', 'BE');
        localExports.uint24le = new NumberT('UInt24', 'LE');
        localExports.uint32be = localExports.uint32 = new NumberT('UInt32', 'BE');
        localExports.uint32le = new NumberT('UInt32', 'LE');
        localExports.int8 = new NumberT('Int8');
        localExports.int16be = localExports.int16 = new NumberT('Int16', 'BE');
        localExports.int16le = new NumberT('Int16', 'LE');
        localExports.int24be = localExports.int24 = new NumberT('Int24', 'BE');
        localExports.int24le = new NumberT('Int24', 'LE');
        localExports.int32be = localExports.int32 = new NumberT('Int32', 'BE');
        localExports.int32le = new NumberT('Int32', 'LE');
        localExports.floatbe = localExports.float = new NumberT('Float', 'BE');
        localExports.floatle = new NumberT('Float', 'LE');
        localExports.doublebe = localExports.double = new NumberT('Double', 'BE');
        localExports.doublele = new NumberT('Double', 'LE');

        Fixed = function (_super) {
          __extends(Fixed, _super);

          function Fixed(size, endian, fracBits) {
            if (fracBits == null) {
              fracBits = size >> 1;
            }

            (<any>Fixed).__super__.constructor.call(this, "Int" + size, endian);

            this._point = 1 << fracBits;
          }

          Fixed.prototype.decode = function (stream) {
            return (<any>Fixed).__super__.decode.call(this, stream) / this._point;
          };

          Fixed.prototype.encode = function (stream, val) {
            return (<any>Fixed).__super__.encode.call(this, stream, val * this._point | 0);
          };

          return Fixed;
        }(NumberT);

        localExports.Fixed = Fixed;
        localExports.fixed16be = localExports.fixed16 = new Fixed(16, 'BE');
        localExports.fixed16le = new Fixed(16, 'LE');
        localExports.fixed32be = localExports.fixed32 = new Fixed(32, 'BE');
        localExports.fixed32le = new Fixed(32, 'LE');
      }).call(this);
    }, {
      "./DecodeStream": 256
    }],
    261: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var Optional;

        Optional = function () {
          function Optional(type, condition) {
            this.type = type;
            this.condition = condition != null ? condition : true;
          }

          Optional.prototype.decode = function (stream, parent) {
            var condition;
            condition = this.condition;

            if (typeof condition === 'function') {
              condition = condition.call(parent, parent);
            }

            if (condition) {
              return this.type.decode(stream, parent);
            }
          };

          Optional.prototype.size = function (val, parent) {
            var condition;
            condition = this.condition;

            if (typeof condition === 'function') {
              condition = condition.call(parent, parent);
            }

            if (condition) {
              return this.type.size(val, parent);
            } else {
              return 0;
            }
          };

          Optional.prototype.encode = function (stream, val, parent) {
            var condition;
            condition = this.condition;

            if (typeof condition === 'function') {
              condition = condition.call(parent, parent);
            }

            if (condition) {
              return this.type.encode(stream, val, parent);
            }
          };

          return Optional;
        }();

        localModule.localExports = Optional;
      }).call(this);
    }, {}],
    262: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var Pointer, VoidPointer, utils;
        utils = localRequire('./utils');

        Pointer = function () {
          function Pointer(offsetType, type, options) {
            var _base, _base1, _base2, _base3;

            this.offsetType = offsetType;
            this.type = type;
            this.options = options != null ? options : {};

            if (this.type === 'void') {
              this.type = null;
            }

            if ((_base = this.options).type == null) {
              _base.type = 'local';
            }

            if ((_base1 = this.options).allowNull == null) {
              _base1.allowNull = true;
            }

            if ((_base2 = this.options).nullValue == null) {
              _base2.nullValue = 0;
            }

            if ((_base3 = this.options).lazy == null) {
              _base3.lazy = false;
            }

            if (this.options.relativeTo) {
              // GrapeCity begin
              //this.relativeToGetter = new Function('ctx', "return ctx." + this.options.relativeTo);
              if (typeof this.options.relativeTo !== 'function') {
                throw new Error('The relativeTo option must be a function.');
              } // GrapeCity end

            }
          }

          Pointer.prototype.decode = function (stream, ctx) {
            var c, decodeValue, offset, ptr, relative, val;
            offset = this.offsetType.decode(stream, ctx);

            if (offset === this.options.nullValue && this.options.allowNull) {
              return null;
            }

            relative = function () {
              switch (this.options.type) {
                case 'local':
                  return ctx._startOffset;

                case 'immediate':
                  return stream.pos - this.offsetType.size();

                case 'parent':
                  return ctx.parent._startOffset;

                default:
                  c = ctx;

                  while (c.parent) {
                    c = c.parent;
                  }

                  return c._startOffset || 0;
              }
            }.call(this);

            if (this.options.relativeTo) {
              // GrapeCity begin
              //relative += this.relativeToGetter(ctx);
              relative += this.options.relativeTo(ctx); //GrapeCity end
            }

            ptr = offset + relative;

            if (this.type != null) {
              val = null;

              decodeValue = function (_this) {
                return function () {
                  var pos;

                  if (val != null) {
                    return val;
                  }

                  pos = stream.pos;
                  stream.pos = ptr;
                  val = _this.type.decode(stream, ctx);
                  stream.pos = pos;
                  return val;
                };
              }(this);

              if (this.options.lazy) {
                return new utils.PropertyDescriptor({
                  get: decodeValue
                });
              }

              return decodeValue();
            } else {
              return ptr;
            }
          };

          Pointer.prototype.size = function (val, ctx) {
            var parent, type;
            parent = ctx;

            switch (this.options.type) {
              case 'local':
              case 'immediate':
                break;

              case 'parent':
                ctx = ctx.parent;
                break;

              default:
                while (ctx.parent) {
                  ctx = ctx.parent;
                }

            }

            type = this.type;

            if (type == null) {
              if (!(val instanceof VoidPointer)) {
                throw new Error("Must be a VoidPointer");
              }

              type = val.type;
              val = val.value;
            }

            if (val && ctx) {
              ctx.pointerSize += type.size(val, parent);
            }

            return this.offsetType.size();
          };

          Pointer.prototype.encode = function (stream, val, ctx) {
            var parent, relative, type;
            parent = ctx;

            if (val == null) {
              this.offsetType.encode(stream, this.options.nullValue);
              return;
            }

            switch (this.options.type) {
              case 'local':
                relative = ctx.startOffset;
                break;

              case 'immediate':
                relative = stream.pos + this.offsetType.size(val, parent);
                break;

              case 'parent':
                ctx = ctx.parent;
                relative = ctx.startOffset;
                break;

              default:
                relative = 0;

                while (ctx.parent) {
                  ctx = ctx.parent;
                }

            }

            if (this.options.relativeTo) {
              // GrapeCity begin
              //relative += this.relativeToGetter(parent.val);
              relative += this.options.relativeTo(parent.val); // GrapeCity end
            }

            this.offsetType.encode(stream, ctx.pointerOffset - relative);
            type = this.type;

            if (type == null) {
              if (!(val instanceof VoidPointer)) {
                throw new Error("Must be a VoidPointer");
              }

              type = val.type;
              val = val.value;
            }

            ctx.pointers.push({
              type: type,
              val: val,
              parent: parent
            });
            return ctx.pointerOffset += type.size(val, parent);
          };

          return Pointer;
        }();

        VoidPointer = function () {
          function VoidPointer(type, value) {
            this.type = type;
            this.value = value;
          }

          return VoidPointer;
        }();

        localExports.Pointer = Pointer;
        localExports.VoidPointer = VoidPointer;
      }).call(this);
    }, {
      "./utils": 267
    }],
    263: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var Reserved, utils;
        utils = localRequire('./utils');

        Reserved = function () {
          function Reserved(type, count) {
            this.type = type;
            this.count = count != null ? count : 1;
          }

          Reserved.prototype.decode = function (stream, parent) {
            stream.pos += this.size(null, parent);
            return void 0;
          };

          Reserved.prototype.size = function (data, parent) {
            var count;
            count = utils.resolveLength(this.count, null, parent);
            return this.type.size() * count;
          };

          Reserved.prototype.encode = function (stream, val, parent) {
            return stream.fill(0, this.size(val, parent));
          };

          return Reserved;
        }();

        localModule.localExports = Reserved;
      }).call(this);
    }, {
      "./utils": 267
    }],
    264: [function (localRequire, localModule, localExports) {
      (function (Buffer) {
        (function () {
          // Generated by CoffeeScript 1.7.1
          (function () {
            var NumberT, StringT, utils;
            NumberT = localRequire('./Number').Number;
            utils = localRequire('./utils');

            StringT = function () {
              function StringT(length, encoding) {
                this.length = length;
                this.encoding = encoding != null ? encoding : 'ascii';
              }

              StringT.prototype.decode = function (stream, parent) {
                var buffer, encoding, length, pos, string;

                length = function () {
                  if (this.length != null) {
                    return utils.resolveLength(this.length, stream, parent);
                  } else {
                    buffer = stream.buffer, length = stream.length, pos = stream.pos;

                    while (pos < length && buffer[pos] !== 0x00) {
                      ++pos;
                    }

                    return pos - stream.pos;
                  }
                }.call(this);

                encoding = this.encoding;

                if (typeof encoding === 'function') {
                  encoding = encoding.call(parent, parent) || 'ascii';
                }

                string = stream.readString(length, encoding);

                if (this.length == null && stream.pos < stream.length) {
                  stream.pos++;
                }

                return string;
              };

              StringT.prototype.size = function (val, parent) {
                var encoding, size;

                if (!val) {
                  return utils.resolveLength(this.length, null, parent);
                }

                encoding = this.encoding;

                if (typeof encoding === 'function') {
                  encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
                }

                if (encoding === 'utf16be') {
                  encoding = 'utf16le';
                }

                size = Buffer.byteLength(val, encoding);

                if (this.length instanceof NumberT) {
                  size += this.length.size();
                }

                if (this.length == null) {
                  size++;
                }

                return size;
              };

              StringT.prototype.encode = function (stream, val, parent) {
                var encoding;
                encoding = this.encoding;

                if (typeof encoding === 'function') {
                  encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
                }

                if (this.length instanceof NumberT) {
                  this.length.encode(stream, Buffer.byteLength(val, encoding));
                }

                stream.writeString(val, encoding);

                if (this.length == null) {
                  return stream.writeUInt8(0x00);
                }
              };

              return StringT;
            }();

            localModule.localExports = StringT;
          }).call(this);
        }).call(this);
      }).call(this, localRequire("buffer").Buffer);
    }, {
      "./Number": 260,
      "./utils": 267,
      "buffer": 152
    }],
    265: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var Struct, utils;
        utils = localRequire('./utils');

        Struct = function () {
          function Struct(fields) {
            this.fields = fields != null ? fields : {};
          }

          Struct.prototype.decode = function (stream, parent, length) {
            var res, _ref;

            if (length == null) {
              length = 0;
            }

            res = this._setup(stream, parent, length);

            this._parseFields(stream, res, this.fields);

            if ((_ref = this.process) != null) {
              _ref.call(res, stream);
            }

            return res;
          };

          Struct.prototype._setup = function (stream, parent, length) {
            var res;
            res = {};
            Object.defineProperties(res, {
              parent: {
                value: parent
              },
              _startOffset: {
                value: stream.pos
              },
              _currentOffset: {
                value: 0,
                writable: true
              },
              _length: {
                value: length
              }
            });
            return res;
          };

          Struct.prototype._parseFields = function (stream, res, fields) {
            var key, type, val;

            for (key in fields) {
              type = fields[key];

              if (typeof type === 'function') {
                val = type.call(res, res);
              } else {
                val = type.decode(stream, res);
              }

              if (val !== void 0) {
                if (val instanceof utils.PropertyDescriptor) {
                  Object.defineProperty(res, key, val);
                } else {
                  res[key] = val;
                }
              }

              res._currentOffset = stream.pos - res._startOffset;
            }
          };

          Struct.prototype.size = function (val, parent, includePointers) {
            var ctx, key, size, type, _ref;

            if (val == null) {
              val = {};
            }

            if (includePointers == null) {
              includePointers = true;
            }

            ctx = {
              parent: parent,
              val: val,
              pointerSize: 0
            };
            size = 0;
            _ref = this.fields;

            for (key in _ref) {
              type = _ref[key];

              if (type.size != null) {
                size += type.size(val[key], ctx);
              }
            }

            if (includePointers) {
              size += ctx.pointerSize;
            }

            return size;
          };

          Struct.prototype.encode = function (stream, val, parent) {
            var ctx, i, key, ptr, type, _ref, _ref1;

            if ((_ref = this.preEncode) != null) {
              _ref.call(val, stream);
            }

            ctx = {
              pointers: [],
              startOffset: stream.pos,
              parent: parent,
              val: val,
              pointerSize: 0
            };
            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
            _ref1 = this.fields;

            for (key in _ref1) {
              type = _ref1[key];

              if (type.encode != null) {
                type.encode(stream, val[key], ctx);
              }
            }

            i = 0;

            while (i < ctx.pointers.length) {
              ptr = ctx.pointers[i++];
              ptr.type.encode(stream, ptr.val, ptr.parent);
            }
          };

          return Struct;
        }();

        localModule.localExports = Struct;
      }).call(this);
    }, {
      "./utils": 267
    }],
    266: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var Struct,
          VersionedStruct,
          utils,
          __hasProp = {}.hasOwnProperty,
          __extends = function __extends(child, parent) {
            for (var key in parent) {
              if (__hasProp.call(parent, key)) child[key] = parent[key];
            }

            function ctor() {
              this.constructor = child;
            }

            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          };

        Struct = localRequire('./Struct');
        utils = localRequire('./utils'); // GrapeCity

        VersionedStruct = function (_super) {
          __extends(VersionedStruct, _super);

          function VersionedStruct(type, versions) {
            this.type = type;
            this.versions = versions != null ? versions : {};

            if (typeof this.type === 'string') {
              // GrapeCity start
              //this.versionGetter = new Function('parent', "return parent." + this.type);
              //this.versionSetter = new Function('parent', 'version', "return parent." + this.type + " = version");
              var path = this.type.split('.');

              this.versionGetter = function (parent) {
                return utils.resolveValueByPath(parent, path);
              }; // GrapeCity end

            }
          }

          VersionedStruct.prototype.decode = function (stream, parent, length) {
            var fields, res, _ref;

            if (length == null) {
              length = 0;
            }

            res = this._setup(stream, parent, length);

            if (typeof this.type === 'string') {
              res.version = this.versionGetter(parent);
            } else {
              res.version = this.type.decode(stream);
            }

            if (this.versions.header) {
              this._parseFields(stream, res, this.versions.header);
            }

            fields = this.versions[res.version];

            if (fields == null) {
              throw new Error("Unknown version " + res.version);
            }

            if (fields instanceof VersionedStruct) {
              return (<any>fields).decode(stream, parent);
            }

            this._parseFields(stream, res, fields);

            if ((_ref = this.process) != null) {
              _ref.call(res, stream);
            }

            return res;
          };

          VersionedStruct.prototype.size = function (val, parent, includePointers) {
            var ctx, fields, key, size, type, _ref;

            if (includePointers == null) {
              includePointers = true;
            }

            if (!val) {
              throw new Error('Not a fixed size');
            }

            ctx = {
              parent: parent,
              val: val,
              pointerSize: 0
            };
            size = 0;

            if (typeof this.type !== 'string') {
              size += this.type.size(val.version, ctx);
            }

            if (this.versions.header) {
              _ref = this.versions.header;

              for (key in _ref) {
                type = _ref[key];

                if (type.size != null) {
                  size += type.size(val[key], ctx);
                }
              }
            }

            fields = this.versions[val.version];

            if (fields == null) {
              throw new Error("Unknown version " + val.version);
            }

            for (key in fields) {
              type = fields[key];

              if (type.size != null) {
                size += type.size(val[key], ctx);
              }
            }

            if (includePointers) {
              size += ctx.pointerSize;
            }

            return size;
          };

          VersionedStruct.prototype.encode = function (stream, val, parent) {
            var ctx, fields, i, key, ptr, type, _ref, _ref1;

            if ((_ref = this.preEncode) != null) {
              _ref.call(val, stream);
            }

            ctx = {
              pointers: [],
              startOffset: stream.pos,
              parent: parent,
              val: val,
              pointerSize: 0
            };
            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);

            if (typeof this.type !== 'string') {
              this.type.encode(stream, val.version);
            }

            if (this.versions.header) {
              _ref1 = this.versions.header;

              for (key in _ref1) {
                type = _ref1[key];

                if (type.encode != null) {
                  type.encode(stream, val[key], ctx);
                }
              }
            }

            fields = this.versions[val.version];

            for (key in fields) {
              type = fields[key];

              if (type.encode != null) {
                type.encode(stream, val[key], ctx);
              }
            }

            i = 0;

            while (i < ctx.pointers.length) {
              ptr = ctx.pointers[i++];
              ptr.type.encode(stream, ptr.val, ptr.parent);
            }
          };

          return VersionedStruct;
        }(Struct);

        localModule.localExports = VersionedStruct;
      }).call(this);
    }, {
      "./Struct": 265,
      "./utils": 267
    }],
    267: [function (localRequire, localModule, localExports) {
      // Generated by CoffeeScript 1.7.1
      (function () {
        var NumberT, PropertyDescriptor;
        NumberT = localRequire('./Number').Number;

        localExports.resolveLength = function (length, stream, parent) {
          var res;

          if (typeof length === 'number') {
            res = length;
          } else if (typeof length === 'function') {
            res = length.call(parent, parent);
          } else if (parent && typeof length === 'string') {
            res = parent[length];
          } else if (stream && length instanceof NumberT) {
            res = length.decode(stream);
          }

          if (isNaN(res)) {
            throw new Error('Not a fixed size');
          }

          return res;
        }; // GrapeCity begin
        // Usage:
        // resolvePath({ a: { b: 10 } }, 'a.b')
        // resolvePath({ a: { b: 10 } }, ['a', 'b'])


        localExports.resolveValueByPath = function (obj, path) {
          if (typeof path === 'string') {
            path = path.split('.');
          } // return path.reduce(function (p, c) { return p && p[c]; }, obj);


          for (var i = 0, len = path.length; obj != null && i < len; i++) {
            obj = obj[path[i]];
          }

          return obj;
        }; // GrapeCity end


        PropertyDescriptor = function () {
          function PropertyDescriptor(opts) {
            var key, val;

            if (opts == null) {
              opts = {};
            }

            this.enumerable = true;
            this.configurable = true;

            for (key in opts) {
              val = opts[key];
              this[key] = val;
            }
          }

          return PropertyDescriptor;
        }();

        localExports.PropertyDescriptor = PropertyDescriptor;
      }).call(this);
    }, {
      "./Number": 260
    }]
  }, {}, [135])(135);
});

    }
    


    module wijmo.pdf {
    



'use strict';

export function softPdfSecurity(): typeof wijmo.pdf.security {
    return wijmo._getModule('wijmo.pdf.security');
}
    }
    


    module wijmo.pdf {
    

'use strict';

export class _PdfSvgPathHelper {
    /*
    * Updates the absolute coordinates using the given offset and returns an updated path.
    * @param path Path.
    * @param offset Offset.
    */
    public static offset(path: string, offset: wijmo.Point): string {
        var newPath = this._processPath(path, (value, cmd, cmdIdx, argIdx) => {
            value = this._updateOffset(value, offset, cmd, cmdIdx, argIdx);
            return value;
        });
        return newPath;
    }

    /*
    * Updates coordinates using the given scale factor and returns an updated path.
    * @param path Path.
    * @param scale Scale factor.
    */
    public static scale(path: string, scale: number): string {
        var newPath = this._processPath(path, (value, cmd, cmdIdx, argIdx) => {
            if (cmd === 'a' || cmd === 'A') {
                var rm = argIdx % 7;
                if (rm >= 2 && rm <= 4) { // skip 'x-axis-rotation', 'large-arc-flag', 'sweep-flag'
                    return value;
                }
            }

            return value * scale;
        });

        return newPath;
    }

    private static _processPath(path: string, argCallback: (value: number, cmd: string, cmdIdx: number, argIdx: number) => number): string {
        var tkn = this._getTokenizer(path),
            cmd = '',
            res = '',
            argIdx = -1,
            cmdIdx = -1;

        for (var token: string; token = tkn();) {
            if (token.length === 1 && /[a-zA-Z]/.test(token)) { // a command
                cmdIdx++;
                cmd = token;
                argIdx = -1
            } else { // an argument
                argIdx++;
                var newValue = argCallback(parseFloat(token), cmd, cmdIdx, argIdx);
                token = wijmo.toFixed(newValue, 7, false) + '';
            }

            res += token + ' ';
        }

        return res;
    }

    private static _getTokenizer(path: string) {
        var len = path.length,
            i = 0;

        return () => {
            if (i >= len) {
                return ''; // done
            }

            // skip whitespaces
            while ((i < len) && (/\s/.test(path[i]) || path[i] == ',')) {
                i++;
            }

            var j = i;

            // skip numbers
            //    0.1.2 => 0.1, .2
            //-   1-2 => -1, -2
            //    -1e-2-3e-4 => -1e-2, -3e-4
            var hasDigit = false;
            var hasDot = false;
            var hasSign = false;
            while (i < len) {
                var c = path[i];

                var isSign = (c === '-' || c === '+');
                if (isSign) {
                    if ((hasSign || hasDot || hasDigit) && !((i > 1) && (path[i - 1] === 'e' || path[i - 1] === 'E'))) {
                        break;
                    }

                    hasSign = true;
                } else {
                    var isDot = c === '.';
                    if (isDot) {
                        if (hasDot) {
                            break;
                        }

                        hasDot = true;
                    } else {
                        var isDigit = /[0-9eE]/.test(c);
                        if (!isDigit) {
                            break;
                        }
                        hasDigit = true;
                    }
                }

                i++;
            }

            if (i != j) {
                return path.substr(j, i - j);
            }

            return path.substr(i++, 1);
        };
    }

    private static _updateOffset(value: number, offset: wijmo.Point, cmd: string, cmdIdx: number, argIdx: number): number {
        var o = 0;

        switch (cmd) {
            case 'm': // (dx dy)+
                if (cmdIdx === 0) { // SVG specs: if a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates.
                    // inspect only the first group
                    if (argIdx === 0) {
                        o = -1;
                    } else {
                        if (argIdx === 1) {
                            o = 1;
                        }
                    }
                }
                break;

            case 'L': // (x y)+
            case 'M': // (x y)+
            case 'C': // (c1x c1y c2x c2y x y)+
            case 'S': // (x2 y2 x y)+
            case 'Q': // (x1 y1 x y)+
            case 'T': // (x y)+
                o = (argIdx % 2 === 0) ? -1 : 1;
                break;

            case 'A': // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+
                if (argIdx % 7 === 5) { // x
                    o = -1;
                } else {
                    if (argIdx % 7 === 6) { // y
                        o = 1;
                    }
                }
                break;

            case 'H': // x+
                o = -1;
                break;

            case 'V': // y+
                o = 1;
                break;
        }

        return o
            ? (o === -1 ? value + offset.x : value + offset.y)
            : value;
    }
}


    }
    


    module wijmo.pdf {
    

'use strict';

// https://www.w3.org/TR/2018/REC-css-color-3-20180619/#svg-color
const colorNames = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};

// Not depends on DOM when parsing named colors, therefore it is safe to use in Web Workers.
export class _SafeColor extends wijmo.Color {
    constructor(color: string) {
        super(color);
    }

    _parse(c: string): boolean {
        return super._parse(colorNames[c.toLowerCase()] || c);
    }

    static fromString(value: string): wijmo.Color {
        let c = new _SafeColor(null);
        return c._parse(wijmo.asString(value)) ? c : null;
    }
}
    }
    


    module wijmo.pdf {
    

'use strict';

/**
 * Represents the dash pattern used to stroke paths.
 */
export class PdfDashPattern {
    private _dash: number;
    private _gap: number;
    private _phase: number;

    /**
    * Initializes a new instance of the {@link PdfDashPattern} class.
    *
    * @param dash The length of alternating dashes, in points.
    * @param gap The length of alternating gaps, in points.
    * @param phase The distance in the dash pattern to start the dash at, in points.
    */
    constructor(dash: number = null, gap: number = dash, phase: number = 0) {
        this.dash = dash;
        this.gap = gap;
        this.phase = phase;
    }

    /**
    * Gets or sets the length of alternating dashes, in points.
    * The default value is null which indicates no dash pattern, but a solid line.
    */
    public get dash(): number {
        return this._dash;
    }
    public set dash(value: number) {
        this._dash = wijmo.asNumber(value, true, true);
    }

    /**
    * Gets or sets the length of alternating gaps, in points.
    * The default value is equal to {@link dash} which indicates that dashes and gaps will
    * have the same length.
    */
    public get gap(): number {
        return this._gap;
    }
    public set gap(value: number) {
        this._gap = wijmo.asNumber(value, true, true);
    }

    /**
    * Gets or sets the distance in the dash pattern to start the dash at, in points.
    * The default value is 0.
    */
    public get phase(): number {
        return this._phase;
    }
    public set phase(value: number) {
        this._phase = wijmo.asNumber(value, false, true);
    }

    /**
    * Creates a copy of this {@link PdfDashPattern}.
    * @return A copy of this dash pattern.
    */
    public clone(): PdfDashPattern {
        return new PdfDashPattern(this._dash, this._gap, this._phase);
    }

    /**
    * Determines whether the specified {@link PdfDashPattern} instance is equal
    * to the current one.
    *
    * @param value {@link PdfDashPattern} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfDashPattern): boolean {
        return ((value instanceof PdfDashPattern)
            && (this._dash === value.dash)
            && (this._gap === value.gap)
            && (this._phase === value.phase));
    }
}
    }
    


    module wijmo.pdf {
    

'use strict';

/**
* Provides arguments for the {@link PdfDocument.end} event.
*/
export class PdfDocumentEndedEventArgs extends wijmo.EventArgs {
    private _blob: Blob;
    private _chunks: Uint8Array[];

    /**
    * Initializes a new instance of the {@link PdfDocumentEndedEventArgs} class.
    *
    * @param chunks An array of chunks.
    */
    constructor(chunks: Uint8Array[]) {
        super();
        this._chunks = chunks;
    }

    /**
    * Gets a Blob object that contains the document data.
    */
    public get blob(): Blob {
        if (!this._blob) {
            this._blob = new Blob(this._chunks, { type: 'application/pdf' });
        }
        return this._blob;
    }

    /**
    * Gets the underlying array of buffers that contains the document data.
    */
    public get chunks(): Uint8Array[] {
        return this._chunks;
    }
}
    }
    


    module wijmo.pdf {
    'use strict';

// Must follow the PDFKit's _CAP_STYLES object.
/**
* Specifies the shape that shall be used at the ends of open subpaths
* (and dashes, if any) when they are stroked.
*/
export enum PdfLineCapStyle {
    /**
    * The stroke is squared off at the endpoint of the path.
    */
    Butt = 0,

    /**
    * A semicircular arc with a diameter equal to the line width is 
    * drawn around the endpoint and is filled in.
    */
    Round = 1,

    /**
    * The stroke continues beyond the endpoint of the path for a
    * distance equal to the half of the line width and is squared off.
    */
    Square = 2
}

// Must follow the PDFKit's _JOIN_STYLES object.
/**
* Specifies the shape to be used at the corners of paths that are stroked.
*/
export enum PdfLineJoinStyle {
    /**
    * The outer edges of the strokes for the two segments are extended
    * until they meet at an angle.
    */
    Miter = 0,

    /**
    * An arc of a circle with a diameter equal to the line width is drawn
    * around the point where the two segments meet.
    */
    Round = 1,

    /**
    * The two segments are finished with butt caps and the resulting notch
    * beyond the ends of the segments is filled with a triangle.
    */
    Bevel = 2
}

/**
* Specifies a rule that determines if a point falls inside the enclosed path.
*/
export enum PdfFillRule {
    /**
    * Non-zero rule.
    */
    NonZero,

    /**
    * Even-odd rule.
    */
    EvenOdd
}

/**
* Specifies the page orientation.
*/
export enum PdfPageOrientation {
    /**
    * Portrait orientation.
    */
    Portrait,

    /**
    * Landscape orientation.
    */
    Landscape
}

/**
* Specifies the horizontal alignment of the image.
*/
export enum PdfImageHorizontalAlign {
    /**
    * Aligns the image to the left edge of the drawing area.
    */
    Left,

    /**
    * Aligns the image in the middle of the drawing area.
    */
    Center,

    /**
    * Aligns the image to the right edge of the drawing area.
    */
    Right
}

/**
* Specifies the vertical alignment of the image.
*/
export enum PdfImageVerticalAlign {
    /**
    * Aligns the image to the top edge of the drawing area.
    */
    Top,

    /**
    * Aligns the image in the middle of the drawing area.
    */
    Center,

    /**
    * Aligns the image to the bottom edge of the drawing area.
    */
    Bottom
}

/**
* Specifies the horizontal alignment of text content.
*/
export enum PdfTextHorizontalAlign {
    /**
    * Text is aligned to the left.
    */
    Left,

    /**
    * Text is centered.
    */
    Center,

    /**
    * Text is aligned to the right.
    */
    Right,

    /**
    * Text is justified.
    */
    Justify
}

// internal, determines the baseline of the text.
export enum _PdfTextBaseline {
    Top,
    Alphabetic
}

// Names must strictly follow the PDFKit's SIZES object.
/**
* Specifies the page size, in points.
*/
export enum PdfPageSize {
    /**
    * Represents the A0 page size.
    */
    A0,

    /**
    * Represents the A1 page size.
    */
    A1,

    /**
    * Represents the A2 page size.
    */
    A2,

    /**
    * Represents the A3 page size.
    */
    A3,

    /**
    * Represents the A4 page size.
    */
    A4,

    /**
    * Represents the A5 page size.
    */
    A5,

    /**
    * Represents the A6 page size.
    */
    A6,

    /**
    * Represents the A7 page size.
    */
    A7,

    /**
    * Represents the A8 page size.
    */
    A8,

    /**
    * Represents the A9 page size.
    */
    A9,

    /**
    * Represents the A10 page size.
    */
    A10,

    /**
    * Represents the B0 page size.
    */
    B0,

    /**
    * Represents the B1 page size.
    */
    B1,

    /**
    * Represents the B2 page size.
    */
    B2,

    /**
    * Represents the B3 page size.
    */
    B3,

    /**
    * Represents the B4 page size.
    */
    B4,

    /**
    * Represents the B5 page size.
    */
    B5,

    /**
    * Represents the B6 page size.
    */
    B6,

    /**
    * Represents the B7 page size.
    */
    B7,

    /**
    * Represents the B8 page size.
    */
    B8,

    /**
    * Represents the B9 page size.
    */
    B9,

    /**
    * Represents the B10 page size.
    */
    B10,

    /**
    * Represents the C0 page size.
    */
    C0,

    /**
    * Represents the C1 page size.
    */
    C1,

    /**
    * Represents the C2 page size.
    */
    C2,

    /**
    * Represents the C3 page size.
    */
    C3,

    /**
    * Represents the C4 page size.
    */
    C4,

    /**
    * Represents the C5 page size.
    */
    C5,

    /**
    * Represents the C6 page size.
    */
    C6,

    /**
    * Represents the C7 page size.
    */
    C7,

    /**
    * Represents the C8 page size.
    */
    C8,

    /**
    * Represents the C9 page size.
    */
    C9,

    /**
    * Represents the C10 page size.
    */
    C10,

    /**
    * Represents the RA0 page size.
    */
    RA0,

    /**
    * Represents the RA1 page size.
    */
    RA1,

    /**
    * Represents the RA2 page size.
    */
    RA2,

    /**
    * Represents the RA3 page size.
    */
    RA3,

    /**
    * Represents the RA4 page size.
    */
    RA4,

    /**
    * Represents the SRA0 page size.
    */
    SRA0,

    /**
    * Represents the SRA1 page size.
    */
    SRA1,

    /**
    * Represents the SRA2 page size.
    */
    SRA2,

    /**
    * Represents the SRA3 page size.
    */
    SRA3,

    /**
    * Represents the SRA4 page size.
    */
    SRA4,

    /**
    * Represents the executive page size.
    */
    Executive,

    /**
    * Represents the folio page size.
    */
    Folio,

    /**
    * Represents the legal page size.
    */
    Legal,

    /**
    * Represents the letter page size.
    */
    Letter,

    /**
    * Represents the tabloid page size.
    */
    Tabloid
}

/**
* Specifies PDF printing permisson.
*/
export enum PdfPrintPermission {
    /**
    * Printing is not allowed.
    */
    NotAllowed,
    /**
    * Printing is limited to a low-level representation of the appearance, possibly of degraded quality.
    */
    AllowLowResolution,
    /**
    * Print the document to a representation from which a faithful digital copy of the PDF content could be generated.
    */
    AllowHighResolution
}

// Important: see PdfDocument.ctor for converting PdfVersion to _PdfKitVersion.
/**
* Specifies PDF file version.
*/
export enum PdfVersion {
    /**
    * PDF version 1.3.
    */
    v1_3,
    /**
    * PDF version 1.4.
    */
    v1_4,
    /**
    * PDF version 1.5.
    */
    v1_5,
    /**
    * PDF version 1.6.
    */
    v1_6,
    /**
    * PDF version 1.7.
    */
    v1_7,
    /**
    * PDF version 1.7 ExtensionLevel 3.
    */
    v1_7Ext3
}
    }
    


    module wijmo.pdf {
    'use strict';

export var _Errors = {
    InvalidArg: (name: string): string => {
        return 'Invalid argument: "' + name + '".';
    },
    InvalidFormat: (value: string): string => {
        return '"' + value + '" is not in the correct format.';
    },
    ValueCannotBeEmpty: (name: string): string => {
        return 'Value cannot be empty: "' + name + '".';
    },

    PathStarted: 'This method can not be used until the current path is finished.',
    BufferPagesMustBeEnabled: 'The bufferPages property must be enabled to render headers and footers.',
    AbstractMethod: 'This is an abstract method, it should not be called.',

    FontNameMustBeSet: 'The font name must be set.',
    FontSourceMustBeStringArrayBuffer: 'The font source must be of type string or ArrayBuffer.',
    FontSourceMustBeString: 'The font source must be of type string.',
    FontSourceMustBeArrayBuffer: 'The font source must be of type ArrayBuffer.',

    EmptyUrl: 'URL can not be empty.',
    UndefinedMimeType: 'MIME-type must be set.',
    InvalidImageDataUri: 'Invalid Data URI. It should be base64 encoded string that represents JPG or PNG image.',
    InvalidImageFormat: 'Invalid image format. Only JPG and PNG formats are supported.',

    SecurityRequirements: 'The wijmo.pdf.security module must be added on page to use PDF encryption and permissions settings.'
};

    }
    


    module wijmo.pdf {
    


'use strict';

/**
* Represents an abstract class that serves as a base class for all brushes.
* Instances of any class that derives from this class are used to fill areas and text.
*
* This class is not intended to be instantiated in your code. 
*/
export class PdfBrush {
    /**
    * Creates a copy of this {@link PdfBrush}.
    * @return A copy of this brush.
    */
    public clone(): PdfBrush {
        throw _Errors.AbstractMethod;
    }

    /**
    * Determines whether the specified {@link PdfBrush} instance is equal to the current one.
    *
    * @param value {@link PdfBrush} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfBrush): boolean {
        throw _Errors.AbstractMethod;
    }

    /*
    * Gets a native PDFKit's object which represents the brush.
    *
    * @param area Associated {@link PdfPageArea}.
    */
    public _getBrushObject(area: PdfPageArea): any {
        throw _Errors.AbstractMethod;
    }
}
    }
    


    module wijmo.pdf {
    







'use strict';

/**
 * Determines an object used to stroke paths and text.
 */
export class PdfPen {
    private _color: wijmo.Color;
    private _brush: PdfBrush;
    private _width: number;
    private _cap: PdfLineCapStyle;
    private _join: PdfLineJoinStyle;
    private _miterLimit: number;
    private _dashPattern: PdfDashPattern;

    /**
    * Initializes a new instance of the {@link PdfPen} class with the specified color or
    * brush or JavaScript object.
    *
    * The first argument can accept the following values:
    * <ul>
    *  <li>{@link wijmo.Color} object or any string acceptable by the {@link wijmo.Color.fromString} method.</li>
    *  <li>{@link PdfBrush} object.</li>
    *  <li>JavaScript object containing initialization properties (all other arguments are ignored).</li>
    * </ul>
    *
    * @param colorOrBrushOrOptions The color or brush or JavaScript object to use.
    * @param width The width to use.
    * @param dashPattern The dash pattern to use.
    * @param cap The line cap style to use.
    * @param join The line join style to use.
    * @param miterLimit The miter limit to use.
    */
    constructor(colorOrBrushOrOptions?: any, width?: number, dashPattern?: PdfDashPattern, cap?: PdfLineCapStyle, join?: PdfLineJoinStyle, miterLimit?: number) {
        // Default arguments values are taken from the PDF Reference 1.7, chapter 4.3, 'Device-independent graphics state parameters'.
        if (colorOrBrushOrOptions == null) {
            colorOrBrushOrOptions = wijmo.Color.fromRgba(0, 0, 0);
        }

        if (width == null) {
            width = 1;
        }

        if (dashPattern == null) {
            dashPattern = new PdfDashPattern(null, null, 0);
        }

        if (cap == null) {
            cap = PdfLineCapStyle.Butt;
        }

        if (join == null) {
            join = PdfLineJoinStyle.Miter;
        }

        if (miterLimit == null) {
            miterLimit = 10;
        }

        if (wijmo.isObject(colorOrBrushOrOptions) && !(colorOrBrushOrOptions instanceof wijmo.Color) && !(colorOrBrushOrOptions instanceof PdfBrush)) {
            var foo = <PdfPen>colorOrBrushOrOptions;

            this.color = foo.color;
            this.brush = foo.brush;
            this.width = foo.width != null ? foo.width : width;
            this.cap = foo.cap != null ? foo.cap : cap;
            this.join = foo.join != null ? foo.join : join;
            this.miterLimit = foo.miterLimit != null ? foo.miterLimit : miterLimit
            this.dashPattern = foo.dashPattern || dashPattern;
        } else {
            if (colorOrBrushOrOptions instanceof PdfBrush) {
                this.brush = colorOrBrushOrOptions;
            } else {
                this.color = colorOrBrushOrOptions;
            }

            this.width = width;
            this.cap = cap;
            this.join = join;
            this.miterLimit = miterLimit
            this.dashPattern = dashPattern;
        }

        this._color = this._color || wijmo.Color.fromRgba(0, 0, 0);
    }

    /**
    * Gets or sets the color used to stroke paths.
    * The default color is black.
    */
    public get color(): wijmo.Color {
        return this._color;
    }
    public set color(value: wijmo.Color) { // also accepts string values
        this._color = _asColor(value);
    }

    /**
    * Gets or sets the brush used to stroke paths.
    * Takes precedence over the {@link color} property, if defined.
    */
    public get brush(): PdfBrush {
        return this._brush;
    }
    public set brush(value: PdfBrush) {
        value = _asPdfBrush(value, true);
        this._brush = value ? value.clone() : null;
    }

    /**
    * Gets or sets the line width used to stroke paths, in points.
    * The default width is 1.
    */
    public get width(): number {
        return this._width;
    }
    public set width(value: number) {
        this._width = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the shape that shall be used at the open ends of a stroked path.
    * The default value is <b>Butt</b>.
    */
    public get cap(): PdfLineCapStyle {
        return this._cap;
    }
    public set cap(value: PdfLineCapStyle) {
        this._cap = wijmo.asEnum(value, PdfLineCapStyle);
    }

    /**
    * Gets or sets the shape to be used at the corners of a stroked path.
    * The default value is <b>Miter</b>.
    */
    public get join(): PdfLineJoinStyle {
        return this._join;
    }
    public set join(value: PdfLineJoinStyle) {
        this._join = wijmo.asEnum(value, PdfLineJoinStyle);
    }

    /**
    * Determines the maximum value of the miter length to the line width ratio, when the line
    * join is converted from miter to bevel.
    * The default value is 10.
    */
    public get miterLimit(): number {
        return this._miterLimit;
    }
    public set miterLimit(value: number) {
        this._miterLimit = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets the dash pattern used to stroke paths.
    * The default value is a solid line.
    */
    public get dashPattern(): PdfDashPattern {
        return this._dashPattern;
    }
    public set dashPattern(value: PdfDashPattern) {
        wijmo.assert(value instanceof PdfDashPattern, _Errors.InvalidArg('value'));
        this._dashPattern = value.clone();
    }

    /**
    * Creates a copy of this {@link PdfPen}.
    * @return A copy of this pen.
    */
    public clone(): PdfPen {
        var pen = new PdfPen(this._color, this._width, this._dashPattern, this._cap, this._join, this._miterLimit);
        pen.brush = this._brush;
        return pen;
    }

    /**
    * Determines whether the specified {@link PdfPen} instance is equal to the current one.
    *
    * @param value {@link PdfPen} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfPen): boolean {
        return ((value instanceof PdfPen)
            && this._color.equals(value._color)
            && (this._brush ? this._brush.equals(value._brush) : this._brush === value._brush)
            && (this._width === value._width)
            && (this._cap === value._cap)
            && (this._join === value._join)
            && (this._miterLimit === value._miterLimit)
            && this._dashPattern.equals(value._dashPattern));
    }
}
    }
    


    module wijmo.pdf {
    



'use strict';

/**
 * Represents a font.
 */
export class PdfFont {
    public static _DEF_NATIVE_NAME = 'Times-Roman';
    public static _DEF_FAMILY_NAME = 'times';

    public static _KNOWN_WEIGHTS = {
        'normal': 1, 'bold': 1, '100': 1, '200': 1, '300': 1, '400': 1, '500': 1, '600': 1, '700': 1, '800': 1, '900': 1
    };
    public static _KNOWN_STYLES = {
        'normal': 1, 'italic': 1, 'oblique': 1
    };

    public static _DEF_PDFKIT_FONT = new PdfFont('helvetica', 12);
    public static _DEF_FONT = new PdfFont();

    private _family: string;
    private _size: number;
    private _style: string;
    private _weight: string;

    /**
    * Initializes a new instance of the {@link PdfFont} class.
    *
    * @param family The family name of the font.
    * @param size The size of the font.
    * @param style The style of the font.
    * @param weight The weight of the font.
    */
    constructor(family = 'times', size = 10, style = 'normal', weight = 'normal') {
        this.family = family;
        this.size = size;
        this.style = style;
        this.weight = weight;
    }

    /**
    * Gets or sets the family name of the font.
    *
    * The list of the font family names in the order of preferences,
    * separated by commas. Each font family name can be the one that
    * was registered using the {@link PdfDocument.registerFont} method or
    * the name of one of the PDF standard font families: 'courier',
    * 'helvetica', 'symbol', 'times', 'zapfdingbats' or the superfamily
    * name: 'cursive', 'fantasy', 'monospace', 'serif', 'sans-serif'.
    */
    public get family(): string {
        return this._family;
    }
    public set family(value: string) {
        this._family = wijmo.asString(value, false);
    }

    /**
    * Gets or sets the size of the font.
    */
    public get size(): number {
        return this._size;
    }
    public set size(value: number) {
        this._size = wijmo.asNumber(value, false, true);
    }

    /**
     * Gets or sets the style of the font.
     *
     * The following values are supported: 'normal', 'italic', 'oblique'.
     */
    public get style(): string {
        return this._style;
    }
    public set style(value: string) {
        value = wijmo.asString(value, false);

        if (value) {
            wijmo.assert(!!PdfFont._KNOWN_STYLES[(value || '').toLowerCase()], _Errors.InvalidArg('value'));
        }

        this._style = value;
    }

    /**
     * Gets or sets the weight of the font.
     *
     * The following values are supported: 'normal', 'bold', '100', '200', '300',
     * '400', '500', '600', '700', '800', '900'.
     */
    public get weight(): string {
        return this._weight;
    }
    public set weight(value: string) {
        value = wijmo.asString(value, false);

        if (value) {
            wijmo.assert(!!PdfFont._KNOWN_WEIGHTS[(value || '').toLowerCase()], _Errors.InvalidArg('value'));
        }

        this._weight = value;
    }

    /**
    * Creates a copy of this {@link PdfFont}.
    * @return A copy of this font.
    */
    clone(): PdfFont {
        return new PdfFont(this.family, this.size, this.style, this.weight);
    }

    /**
    * Determines whether the specified {@link PdfFont} instance is equal to the current one.
    *
    * @param value {@link PdfFont} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    equals(value: PdfFont): boolean {
        return (value instanceof PdfFont)
            && (this._family === value._family)
            && (this._size === value._size)
            && (this._style === value._style)
            && (this._weight === value._weight);
    }
}
    }
    


    module wijmo.pdf {
    








/** Infrastructure. */
export interface _IPdfTextFlowCtxState {
    xo: number;
    yo: number;
    lineGap: number;
}

// wraps the _IPdfKitTextOptions native interface.
/**
* Represents text settings used by {@link PdfPageArea.drawText} and {@link PdfPageArea.measureText} methods.
*/
export interface IPdfTextSettings {
    /**
    * Determines how text is aligned within the drawing area.
    * The default value is <b>Left</b>.
    */
    align?: PdfTextHorizontalAlign;

    /**
    * Indicates whether line wrapping should be used or not.
    * The property is ignored if {@link IPdfTextSettings.width} is defined.
    * The default value is true.
    */
    lineBreak?: boolean;

    /**
    * Determines the width of the text area in points to which the text should wrap.
    * The default value is undefined which means that the text area will be limited by
    * right margin of the page.
    * Use Infinity to indicate that the text area has an infinite width.
    * If defined, forces the {@link IPdfTextSettings.lineBreak} property to be enabled.
    */
    width?: number;

    /**
    * Determines the height of the drawing area in points to which the text should be clipped.
    * The default value is undefined which means that the text area will be limited by
    * bottom edge of the body section.
    * Use Infinity to indicate that the text area has an infinite height.
    */
    height?: number;

    /**
    * Determines the character to display at the end of the text when it exceeds
    * the given area.The default value is undefined, that is, ellipsis is not displayed.
    * Set to true to use the default character.
    */
    ellipsis?: any;

    /**
    * Determines the number of columns to flow the text into.
    * The default value is 1.
    */
    columns?: number;

    /**
    * Determines the spacing between each column, in points.
    * The default value is 18.
    */
    columnGap?: number;

    /**
    * Determines the value of indentaion in each paragraph of text, in points.
    * The default value is 0.
    */
    indent?: number;

    /**
    * Determines the spacing between paragraphs of text.
    * The default value is 0.
    */
    paragraphGap?: number;

    /**
    * Determines the spacing between lines of text.
    * The default value is 0.
    */
    lineGap?: number;

    /**
    * Determines the spacing between words in the text.
    * The default value is 0.
    */
    wordSpacing?: number;

    /**
    * Determines the spacing between text characters.
    * The default value is 0.
    */
    characterSpacing?: number;

    /**
    * Indicates whether the text should be filled or not.
    * The default value is true.
    */
    fill?: boolean;

    /**
    * Indicates whether the text should be stroked or not.
    * The default value is false.
    */
    stroke?: boolean;

    /**
    * Determines a URL used to create a link annotation (URI action).
    */
    link?: string;

    /**
    * Indicates whether the text should be underlined or not.
    * The default value is false.
    */
    underline?: boolean;

    /**
    * Indicates whether the text should be striked out or not.
    * The default value is false.
    */
    strike?: boolean;

    /**
    * Indicates whether subsequent text should be continued right after that or
    * it will be a new paragraph. If true, the text settings will be retained
    * between drawText calls. It means that options argument will be merged with
    * the one taken from the previous drawText call.
    *
    * The default value is false.
    */
    continued?: boolean;
}

/**
* Represents the settings used by {@link PdfPageArea.drawText} method to draw a text
* with the specified {@link PdfPen} and {@link PdfBrush}.
*/
export interface IPdfTextDrawSettings extends IPdfTextSettings {
    /**
    * Determines the font to use. If not specified, the default document font will be
    * used ({@link PdfDocument.setFont} method).
    */
    font?: PdfFont;

    /**
    * Determines the pen to stroke the text. If not specified, the default document
    * pen will be used ({@link PdfDocument.setPen} method).
    */
    pen?: PdfPen | wijmo.Color | string

    /**
    * Determines the brush to fill the text. If not specified, the default document
    * brush will be used ({@link PdfDocument.setBrush} method).
    */
    brush?: PdfBrush | wijmo.Color | string

    _baseline?: _PdfTextBaseline; // internal, used by SVG renderer
}

/**
* Represents the settings used by {@link PdfPageArea.measureText} method.
*/
export interface IPdfTextMeasurementSettings extends IPdfTextSettings {
    /**
    * Determines whether the last line external leading value should be included into the measurements result.
    * The default value is true.
    */
    includeLastLineExternalLeading?: boolean; // default: true
}

// wraps the _IPdfKitImage native interface.
/**
* Represents the image opened using {@link PdfPageArea.openImage} method.
*/
export interface IPdfImage {
    /**
    * The width of the image, in pixels.
    */
    width: number;
    /**
    * The height of the image, in pixels.
    */
    height: number;
}

/**
 * Represents the image drawing settings used by {@link PdfPageArea.drawImage} method.
 *
 * If neither width nor height options are provided, then the image will be rendered
 * in its original size. If only width is provided, then the image will be scaled
 * proportionally to fit in the provided width. If only height is provided, then the
 * image will be scaled proportionally to fit in the provided height. If both width
 * and height are provided, then image will be stretched to the dimensions depending
 * on the stretchProportionally property.
 */
export interface IPdfImageDrawSettings {
    /**
    * Determines the width of the image, in points.
    */
    width?: number;

    /**
    * Determines the height of the image, in points.
    */
    height?: number;

    /**
    * Indicates whether an image will be stretched proportionally or not, if both width
    * and height options are provided.
    */
    stretchProportionally?: boolean;

    /**
    * Determines the horizontal alignment in case of proportional stretching.
    */
    align?: PdfImageHorizontalAlign;

    /**
    * Determines the vertical alignment in case of proportional stretching.
    */
    vAlign?: PdfImageVerticalAlign;
}


/**
* Represents the settings used by {@link PdfPageArea.drawSvg} method to draw a SVG image.
*/
export interface IPdfSvgDrawSettings extends IPdfImageDrawSettings {
    /**
    * Determines a callback function used to convert a relative URL to a URL that is correct for the current request path.
    * The function gets passed the relative URL as its argument and should return the resolved URL.
    */
    urlResolver?: (url: string) => string;
}

/**
* Represents a range of buffered pages returned by {@link PdfDocument.bufferedPageRange} method.
*/
export interface IPdfBufferedPageRange {
    /**
    * Determines the zero-based index of the first buffered page.
    */
    start: number;

    /**
    * Determines the count of buffered pages.
    */
    count: number;
}

/**
* Represents the font attributes.
*/
export interface IPdfFontAttributes {
    /**
    * Glyphs have finishing strokes, flared or tapering ends, or have actual
    * serifed endings.
    */
    cursive?: boolean;

    /**
    * Fantasy fonts are primarily decorative fonts that contain playful representations
    * of characters.
    */
    fantasy?: boolean;

    /**
    * All glyphs have the same width.
    */
    monospace?: boolean;

    /**
    * Glyphs have finishing strokes, flared or tapering ends, or have actual
    * serifed endings.
    */
    serif?: boolean;

    /**
    * Glyphs have stroke endings that are plain.
    */
    sansSerif?: boolean;
}

/**
* Represents the settings of the font to register by {@link PdfDocument.registerFont} and
* {@link PdfDocument.registerFontAsync} methods.
*/
export interface IPdfFontFile extends IPdfFontAttributes {
    /**
    * An ArrayBuffer containing binary data or URL to load the font from. 
    * Following font formats are supported: TrueType (.ttf), TrueType Collection (.ttc),
    * Datafork TrueType (.dfont).
    */
    source: ArrayBuffer | string;

    /**
    * The name of the font to use.
    */
    name: string;

    /**
    * The style of the font. One of the following values: 'normal', 'italic', 'oblique'.
    */
    style?: string;

    /**
    * The weight of the font. One of the following values: 'normal', 'bold', '100', '200', 
    *'300', '400', '500', '600', '700', '800', '900'.
    */
    weight?: string;

    /**
    * An optional parameter determining the TrueType Collection or Datafork TrueType
    * font family.
    */
    family?: string;
}

/**
* Represents the document information used by {@link PdfDocument.info} property.
*/
export interface IPdfDocumentInfo {
    /**
    * Determines the name of the person who created the document.
    */
    author?: string;

    /**
    * Determines the date and time the document was created on.
    */
    creationDate?: Date;

    /**
    * Determines the keywords associated with the document. 
    */
    keywords?: string;

    /**
    * Determines the date and time when the document was last modified.
    */
    modDate?: Date;

    /**
    * Determines the subject of the document.
    */
    subject?: string;

    /**
    * Determines the title of the document.
    */
    title?: string;
}

/**
* Represents the page margins.
*/
export interface IPdfPageMargins {
    /**
    * Determines the bottom margin, in points.
    */
    bottom: number;

    /**
    * Determines the left margin, in points.
    */
    left: number;

    /**
    * Determines the right margin, in points.
    */
    right: number;

    /**
    * Determines the top margin, in points.
    */
    top: number;
}

/**
* Represents the page settings.
*/
export interface IPdfPageSettings {
    /**
    * Determines the layout of the page.
    */
    layout?: PdfPageOrientation;

    /**
    * Determines the margins of the page.
    */
    margins?: IPdfPageMargins;

    /**
    * Determines the dimensions of the page.
    * The following values are supported:
    * <ul>
    *  <li><b>{@link PdfPageSize}</b>: predefined sizes.</li>
    *  <li><b>{@link Size}</b>: custom sizes.</li>
    * </ul>
    */
    size?: PdfPageSize | wijmo.Size;
}

/**
* Represents the text measurement information returned by {@link PdfPageArea.measureText} method.
*/
export interface IPdfTextMeasurementInfo {
    /**
    * Determines the text size, in points.
    */
    size: wijmo.Size;

    /**
    * Determines the character count.
    */
    charCount: number;
}

/**
* Represents the initialization settings of a running title of the page, like header and footer.
*/
export interface IPdfRunningTitleOptions {
    /**
    * Represents the height of a running title, in points. To hide the running title, set this property to 0.
    *
    * The default value is 24.
    */
    height?: number;
    /**
    * Represents the spacing between each line of text, in points.
    *
    * The default value is 0.
    */
    lineGap?: number;
    /**
    * Represents the declarative content of a running title.
    */
    declarative?: {
        /**
        * Represents the font of the {@link text}.
        */
        font?: PdfFont;
        /**
        * Represents the text of a running title.
        * May contain up to 3 tabular characters ('\t') which are used for separating the text
        * into the parts that will be aligned within the page area using left, center and right
        * alignment.
        * Two kinds of macros are supported, '&[Page]' and '&[Pages]'. The former one designates
        * the current page index while the latter one designates the page count.
        *
        * For example, for the first page of a document having ten pages, the following string:
        * <pre>
        *    '&[Page]\\&[Pages]\theader\t&[Page]\\&[Pages]'
        * </pre>
        * will be translated to:
        * <pre>
        *    '1\10 header 1\10'
        * </pre>
        */
        text?: string;
        /**
        * Represents the brush used to fill the {@link text}.
        */
        brush?: PdfBrush | wijmo.Color | string;
    }
}

/**
* Represents the {@link PdfDocument} permission settings.
*/
export interface IPdfPermissions {
    /**
    * Determines whether annotating, form filling is allowed.
    * The default value is false.
    */
    annotating?: boolean;
    /**
    * Determines copying text for accessibility is allowed.
    * 
    * Not supported in PDF 1.3.
    * 
    * The default value is false.
    */
    contentAccessibility?: boolean;
    /**
    * Determines whether copying text or graphics is allowed.
    * 
    * The default value is false.
    */
    copying?: boolean;
    /**
    * Determines whether whether assembling document is allowed.
    * 
    * Not supported in PDF 1.3.
    * 
    * The default value is false.
    */
    documentAssembly?: boolean;
    /**
    * Determines whether form filling and signing is allowed.
    * 
    * Not supported in PDF 1.3.
    * 
    * The default value is false.
    */
    fillingForms?: boolean;
    /**
    * Determines whether modifying the file is allowed.
    * 
    * The default value is false.
    */
    modifying?: boolean;
    /**
    * Determines whether printing is allowed.
    * 
    * The {@link PdfPrintPermission.AllowLowResolution} value is equivalent to {@link PdfPrintPermission.AllowHighResolution} in PDF 1.3.
    * 
    * The default value is {@link PdfPrintPermission.NotAllowed}.
    */
    printing?: PdfPrintPermission;
}

/**
* Represents the {@link PdfDocument} initialization settings.
*/
export interface IPdfDocumentOptions {
    /**
    * Indicates whether the pages buffering mode is enabled which means that the document's pages
    * can be iterated over using {@link PdfDocument.pageIndex} and {@link PdfDocument.bufferedPageRange}.
    *
    * This property can be set to false only if both {@link header} and {@link footer} are invisible.
    *
    * The default value is true.
    */
    bufferPages?: boolean;
    /**
    * Indicates whether the document compression is enabled.
    *
    * The default value is true.
    */
    compress?: boolean;
    /**
    * Represents the document information, such as author name, document's creation date and so on.
    */
    info?: IPdfDocumentInfo;
    /**
    * Represents the spacing between each line of text, in points.
    *
    * The default value is 0.
    */
    lineGap?: number;
    /**
    * Represents the initialization settings of a header, the page area positioned right below
    * the top margin.
    */
    header?: IPdfRunningTitleOptions;
    /**
    * Represents the initialization settings of a footer, the page area positioned right above
    * the bottom margin.
    */
    footer?: IPdfRunningTitleOptions;
    /**
    * Represents the default page settings for the pages added automatically and for the {@link PdfDocument.addPage} method.
    */
    pageSettings?: IPdfPageSettings;

    /**
    * Represents the PDF owner password.
    * 
    * When only owner password is provided, users are able to decrypt and open the document without providing any password,
    * but the access is limited to those operations explicitly permitted according to {@link permissions} settings.
    * Users with owner password have full access to the document.
    *
    * When both owner password and {@link userPassword} are provided, users with user password are able to decrypt the file
    * but only have limited access to the file according to {@link permissions} settings.
    * Users with owner password have full access to the document.
    *
    * The {@link wijmo.pdf.security} module must be added on page to use PDF encryption and permissions settings.
    */
    ownerPassword?: string;
    /**
    * Represents PDF file permissions.
    *
    * To set permissons for the PDF file, you need to provide an {@link ownerPassword} along with the permissions settings.
    * By default, all operations are disallowed. You need to explicitly allow certain operations.
    *
    * The {@link wijmo.pdf.security} module must be added on page to use PDF encryption and permissions settings.
    */
    permissions?: IPdfPermissions;
    /**
    * Represents the PDF user password.
    * 
    * When only user password is provided, users with user password are able to decrypt the file and have full access to the document.
    * 
    * When both user password and {@link ownerPassword} are provided, users with user password are able to decrypt the file
    * but only have limited access to the file according to {@link permissions} settings.
    * Users with owner password have full access to the document.
    *
    * The {@link wijmo.pdf.security} module must be added on page to use PDF encryption and permissions settings.
    */
    userPassword?: string;
    /**
    * Represents PDF file version.
    *
    * The PDF file version determines encryption algorithm and key length to use:
    * <ul>
    *  <li>{@link PdfVersion.v1_3}, 40-bit RC4.</li>
    *  <li>{@link PdfVersion.v1_4}, 128-bit RC4.</li>
    *  <li>{@link PdfVersion.v1_5}, 128-bit RC4.</li>
    *  <li>{@link PdfVersion.v1_6}, 128-bit AES.</li>
    *  <li>{@link PdfVersion.v1_7}, 128-bit AES.</li>
    *  <li>{@link PdfVersion.v1_7Ext3}, 256-bit AES.</li>
    * </ul>
    *
    * When using PDF version 1.7 ExtensionLevel 3, password is truncated to 127 bytes of its UTF-8 representation.
    * In older versions, password is truncated to 32 bytes, and only Latin-1 characters are allowed.
    *
    * The default value is {@link PdfVersion.v1_3}.
    */
    version?: PdfVersion;
    /**
    * Occurs when the document has been rendered.
    */
    ended?: (sender: PdfDocument, args: PdfDocumentEndedEventArgs) => void;
    /**
    * Occurs when a new page is added to the document.
    */
    pageAdded?: (sender: PdfDocument, args: wijmo.EventArgs) => void;
}
    }
    


    module wijmo.pdf {
    








'use strict';

export var _IE = (typeof (window) != 'undefined') && ('ActiveXObject' in window); // IE < 11.

var _FontSizePt = {
    'xx-small': 7,
    'x-small': 7.5,
    small: 10,
    medium: 12,
    large: 13.5,
    'x-large': 18,
    'xx-large': 24
};

/**
 * Saves the Blob object as a file.
 * @param blob The Blob object to save.
 * @param fileName The name with which the file is saved.
*/
export function saveBlob(blob: Blob, fileName: string): void {
    if (!blob || !(blob instanceof Blob) || !fileName) {
        return;
    }

    if (navigator.msSaveBlob) {
        navigator.msSaveBlob(blob, fileName);
    } else {
        var link = <HTMLAnchorElement>document.createElement('a'),
            click = function (element) {
                var evnt = <MouseEvent>document.createEvent('MouseEvents');
                evnt.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                element.dispatchEvent(evnt);
            };

        if ("download" in link) {
            var url = window.URL || (<any>window).webkitURL || window,
                objUrl = url.createObjectURL(blob);

            link.href = objUrl;
            link.target = "_blank"; // #315860 
            link.download = fileName;
            click(link);
            link = null;

            window.setTimeout(() => { // FF requires a timeout
                url.revokeObjectURL(objUrl);
            }, 30000);
        } else {
            var fr = new FileReader();

            // Save a blob using data URI scheme
            fr.onloadend = (e) => {
                link.download = fileName;
                link.href = <any>fr.result;
                click(link);
                link = null;
            };

            fr.readAsDataURL(blob);
        }
    }
}

/**
* Converts a point unit value to a pixel unit value.
*
* @param value The value to convert.
* @return The converted value.
*/
export function ptToPx(value: number): number {
    return wijmo.asNumber(value) / 0.75; // * 96 / 72;
}

/**
* Converts a pixel unit value to a point unit value.
*
* @param value The value to convert.
* @return The converted value.
*/
export function pxToPt(value: number): number {
    return wijmo.asNumber(value) * 0.75; // * 72 / 96;
}

/*
* Converts a value to {@link wijmo.Color}.
*
* If value is {@link wijmo.Color} then, the original or cloned value will be returned
* depending on the cloned parameter.
* If value is a string, then a new {@link wijmo.Color} instance will be created.
* If value is omitted, then a new {@link wijmo.Color} instance designated with black color 
* will be created.
*
* @param value Value to convert.
* @param clone Indicates whether the original {@link wijmo.Color} value should be cloned.
* @return A {@link wijmo.Color}.
*/
export function _asColor(value: wijmo.Color | string, clone = true): wijmo.Color {
    var res: wijmo.Color;

    if (!value) {
        res = wijmo.Color.fromRgba(0, 0, 0);
    } else {
        if (value instanceof wijmo.Color) {
            res = clone
                ? wijmo.Color.fromRgba((<wijmo.Color>value).r, (<wijmo.Color>value).g, (<wijmo.Color>value).b, (<wijmo.Color>value).a)
                : value;
        } else {
            res = _SafeColor.fromString(value);
        }
    }

    wijmo.assert(res instanceof wijmo.Color, _Errors.InvalidArg('value'));

    return res;
}

/*
* Converts a value to a {@link PdfPen}.
*
* If value is a {@link PdfPen} then the original value will be returned.
* If value is a string or a {@link wijmo.Color} then a new {@link PdfPen} instance will be created using value as a color argument.
*
* @param value Value to convert.
* @param nullOK Whether null values are acceptable.
* @return A {@link PdfPen}.
*/
export function _asPdfPen(value: PdfPen | wijmo.Color | string, nullOK = true): PdfPen {
    if (wijmo.isString(value) || (value instanceof wijmo.Color)) {
        value = new PdfPen(value);
    }

    wijmo.assert((value == null && nullOK) || value instanceof PdfPen, _Errors.InvalidArg('value'));

    return value;
}

/*
* Converts a value to a {@link PdfBrush}.
*
* If value is a {@link PdfBrush}, then the original value will be returned.
* If value is a string or a {@link wijmo.Color}, then a new {@link PdfSolidBrush} 
* instance will be created using value as a color argument.
*
* @param value Value to convert.
* @param nullOK Whether null values are acceptable.
* @return A {@link PdfBrush}.
*/
export function _asPdfBrush(value: PdfBrush | wijmo.Color | string, nullOK = true): PdfBrush {
    if (wijmo.isString(value) || (value instanceof wijmo.Color)) {
        value = new PdfSolidBrush(value);
    }

    wijmo.assert((value == null && nullOK) || value instanceof PdfBrush, _Errors.InvalidArg('value'));

    return value;
}

/*
* Asserts that value is a {@link PdfFont}.
*
* @param value Value to check.
* @param nullOK Whether null values are acceptable.
* @return A {@link PdfFont}.
*/
export function _asPdfFont(value: PdfFont, nullOK = true): PdfFont {
    wijmo.assert((value == null && nullOK) || value instanceof PdfFont, _Errors.InvalidArg('value'));
    return value;
}

/*
* Converts a value to a point unit value.
*
* The following values are supported:
* <ul>
*	<li>A number or numeric string or string postfixed with 'pt', treated as a point unit value.</li>
*	<li>A string postfixed with the 'px'</li>
*	<li>A font size value: 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'.</li>
* </ul>
*
* @param value The value to convert.
* @param emptyOK Whether empty values ('', null, undefined) are acceptable.
* @param emptyValue A value to be returned, if the provided value is empty.
* @return The converted value or an exception if conversion fails.
*/
export function _asPt(value: any, emptyOK = true, emptyValue = 0): number {
    var isEmpty = !value && value !== 0;

    wijmo.assert(!isEmpty || emptyOK, _Errors.ValueCannotBeEmpty('value'));

    if (isEmpty) {
        return emptyValue;
    }

    if (wijmo.isNumber(value)) {
        if (value === value) {
            return value;
        }
    } else {
        if (wijmo.isString(value)) {
            if (_FontSizePt[value]) {
                return _FontSizePt[value];
            }

            var num = parseFloat(value);
            if (num === num) { // test for NaN
                if (value.match(/(px)$/i)) {
                    return pxToPt(num);
                }

                // If comparison with the use of implicit type conversion gives the same result, the value is correct.
                // parseFloat("123") -> 123, "123" == 123 -- OK
                // parseFloat("123zz") -> 123, "123zz" != 123 -- Error, check for "pt" postfix then.
                if (value as any == num || value.match(/(pt)$/i)) {
                    return num;
                }
            }
        }
    }

    wijmo.assert(false, _Errors.InvalidFormat(value));
}

/*
* Replaces each macro item in a specified string with the text equivalent to an object's
* value.
*
* The function works by replacing parts of the <b>str</b> with the pattern
* '&[MacroName]' with properties of the <b>dict</b> argument.
*
* Use '&&' to indicate an actual ampersand.
*
* @param str A string to format.
* @param dict The macros dictionary used to format the string.
* @return The formatted string.
*/
export function _formatMacros(str: string, dict: any): string {
    var amps = {},
        ampsCnt = 0;

    // && -> &
    str = str.replace(/&&/g, (match, offset, str) => {
        amps[offset - (ampsCnt * 2) + ampsCnt] = true; // store the position of an actual ampersand within the string
        ampsCnt++;
        return '&';
    });

    // process macros
    str = str.replace(/&\[(\S+?)\]/g, (match, p1, offset, str) => {
        var macros = dict[p1];

        return macros && !amps[offset]
            ? macros
            : match;
    });

    return str;
}

/*
* Compares two objects with priority of the obj.equals(), if provided.
*
* @param a The first object to compare.
* @param b The second object to compare.
* @return True if the specified objects are equal, otherwise false.
*/
export function _compare(a: any, b: any): boolean {
    if (wijmo.isObject(a) && wijmo.isObject(b)) {
        for (var key in a) {
            if (key && ((<string>key)[0] === '_')) {
                continue;
            }

            var val = a[key],
                cmp = val && wijmo.isFunction(val.equals) ? val.equals(b[key]) : _compare(val, b[key]);

            if (!cmp) {
                return false;
            }
        }

        return true;
    } else {
        if (wijmo.isArray(a) && wijmo.isArray(b)) {
            if (a.length !== b.length) {
                return false;
            }

            for (var i = 0; i < a.length; i++) {
                if (!_compare(a[i], b[i])) {
                    return false;
                }
            }

            return true;
        }
    }

    // todo: compare Dates, if necessary.

    return a === b;
}

/*
* Creates a shallow copy of the source object.
*
* @param src The source object.
* @return A shallow copy of the source object. 
*/
export function _shallowCopy(src: any): any {
    var dst = {};

    if (src) {
        for (var key in src) {
            dst[key] = src[key];
        }
    }

    return dst;
}

/*
* Capitalizes the first character of the string and converts all other characters to lowercase.
*
* @param value The string to convert.
* @return The converted string.
*/
export function _toTitleCase(value: string): string {
    if (value) {
        return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
    }

    return value;
}
    }
    


    module wijmo.pdf {
    

'use strict';

/* Represents the XMLHttpRequest settings. */
interface _IXhrSettings {
    responseType?: string;
    headers?: { [index: string]: string };
    method?: string;
    async?: boolean;
    user?: string;
    password?: string;
    data?: any;
    overrideMimeType?: string;
}

var _XhrOverrideMimeTypeSupported = !!new XMLHttpRequest().overrideMimeType;

/* XMLHttpRequest helper. */
export class _XhrHelper {
    /*
    * Asynchronously retrieves an ArrayBuffer from the URL using XMLHttpRequest.
    *
    * @param url The URL to send the request to.
    * @param success A function to be called if the request succeeds.
    * @param error A function to be called if the request fails.
    */
    public static arrayBufferAsync(url: string, success: (xhr: XMLHttpRequest, data: ArrayBuffer) => void, error?: (xhr: XMLHttpRequest) => void): void {
        var settings: _IXhrSettings = {
            method: 'GET',
            responseType: 'arraybuffer',
            async: true
        };

        this._getData(url, settings, success, error);
    }

    /*
    * Synchronously retrieves an ArrayBuffer from a URL using XMLHttpRequest.
    *
    * @param url The URL to send the request to.
    * @param error A function to be called if the request fails.
    */
    public static arrayBuffer(url: string, error?: (xhr: XMLHttpRequest) => void): ArrayBuffer {
        var buffer: ArrayBuffer,
            settings: _IXhrSettings = {
                method: 'GET',
                async: false
            };

        if (_IE /*#250357*/ || !_XhrOverrideMimeTypeSupported) {
            // We can retrieve binary data synchronously using xhr.responseType in case of IE10
            settings.responseType = 'arraybuffer';

            this._getData(url, settings, (xhr, response: ArrayBuffer) => {
                buffer = response;
            }, error);
        } else { // Edge, Chrome, Firefox
            // Note: the responseType parameter must be empty in case of synchronous request (http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute)
            settings.overrideMimeType = 'text/plain; charset=x-user-defined'; // retrieve unprocessed data as a binary string

            this._getData(url, settings, (xhr, response: string) => {
                // convert string to ArrayBuffer
                buffer = new ArrayBuffer(response.length);

                var byteView = new Uint8Array(buffer);

                for (var i = 0, len = response.length; i < len; i++) {
                    byteView[i] = response.charCodeAt(i) & 0xFF;
                }
            }, error);
        }

        return buffer;
    }

    /*
    * Synchronously retrieves a text from a URL using XMLHttpRequest.
    *
    * @param url The URL to send the request to.
    * @param error A function to be called if the request fails.
    */
    public static text(url: string, error?: (xhr: XMLHttpRequest) => void): string {
        var settings: _IXhrSettings = {
            method: 'GET',
            async: false
        },
            res = "";

        this._getData(url, settings, (xhr, response) => res = response, error);

        return res;
    }

    /*
    * Retrieves data from a URL using XMLHttpRequest.
    *
    * @param url The URL to send the request to.
    * @param settings Request settings.
    * @param success A function to be called if the request succeeds.
    * @param error A function to be called if the request fails.
    */
    private static _getData(url: string, settings: _IXhrSettings, success: (xhr: XMLHttpRequest, response: any) => void, error?: (xhr: XMLHttpRequest) => void): void {
        var xhr = new XMLHttpRequest();

        settings = settings || {};

        xhr.open(settings.method, url, settings.async, settings.user, settings.password);

        xhr.addEventListener('load', () => {
            if (xhr.readyState === 4) {
                var status = xhr.status;

                if (status >= 200 && status < 300 || status === 304) {
                    if (success) {
                        success(xhr, xhr.response);
                    }
                } else {
                    if (error) {
                        error(xhr);
                    }
                }
            }
        });

        if (settings.headers) {
            for (var key in settings.headers) {
                xhr.setRequestHeader(key, settings.headers[key]);
            }
        }

        if (settings.responseType) {
            xhr.responseType = <any>settings.responseType;
        }

        if (settings.overrideMimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(settings.overrideMimeType);
        }

        xhr.send(settings.data);
    }
}
    }
    


    module wijmo.pdf {
    




'use strict';

export class _PdfImageHelper {
    private static DATAURI_CACHE = {};

    public static getDataUri(url: string): string {
        wijmo.assert(!!(url = wijmo.asString(url)), _Errors.EmptyUrl);

        if (_PdfImageHelper.DATAURI_CACHE[url]) {
            return _PdfImageHelper.DATAURI_CACHE[url];
        }

        var res = '';

        if (url.indexOf('data:') === 0) {
            if (!url.match(/^data:image\/(png|jpeg|jpg);base64,/)) {
                throw _Errors.InvalidImageDataUri;
            }
            res = url;
        } else {
            var xhrError: string,
                buffer = _XhrHelper.arrayBuffer(url, xhr => xhrError = xhr.statusText);

            if (xhrError) {
                throw xhrError;
            }

            try {
                var arr = new Uint16Array(buffer, 0, 2);

                if ((arr[0] === 0xD8FF) || (arr[0] === 0x5089 && arr[1] === 0x474E)) {
                    var base64 = _PdfImageHelper._toBase64(buffer);
                    res = 'data:' + ((arr[0] === 0xD8FF) ? 'image/jpeg' : 'image/png') + ';base64,' + base64;
                } else {
                    throw '';
                }
            }
            catch (ex) {
                throw _Errors.InvalidImageFormat;
            }
        }

        return _PdfImageHelper.DATAURI_CACHE[url] = res;
    }

    private static _toBase64(buffer: ArrayBuffer): string {
        var binary = '',
            bytes = new Uint8Array(buffer);

        for (var i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }

        return (typeof (window) != 'undefined' ? window : self).btoa(binary);
    }
}
    }
    


    module wijmo.pdf {
    















'use strict';

/**
* Represents an area of a page with its own coordinate system, where (0, 0) points 
* to the top-left corner.
* Provides methods for drawing text, images, paths and transformations.
*
* This class is not intended to be instantiated in your code. 
*/
export class PdfPageArea {
    private _pdfdoc: PdfDocument;
    public _offset: wijmo.Point; // upper-left corner in absolute coordinates.
    private _graphics: PdfPaths;
    private _drawingText: boolean;

    private _ctxProps: _IPdfTextFlowCtxState = {
        xo: 0,
        yo: 0,
        lineGap: 0
    };

    /**
    * Initializes a new instance of the {@link PdfPageArea} class.
    */
    constructor() {
    }

    //#region public properties

    /**
    * Gets or sets the X-coordinate (in points) of the current point in the text flow 
    * used to draw a text or an image.
    */
    public get x(): number {
        this._switchCtx();
        var x = (<_IPdfKitDocument>this._pdfdoc._document).x - this._offset.x;
        this._saveCtx();
        return x;
    }
    public set x(value: number) {
        value = wijmo.asNumber(value);

        this._switchCtx();
        (<_IPdfKitDocument>this._pdfdoc._document).x = value + this._offset.x;
        this._saveCtx();
    }

    /**
    * Gets or sets the Y-coordinate (in points) of the current point in the text flow 
    * used to draw a text or an image.
    */
    public get y(): number {
        this._switchCtx();
        var y = (<_IPdfKitDocument>this._pdfdoc._document).y - this._offset.y;
        this._saveCtx();
        return y;
    }
    public set y(value: number) {
        value = wijmo.asNumber(value);

        this._switchCtx();
        (<_IPdfKitDocument>this._pdfdoc._document).y = value + this._offset.y;
        this._saveCtx();
    }

    /**
    * Gets or sets the spacing between each line of text, in points.
    *
    * The default value is 0.
    */
    public get lineGap(): number {
        return this._ctxProps.lineGap;
    }
    public set lineGap(value: number) {
        this._ctxProps.lineGap = value = wijmo.asNumber(value, false, true);

        if (this._pdfdoc && this._pdfdoc._document) {
            this._switchCtx();
            (<_IPdfKitDocument>this._pdfdoc._document).lineGap(value);
            this._saveCtx();
        }
    }

    /**
    * Gets the height of the area, in points.
    */
    public get height(): number {
        var page = (<_IPdfKitDocument>this._pdfdoc._document).page;
        return Math.max(0, page.height - page.margins.top - page.margins.bottom); // header and footer are placed inside the native margins.
    }

    /**
    * Gets the width of the area, in points.
    */
    public get width(): number {
        var page = (<_IPdfKitDocument>this._pdfdoc._document).page;
        return Math.max(page.width - page.margins.left - page.margins.right);
    }

    public get _heightCtm(): number {
        let doc = <_IPdfKitDocument>this._pdfdoc._document;
        return this.height / -doc._ctm[3]; // take vertical scaling into account, Y-axis is inverted.
    }

    public get _widthCtm(): number {
        let doc = <_IPdfKitDocument>this._pdfdoc._document;
        return this.width / doc._ctm[0]; // take horizontal scalling into account
    }

    /**
    * Gets an object that provides ability to draw paths.
    */
    public get paths(): PdfPaths {
        return this._graphics;
    }

    /**
    * Gets the document object.
    */
    public get document(): PdfDocument {
        return this._pdfdoc;
    }

    //#endregion

    //#region public methods

    /**
    * Draws a string with the given options and returns the measurement information.
    *
    * If <b>options.pen</b>, <b>options.brush</b> or <b>options.font</b> are omitted,
    * the current document's pen, brush or font are used (see {@link PdfDocument.setPen},
    * {@link PdfDocument.setBrush}, and  {@link PdfDocument.setFont}).
    *
    * The string is drawn within the rectangular area for which top-left corner, width
    * and  height are defined by the x, y, <b>options.width</b> and <b>options.height</b>
    * values. If x and y are not provided, the {@link PdfDocument.x} and {@link PdfDocument.y}
    * properties are used instead.
    *
    * The text is wrapped and clipped automatically within the area.
    * If <b>options.height</b> is not provided and the text exceeds the bottom body edge,
    * then a new page will be added to accommodate the text.
    *
    * Finally, the method updates the value of the {@link PdfDocument.x} and {@link PdfDocument.y}
    * properties. Hence, any subsequent text or image starts below this point
    * (depending on the value of <b>options.continued</b>).
    *
    * The measurement result doesn't reflect the fact that text can be split into
    * multiple pages or columns; the text is treated as a single block.
    *
    * @param text The text to draw.
    * @param x The X-coordinate of the point to draw the text at, in points.
    * @param y The Y-coordinate of the point to draw the text at, in points.
    * @param options Determines the text drawing options.
    * @return A {@link IPdfTextMeasurementInfo} object determines the measurement information.
    */
    public drawText(text: string, x?: number, y?: number, options?: IPdfTextDrawSettings): IPdfTextMeasurementInfo {
        this._assertPathStarted();

        if (!(text = wijmo.asString(text))) {
            return;
        }

        options = options || {};

        var doc = this._pdfdoc,
            natDoc = <_IPdfKitDocument>doc._document,
            sz: _IPdfKitTextSize,
            drawMode = options.stroke && options.fill ? 2 : options.stroke ? 1 : 0; //  0 = fill, 1 = stroke, 2 = fillAndStroke.

        if ((options.strike || options.underline) && !options.stroke) { // to draw a line PdfKit changes strokeColor to fillColor
            drawMode = 2;
        }

        this._switchCtx();

        try {
            this._drawingText = true;

            if (!(drawMode & 1)) { // fill | fillAndStroke
                doc._toggleBrush(_asPdfBrush(options.brush));
            }

            if (drawMode & 3) { // stroke | fillAndStroke
                doc._togglePen(_asPdfPen(options.pen));
            }

            doc._toggleFont(_asPdfFont(options.font));

            var native = this._textOptionsToNative(options),
                baselineOffset = options._baseline === _PdfTextBaseline.Alphabetic ? natDoc.currentFontAscender() : 0;

            if (x == null) {
                natDoc.y -= baselineOffset;
                sz = natDoc.textAndMeasure(text, null, null, native);
            } else {
                sz = natDoc.textAndMeasure(text, wijmo.asNumber(x) + this._offset.x, wijmo.asNumber(y) + this._offset.y - baselineOffset, native);
            }
        } finally {
            this._drawingText = false;
            this._saveCtx();
        }

        return {
            charCount: sz.charCount || 0,
            size: new wijmo.Size(sz.width || 0, sz.height || 0)
        };
    }

    /**
    * Draws an image in JPG or PNG format with the given options.
    *
    * If x and y are not defined, then {@link x} and {@link y} are used instead.
    *
    * Finally, if the image was drawn in the text flow, the method updates {@link y}. 
    * Hence, any subsequent text or image starts below this point.
    *
    * @param src A string containing the URL to get the image from, or the data URI containing a base64 encoded image,
    * or a {@link wijmo.pdf.IPdfImage} object returned by the {@link openImage} method.
    * @param x The x-coordinate of the point to draw the image at, in points.
    * @param y The y-coordinate of the point to draw the image at, in points.
    * @param options Determines the image drawing options.
    * @return The {@link PdfPageArea} object.
    */
    public drawImage(src: string | IPdfImage, x?: number, y?: number, options?: IPdfImageDrawSettings): PdfPageArea {
        this._assertPathStarted();

        if (!src) {
            return this;
        }

        if (wijmo.isString(src)) {
            src = _PdfImageHelper.getDataUri(src);
        }

        this._switchCtx();
        try {
            var o: _IPdfKitImageOptions = {};

            if (options) {
                switch (wijmo.asEnum(options.align, PdfImageHorizontalAlign, true)) {
                    case PdfImageHorizontalAlign.Center:
                        o.align = 'center';
                        break;
                    case PdfImageHorizontalAlign.Right:
                        o.align = 'right';
                        break;
                    default:
                        o.align = 'left';
                }

                switch (wijmo.asEnum(options.vAlign, PdfImageVerticalAlign, true)) {
                    case PdfImageVerticalAlign.Center:
                        o.valign = 'center';
                        break;
                    case PdfImageVerticalAlign.Bottom:
                        o.valign = 'bottom';
                        break;
                    default:
                        o.valign = 'top';
                }

                var width = wijmo.asNumber(options.width, true, true),
                    height = wijmo.asNumber(options.height, true, true);

                if (width && height && wijmo.asBoolean(options.stretchProportionally, true)) {
                    o.fit = [width, height];
                } else {
                    o.width = width;
                    o.height = height;
                }
            }

            if (x == null) {
                (<_IPdfKitDocument>this._pdfdoc._document).image(src, o);
            } else {
                (<_IPdfKitDocument>this._pdfdoc._document).image(src, wijmo.asNumber(x) + this._offset.x, wijmo.asNumber(y) + this._offset.y, o);
            }
        } finally {
            this._saveCtx();
        }

        return this;
    }

    /**
    * Draws a SVG image with the given options.
    *
    * If x and y are not defined, then {@link x} and {@link y} are used instead.
    *
    * The method uses the values of the width and height attributes of the outermost svg element to determine the
    * scale factor according to the options.width and options.height properties. If any of these attributes are
    * omitted then scaling is not performed and the image will be rendered in its original size.
    *
    * Finally, if the image was drawn in the text flow, the method updates {@link y}.
    * Hence, any subsequent text or image starts below this point.
    * The increment value is defined by the options.height property or by the outermost svg element's height attribute, which comes first.
    * If none of them is provided then {@link y} will stay unchanged.
    *
    * The method supports a limited set of SVG features and provided primarily for rendering wijmo 5 chart controls. 
    *
    * @param url A string containing the URL to get the SVG image from or the data URI containing a base64 encoded SVG image.
    * @param x The x-coordinate of the point to draw the image at, in points.
    * @param y The y-coordinate of the point to draw the image at, in points.
    * @param options Determines the SVG image drawing options.
    * @return The {@link PdfPageArea} object.
    */
    public drawSvg(url: string, x?: number, y?: number, options?: IPdfSvgDrawSettings): PdfPageArea {
        var base64Decode = (value: string) => {
            // return atob(value); // Unicode-unfriendly.

            // https://developer.mozilla.org/ru/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
            return decodeURIComponent(Array.prototype.map.call(atob(value), function (c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
        }

        options = options || {};

        this._assertPathStarted();

        if (!(url = wijmo.asString(url))) {
            return this;
        }

        var svg: string;

        if (url.indexOf('data:image/svg') >= 0) {
            svg = base64Decode(url.substring(url.indexOf(',') + 1));
        } else {
            var xhrError: string;
            svg = _XhrHelper.text(url, xhr => xhrError = xhr.statusText);
            if (xhrError) {
                throw xhrError;
            }
        }

        if (!svg) {
            return this;
        }

        var optWidth = wijmo.asNumber(options.width, true, true),
            optHeight = wijmo.asNumber(options.height, true, true),
            renderer = new _SvgRenderer(svg, this, optWidth, optHeight, <(url: string) => string>wijmo.asFunction(options.urlResolver)),
            textFlow = (y == null),
            x = x != null ? x : this.x,
            y = y != null ? y : this.y,
            oldY = this.y,
            oldX = this.x,
            scaleX: number,
            scaleY: number,
            svgWidth = renderer.root.width.hasVal ? renderer.root.width.val : undefined,
            svgHeight = renderer.root.height.hasVal ? renderer.root.height.val : undefined;

        // scale factor
        if ((optWidth || optHeight) && (svgWidth && svgHeight)) {
            // can be NaN if width or height is undefined
            scaleX = optWidth / svgWidth;
            scaleY = optHeight / svgHeight;

            if (optWidth && optHeight) {
                if (options.stretchProportionally) {
                    var scaleMin = Math.min(scaleX, scaleY);

                    if (scaleX === scaleMin) {
                        switch (wijmo.asEnum(options.vAlign, PdfImageVerticalAlign, true)) {
                            case PdfImageVerticalAlign.Center:
                                y += optHeight / 2 - (svgHeight * scaleX) / 2;
                                break;

                            case PdfImageVerticalAlign.Bottom:
                                y += optHeight - svgHeight * scaleX;
                                break;
                        }
                    }

                    if (scaleY === scaleMin) {
                        switch (wijmo.asEnum(options.align, PdfImageHorizontalAlign, true)) {
                            case PdfImageHorizontalAlign.Center:
                                x += optWidth / 2 - (svgWidth * scaleY) / 2;
                                break;

                            case PdfImageHorizontalAlign.Right:
                                x += optWidth - svgWidth * scaleY;
                                break;
                        }
                    }

                    scaleX = scaleY = scaleMin;
                }
            } else {
                if (options.width) {
                    scaleY = scaleX;
                } else {
                    scaleX = scaleY;
                }
            }
        }

        scaleX = scaleX || 1;
        scaleY = scaleY || 1;

        // render
        this._switchCtx();
        this._pdfdoc.saveState();

        try {
            this.translate(x, y);
            this.scale(scaleX, scaleY);
            renderer.render();
        }
        finally {
            this._pdfdoc.restoreState();
            this._saveCtx();
        }

        // restore the text flow coordinates
        this.x = oldX;
        this.y = oldY;

        // update this.y
        if (textFlow) {
            var imgHeight = optHeight != null ? optHeight : (svgHeight != null ? svgHeight * scaleY : undefined);
            this.y += (imgHeight || 0);
        }

        return this;
    }

    /**
    * Gets the line height with a given font.
    *
    * If font is not specified, then font used in the current document is used.
    *
    * @param font Font to get the line height.
    * @return The line height, in points.
    */
    public lineHeight(font?: PdfFont): number {
        var doc = this._pdfdoc;
        doc._toggleFont(_asPdfFont(font));
        this._switchCtx();
        var value = (<_IPdfKitDocument>doc._document).currentLineHeight();
        this._saveCtx();
        return value;
    }

    /**
    * Measures a text with the given font and text drawing options without rendering it.
    *
    * If font is not specified, then the font used in the current document is used.
    *
    * The method uses the same text rendering engine as {@link drawText}, so it is tied up
    * in the same way to {@link x} and the right page margin, if options.width is not
    * provided. The measurement result doesn't reflect the fact that text can be split 
    * into multiple pages or columns; the text is treated as a single block.
    *
    * @param text Text to measure.
    * @param font Font to be applied on the text.
    * @param options Determines the text drawing options.
    * @return A {@link IPdfTextMeasurementInfo} object determines the measurement information.
    */
    public measureText(text: string, font?: PdfFont, options?: IPdfTextMeasurementSettings): IPdfTextMeasurementInfo {
        var sz: _IPdfKitTextSize = {};

        if (text = wijmo.asString(text)) {
            var doc = this._pdfdoc;

            doc._toggleFont(_asPdfFont(font));
            this._switchCtx();

            try {
                sz = (<_IPdfKitDocument>doc._document).textAndMeasure(text, null, null, this._textOptionsToNative(options), true);
            }
            finally {
                this._saveCtx();
            }
        }

        return {
            charCount: sz.charCount || 0,
            size: new wijmo.Size(sz.width || 0, sz.height || 0)
        };
    }

    /**
    * Moves down the {@link y} by a given number of lines using the given font or,
    * using the font of current document, if not specified.
    *
    * @param lines Number of lines to move down.
    * @param font Font to calculate the line height.
    * @return The {@link PdfPageArea} object.
    */
    public moveDown(lines = 1, font?: PdfFont): PdfPageArea {
        if (lines = wijmo.asNumber(lines, false, true)) {
            var doc = this._pdfdoc;

            doc._toggleFont(_asPdfFont(font));
            this._switchCtx();

            try {
                (<_IPdfKitDocument>doc._document).moveDown(lines);
            } finally {
                this._saveCtx();
            }
        }

        return this;
    }

    /**
    * Moves up the {@link y} by a given number of lines using the given font or,
    * using the font of current document, if not specified.
    *
    * @param lines Number of lines to move up.
    * @param font Font to calculate the line height.
    * @return The {@link PdfPageArea} object.
    */
    public moveUp(lines = 1, font?: PdfFont): PdfPageArea {
        if (lines = wijmo.asNumber(lines, false, true)) {
            var doc = this._pdfdoc;

            doc._toggleFont(_asPdfFont(font));
            this._switchCtx();

            try {
                (<_IPdfKitDocument>doc._document).moveUp(lines);
            } finally {
                this._saveCtx();
            }
        }

        return this;
    }

    /**
    * Opens an image in JPG or PNG format.
    *
    * @param url A string containing the URL to get the image from or the data URI containing a base64 encoded image.
    * @return The {@link IPdfImage} object containing image data.
    */
    public openImage(url: string): IPdfImage {
        if (!(url = wijmo.asString(url))) {
            return null;
        }

        url = _PdfImageHelper.getDataUri(url);
        return (<_IPdfKitDocument>this._pdfdoc._document).openImage(url);
    }

    /**
    * Scales the graphic context by a specified scaling factor.
    *
    * The scaling factor value within the range [0, 1] indicates that the size will be
    * decreased.
    * The scaling factor value greater than 1 indicates that the size will be increased.
    *
    * @param xFactor The factor to scale the X dimension.
    * @param yFactor The factor to scale the Y dimension. If it is not provided, it is
    * assumed to be equal to xFactor.
    * @param origin The {@link Point} to scale around, in points. If it is not provided,
    * then the top left corner is used.
    * @return The {@link PdfPageArea} object.
    */
    public scale(xFactor: number, yFactor = xFactor, origin?: wijmo.Point): PdfPageArea {
        this._assertPathStarted();

        origin = origin || new wijmo.Point(0, 0);

        var ox = wijmo.asNumber(origin.x) + this._offset.x,
            oy = wijmo.asNumber(origin.y) + this._offset.y;

        xFactor = wijmo.asNumber(xFactor, false);
        yFactor = wijmo.asNumber(yFactor, false);

        (<_IPdfKitDocument>this._pdfdoc._document).scale(xFactor, yFactor, {
            origin: [ox, oy]
        });

        return this;
    }

    /**
    * Translates the graphic context with a given distance.
    *
    * @param x The distance to translate along the X-axis, in points.
    * @param y The distance to translate along the Y-axis, in points.
    * @return The {@link PdfPageArea} object.
    */
    public translate(x: number, y: number): PdfPageArea {
        this._assertPathStarted();

        // don't add offsets because all drawing methods using it already, otherwise the translate(0,0).moveTo(0,0) call will double the offsets.
        x = wijmo.asNumber(x); // + this._offset.x;
        y = wijmo.asNumber(y); // + this._offset.y;

        (<_IPdfKitDocument>this._pdfdoc._document).translate(x, y);

        return this;
    }

    /**
    * Transforms the graphic context with given six numbers which represents a 
    * 3x3 transformation matrix.
    *
    * A transformation matrix is written as follows:
    * <table>
    *   <tr><td>a</td><td>b</td><td>0</td></tr>
    *   <tr><td>c</td><td>d</td><td>0</td></tr>
    *   <tr><td>e</td><td>f</td><td>1</td></tr>
    * </table>
    * 
    * @param a Value of the first row and first column.
    * @param b Value of the first row and second column.
    * @param c Value of the second row and first column.
    * @param d Value of the second row and second column.
    * @param e Value of the third row and first column.
    * @param f Value of the third row and second column.
    * @return The {@link PdfPageArea} object.
    */
    public transform(a: number, b: number, c: number, d: number, e: number, f: number): PdfPageArea {
        this._assertPathStarted();

        a = wijmo.asNumber(a);
        b = wijmo.asNumber(b);
        c = wijmo.asNumber(c);
        d = wijmo.asNumber(d);
        e = wijmo.asNumber(e);
        f = wijmo.asNumber(f);

        var x = this._offset.x,
            y = this._offset.y;

        (<_IPdfKitDocument>this._pdfdoc._document).transform(a, b, c, d, e - a * x + x - c * y, f - b * x - d * y + y);

        return this;
    }

    /**
    * Rotates the graphic context clockwise by a specified angle.
    *
    * @param angle The rotation angle, in degrees.
    * @param origin The {@link Point} of rotation, in points. If it is not provided,
    * then the top left corner is used.
    */
    public rotate(angle: number, origin?: wijmo.Point): PdfPageArea {
        this._assertPathStarted();

        origin = origin || new wijmo.Point(0, 0);

        var ox = wijmo.asNumber(origin.x) + this._offset.x,
            oy = wijmo.asNumber(origin.y) + this._offset.y;

        angle = wijmo.asNumber(angle);

        (<_IPdfKitDocument>this._pdfdoc._document).rotate(angle, {
            origin: [ox, oy]
        });

        return this;
    }

    //#endregion

    //#region internal

    public _assertPathStarted(): void {
        wijmo.assert(!this.paths._hasPathBuffer(), _Errors.PathStarted);
    }

    public _initialize(doc: PdfDocument, xo: number, yo: number) {
        this._pdfdoc = doc;
        this._offset = new wijmo.Point(xo, yo);
        this._ctxProps = {
            xo: xo,
            yo: yo,
            lineGap: this._ctxProps.lineGap
        };

        this._graphics = new PdfPaths(this._pdfdoc, this._offset);
    }

    public _isDrawingText(): boolean {
        return this._drawingText;
    }

    //#endregion

    //#region private

    private _switchCtx() {
        this._pdfdoc._switchTextFlowCtx(this._ctxProps);
    }

    private _saveCtx() {
        this._ctxProps = this._pdfdoc._getTextFlowCtxState();
    }

    private _textOptionsToNative(value: IPdfTextSettings): _IPdfKitTextOptions {
        value = value || {};

        var res: _IPdfKitTextOptions = _shallowCopy(value);

        if (value.align != null) {
            res.align = (PdfTextHorizontalAlign[wijmo.asEnum(value.align, PdfTextHorizontalAlign)] || '').toLowerCase(); // default 'left'.
        }

        return res;
    }
}
    }
    


    module wijmo.pdf {
    





'use strict';

/**
* Represents a brush used to fill an area with a color.
*/
export class PdfSolidBrush extends PdfBrush {
    private _color: wijmo.Color;

    /**
    * Initializes a new instance of the {@link PdfSolidBrush} class.
    *
    * @param color The color of this brush. A {@link wijmo.Color} object or any string
    * acceptable by the {@link wijmo.Color.fromString} method.
    */
    constructor(color?: any) { // color: string | Color
        super();
        this.color = color || wijmo.Color.fromRgba(0, 0, 0);
    }

    /**
    * Gets or sets the color of the brush.
    * The default color is black.
    */
    public get color(): wijmo.Color {
        return this._color;
    }
    public set color(value: wijmo.Color) { // also accepts string values
        this._color = _asColor(value);
    }

    //#region overrides

    /**
    * Creates a copy of this {@link PdfSolidBrush}.
    * @return A copy of this brush.
    */
    public clone(): PdfSolidBrush {
        return new PdfSolidBrush(this._color);
    }

    /**
    * Determines whether the specified {@link PdfSolidBrush} instance is equal
    * to the current one.
    *
    * @param value {@link PdfSolidBrush} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfSolidBrush): boolean {
        return ((value instanceof PdfSolidBrush)
            && this._color.equals(value._color));
    }

    //#endregion

    public _getBrushObject(area: PdfPageArea): wijmo.Color {
        // Using the non-native Color here because PDFKit doesn't has an appropriate structure that can represent a color with opacity. The PdfDocument's _setBrush and _setPen methods must take it into account.
        return this._color;
    }
}
    }
    


    module wijmo.pdf {
    








'use strict';

/**
* Represents the declarative content of the running title.
*/
export class PdfRunningTitleDeclarativeContent {
    private _font: PdfFont;
    private _text: string;
    private _brush: PdfBrush;

    /**
    * Initializes a new instance of the {@link PdfRunningTitleDeclarativeContent} class.
    *
    * @param text The text of the running title.
    * @param font Font of the text.
    * @param brush The {@link PdfBrush} or {@link wijmo.Color} or any string acceptable 
    * by the {@link wijmo.Color.fromString} method used to fill the text.
    */
    constructor(text?: string, font?: PdfFont, brush?: PdfBrush | wijmo.Color | string) {
        this.text = text || '';
        this.font = font || new PdfFont();
        this.brush = _asPdfBrush(brush) || new PdfSolidBrush();
    }

    /**
    * Gets or sets the font of the {@link text}.
    */
    public get font(): PdfFont {
        return this._font;
    }
    public set font(value: PdfFont) {
        value = _asPdfFont(value, true);
        this._font = value ? value.clone() : value;
    }

    /**
    * Gets or sets the text of the running title.
    *
    * May contain up to 3 tabular characters ('\t') which are used for separating the text
    * into the parts that will be aligned within the page area using left, center and right
    * alignment.
    * Two kinds of macros are supported, '&[Page]' and '&[Pages]'. The former one designates
    * the current page index while the latter one designates the page count.
    *
    * For example, for the first page of a document having ten pages, the following string:
    * <pre>
    *    '&[Page]\\&[Pages]\theader\t&[Page]\\&[Pages]'
    * </pre>
    * will be translated to:
    * <pre>
    *    '1\10 header 1\10'
    * </pre>
    */
    public get text(): string {
        return this._text;
    }
    public set text(value: string) {
        this._text = wijmo.asString(value);
    }

    /**
    * Gets or sets the brush used to fill the {@link text}.
    */
    public get brush(): PdfBrush {
        return this._brush;
    }
    public set brush(value: PdfBrush) {
        value = _asPdfBrush(value);
        this._brush = value ? value.clone() : value;
    }

    /**
    * Creates a copy of this {@link PdfRunningTitleDeclarativeContent}.
    * @return A copy of this pen.
    */
    public clone(): PdfRunningTitleDeclarativeContent {
        return new PdfRunningTitleDeclarativeContent(this.text, this.font, this.brush);
    }

    /**
    * Determines whether the specified {@link PdfRunningTitleDeclarativeContent} instance
    * is equal to the current one.
    *
    * @param value {@link PdfRunningTitleDeclarativeContent} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfRunningTitleDeclarativeContent): boolean {
        return ((value instanceof PdfRunningTitleDeclarativeContent)
            && (this._text === value.text)
            && (this._brush ? this._brush.equals(value._brush) : this._brush === value._brush)
            && (this._font ? this._font.equals(value._font) : this._font === value._font));
    }
}
    }
    


    module wijmo.pdf {
    






'use strict';

/**
* Represents a running title of the page, like header and footer.
*
* This class is not intended to be instantiated in your code.
*/
export class PdfRunningTitle extends PdfPageArea {
    private _height = 24;
    private _declarative = new PdfRunningTitleDeclarativeContent();
    public _heightChanged = new wijmo.Event<PdfRunningTitle, wijmo.EventArgs>();

    /**
    * Initializes a new instance of the {@link PdfRunningTitle} class.
    *
    * @param options An optional object containing initialization settings.
    */
    constructor(options?: any) {
        super();
        wijmo.copy(this, options);
    }

    //#region public properties

    /**
    * Gets or sets an object that provides the ability to setup the running title
    * content declaratively.
    */
    public get declarative(): PdfRunningTitleDeclarativeContent {
        return this._declarative;
    }
    public set declarative(value: PdfRunningTitleDeclarativeContent) {
        if (value != null) {
            wijmo.assert(value instanceof PdfRunningTitleDeclarativeContent, _Errors.InvalidArg('value'));
            value = value.clone();
        }

        this._declarative = value;
    }

    /**
    * Gets or sets the height of the running title, in points.
    * To hide the running title, set this property to 0.
    * Changing this property has no effect on previous drawings; they will not be resized
    * or clipped.
    *
    * The default value is 24.
    */
    public get height(): number {
        return this._height;
    }
    public set height(value: number) {
        if (value !== this._height) {
            this._height = wijmo.asNumber(value, false, true);
            this._heightChanged.raise(this, wijmo.EventArgs.empty);
        }
    }

    //#endregion

    //#region public methods

    // overrides
    public drawText(text, x?, y?, options?: IPdfTextDrawSettings): IPdfTextMeasurementInfo {
        options = options || {};
        // To be able to draw below the page bottom margin without adding a new page automatically, header and footer are positioned outside the native page margins.
        options.height = Infinity;
        return super.drawText(text, x, y, options);
    }

    //#endregion
}
    }
    


    module wijmo.pdf {
    



'use strict';

/**
* Represents an object which determines a transition point of a gradient.
*/
export class PdfGradientStop {
    private _offset: number;
    private _color: wijmo.Color;
    private _opacity: number;

    /**
    * Initializes a new instance of the {@link PdfGradientStop} class.
    *
    * @param offset The location of the gradient stop on the gradient axis.
    * @param color The color of the gradient stop. A {@link wijmo.Color} object or
    * any string acceptable by the {@link wijmo.Color.fromString} method.
    * @param opacity The opacity of the gradient stop.
    */
    constructor(offset?: number, color?: any, opacity?: number) {
        this.offset = offset || 0;
        this.color = color || wijmo.Color.fromRgba(0, 0, 0);
        this.opacity = opacity == null ? 1 : opacity;
    }

    /**
    * Gets or sets the location of the gradient stop on gradient axis of the brush.
    * The value must be in range [0, 1], where 0 indicates that the gradient stop is
    * placed at the beginning of the gradient axis, while 1 indicates that the 
    * gradient stop is placed at the end of the gradient axis.
    * The default value is 0.
    */
    public get offset(): number {
        return this._offset;
    }
    public set offset(value: number) {
        this._offset = wijmo.clamp(wijmo.asNumber(value, false, true), 0, 1);
    }

    /**
    * Gets or sets the color of the gradient stop.
    * The default color is black.
    */
    public get color(): wijmo.Color {
        return this._color;
    }
    public set color(value: wijmo.Color) { // also accepts string values
        this._color = _asColor(value);
    }

    /**
    * Gets or sets the opacity of the gradient stop.
    * The value must be in range [0, 1], where 0 indicates that the gradient stop is
    * completely transparent, while 1 indicates that the gradient stop is completely
    * opaque. The default value is 1.
    */
    public get opacity(): number {
        return this._opacity;
    }
    public set opacity(value: number) {
        this._opacity = wijmo.clamp(wijmo.asNumber(value, false, true), 0, 1);
    }

    /**
    * Creates a copy of this {@link PdfGradientStop}.
    * @return A copy of this gradient stop.
    */
    public clone(): PdfGradientStop {
        return new PdfGradientStop(this.offset, this.color, this.opacity);
    }

    /**
    * Determines whether the specified {@link PdfGradientStop} instance is equal to
    * the current one.
    *
    * @param value {@link PdfGradientStop} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfGradientStop): boolean {
        return ((value instanceof PdfGradientStop)
            && (this._offset === value._offset)
            && this._color.equals(value._color)
            && (this._opacity === value._opacity));
    }
}
    }
    


    module wijmo.pdf {
    






'use strict';

/**
* Represents an abstract class that serves as a base class for the 
* {@link PdfLinearGradientBrush} and {@link PdfRadialGradientBrush} classes.
*
* This class is not intended to be instantiated in your code. 
*/
export class PdfGradientBrush extends PdfBrush {
    private _opacity: number;
    private _stops: PdfGradientStop[];

    /**
    * Initializes a new instance of the {@link PdfGradientBrush} class.
    *
    * @param stops The {@link PdfGradientStop} array to set on this brush.
    * @param opacity The opacity of this brush.
    */
    constructor(stops?: PdfGradientStop[], opacity?: number) {
        super();

        this.stops = stops || [];
        this.opacity = opacity == null ? 1 : opacity;
    }

    /**
    * Gets or sets the opacity of the brush.
    * The value must be in range [0, 1], where 0 indicates that the brush is
    * completely transparent and 1 indicates that the brush is completely opaque.
    * The default value is 1.
    */
    public get opacity(): number {
        return this._opacity;
    }
    public set opacity(value: number) {
        this._opacity = wijmo.clamp(wijmo.asNumber(value, false, true), 0, 1);
    }

    /**
    * Gets or sets an array of {@link PdfGradientStop} objects representing a color, 
    * offset and opacity within the brush's gradient axis.
    * The default value is an empty array.
    */
    public get stops(): PdfGradientStop[] {
        return this._stops;
    }
    public set stops(value: PdfGradientStop[]) {
        wijmo.assert(wijmo.isArray(value), _Errors.InvalidArg('value'));
        this._stops = this._cloneStopsArray(value);
    }

    /**
    * Determines whether the specified {@link PdfGradientBrush} instance is equal
    * to the current one.
    *
    * @param value {@link PdfGradientBrush} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfGradientBrush): boolean {
        return (value instanceof PdfGradientBrush)
            && (this._opacity === value.opacity)
            && _compare(this._stops, value._stops);
    }

    //#region internal, private

    private _cloneStopsArray(value: PdfGradientStop[]): PdfGradientStop[] {
        var res: PdfGradientStop[] = [];

        for (var i = 0; i < value.length; i++) {
            var stop = value[i];
            wijmo.assert(stop instanceof PdfGradientStop, _Errors.InvalidArg('stops[' + i + ']'));
            res.push(value[i].clone());
        }

        return res;
    }

    //#endregion
}
    }
    


    module wijmo.pdf {
    





'use strict';

/**
* Represents a brush used to fill an area with a radial gradient.
*/
export class PdfRadialGradientBrush extends PdfGradientBrush {
    private _x1: number;
    private _y1: number;
    private _r1: number;

    private _x2: number;
    private _y2: number;
    private _r2: number;

    /**
    * Initializes a new instance of the {@link PdfRadialGradientBrush} class.
    *
    * @param x1 The X-coordinate of the inner circle's center of the radial gradient.
    * @param y1 The Y-coordinate of the inner circle's center of the radial gradient.
    * @param r1 The radius of the inner circle of the radial gradient.
    * @param x2 The X-coordinate of the outer circle's center of the radial gradient.
    * @param y2 The Y-coordinate of the outer circle's center of the radial gradient.
    * @param r2 The radius of the outer circle of the radial gradient.
    * @param stops The {@link PdfGradientStop} array to set on this brush.
    * @param opacity The opacity of this brush.
    */
    constructor(x1: number, y1: number, r1: number, x2: number, y2: number, r2: number, stops: PdfGradientStop[], opacity?: number) {
        super(stops, opacity)

        this.x1 = x1;
        this.y1 = y1;
        this.r1 = r1;

        this.x2 = x2;
        this.y2 = y2;
        this.r2 = r2;
    }

    //#region inner point

    /**
    * Gets or sets the X-coordinate of the inner circle's center that represents the
    * starting point of the radial gradient, in page area coordinates, in points.
    */
    public get x1(): number {
        return this._x1;
    }
    public set x1(value: number) {
        this._x1 = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the Y-coordinate of the inner circle's center that represents the 
    * starting point of the radial gradient, in page area coordinates, in points.
    */
    public get y1(): number {
        return this._y1;
    }
    public set y1(value: number) {
        this._y1 = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the radius of the inner circle that represents the starting 
    * point of the radial gradient, in page area coordinates, in points.
    */
    public set r1(value: number) {
        this._r1 = wijmo.asNumber(value, false, true);
    }
    public get r1(): number {
        return this._r1;
    }

    //#endregion

    //#region outer point

    /**
    * Gets or sets the X-coordinate of the outer circle's center that represents the ending point of the radial gradient, in page area coordinates, in points.
    */
    public get x2(): number {
        return this._x2;
    }
    public set x2(value: number) {
        this._x2 = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the Y-coordinate of the outer circle's center that represents
    * the ending point of the radial gradient, in page area coordinates, in points.
    */
    public get y2(): number {
        return this._y2;
    }
    public set y2(value: number) {
        this._y2 = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the radius of the outer circle that represents the ending point of the
    * radial gradient, in page area coordinates, in points.
    */
    public get r2(): number {
        return this._r2;
    }
    public set r2(value: number) {
        this._r2 = wijmo.asNumber(value, false, true);
    }

    //#endregion

    //#region overrides

    /**
    * Creates a copy of this {@link PdfRadialGradientBrush}.
    * @return A copy of this brush.
    */
    public clone(): PdfRadialGradientBrush {
        return new PdfRadialGradientBrush(this._x1, this._y1, this._r1, this._x2, this._y2, this._r2, this.stops, this.opacity);
    }

    /**
    * Determines whether the specified {@link PdfRadialGradientBrush} instance is equal
    * to the current one.
    *
    * @param value {@link PdfRadialGradientBrush} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfRadialGradientBrush): boolean {
        return (value instanceof PdfRadialGradientBrush)
            && (this._x1 === value._x1)
            && (this._y1 === value._y1)
            && (this._r1 === value._r1)
            && (this._x2 === value._x2)
            && (this._y2 === value._y2)
            && (this._r2 === value._r2)
            && super.equals(value);
    }

    public _getBrushObject(area: PdfPageArea): any {
        var g = (<_IPdfKitDocument>area.document._document).radialGradient(
            this._x1 + area._offset.x,
            this._y2 + area._offset.y,
            this._r1,
            this._x2 + area._offset.x,
            this._y2 + area._offset.y,
            this._r2),
            stops = this.stops;

        for (var i = 0; i < stops.length; i++) {
            var s = stops[i];

            if (s) {
                g.stop(s.offset, [s.color.r, s.color.g, s.color.b], s.color.a);
            }
        }

        return g;
    }

    //#endregion
}
    }
    


    module wijmo.pdf {
    





'use strict';

/**
* Represents a brush used to fill an area with a linear gradient.
*/
export class PdfLinearGradientBrush extends PdfGradientBrush {
    private _x1: number;
    private _y1: number;
    private _x2: number;
    private _y2: number;

    /**
    * Initializes a new instance of the {@link PdfLinearGradientBrush} class.
    *
    * @param x1 The X-coordinate of the starting point of the linear gradient.
    * @param y1 The Y-coordinate of the starting point of the linear gradient.
    * @param x2 The X-coordinate of the ending point of the linear gradient.
    * @param y2 The Y-coordinate of the ending point of the linear gradient.
    * @param stops The {@link PdfGradientStop} array to set on this brush.
    * @param opacity The opacity of this brush.
    */
    constructor(x1: number, y1: number, x2: number, y2: number, stops: PdfGradientStop[], opacity?: number) {
        super(stops, opacity)

        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }

    /**
    * Gets or sets the X-coordinate of the starting point of the linear gradient,
    * in page area coordinates, in points.
    */
    public get x1(): number {
        return this._x1;
    }
    public set x1(value: number) {
        this._x1 = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the Y-coordinate of the starting point of the linear gradient,
    * in page area coordinates, in points.
    */
    public get y1(): number {
        return this._y1;
    }
    public set y1(value: number) {
        this._y1 = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the X-coordinate of the ending point of the linear gradient, 
    * in page area coordinates, in points.
    */
    public get x2(): number {
        return this._x2;
    }
    public set x2(value: number) {
        this._x2 = wijmo.asNumber(value, false, true);
    }

    /**
    * Gets or sets the Y-coordinate of the ending point of the linear gradient,
    * in page area coordinates, in points.
    */
    public get y2(): number {
        return this._y2;
    }
    public set y2(value: number) {
        this._y2 = wijmo.asNumber(value, false, true);
    }

    //#region overrides

    /**
    * Creates a copy of this {@link PdfLinearGradientBrush}.
    * @return A copy of this brush.
    */
    public clone(): PdfLinearGradientBrush {
        return new PdfLinearGradientBrush(this._x1, this._y1, this._x2, this._y2, this.stops, this.opacity);
    }

    /**
    * Determines whether the specified {@link PdfLinearGradientBrush} instance is equal to
    * the current one.
    *
    * @param value {@link PdfLinearGradientBrush} to compare.
    * @return true if the specified object is equal to the current one, otherwise false.
    */
    public equals(value: PdfLinearGradientBrush): boolean {
        return (value instanceof PdfLinearGradientBrush)
            && (this._x1 === value._x1)
            && (this._y1 === value._y1)
            && (this._x2 === value._x2)
            && (this._y2 === value._y2)
            && super.equals(value);
    }

    public _getBrushObject(area: PdfPageArea): any {
        var g = (<_IPdfKitDocument>area.document._document).linearGradient(
            this._x1 + area._offset.x,
            this._y1 + area._offset.y,
            this._x2 + area._offset.x,
            this._y2 + area._offset.y),
            stops = this.stops;


        for (var i = 0; i < stops.length; i++) {
            var s = stops[i];

            if (s) {
                g.stop(s.offset, [s.color.r, s.color.g, s.color.b], s.color.a);
            }
        }

        return g;
    }

    //#endregion
}
    }
    


    module wijmo.pdf {
    






'use strict';

interface _IPdfFontWeightDescription {
    [index: number]: string; // <weight>: <PDFKit's internal name to use>
}

interface _IPdfFontDescription {
    attributes: IPdfFontAttributes;
    normal?: _IPdfFontWeightDescription;
    italic?: _IPdfFontWeightDescription;
    oblique?: _IPdfFontWeightDescription
}

interface _IPdfNormalizedFontSelector {
    name: string;
    style: string;
    weight: number;
}

class _OrderedDictionary<T> {
    private _values: { key: string; value: T }[] = [];
    private _keys: { [key: string]: number } = {};

    constructor(values?: { key: string; value: T }[]) {
        if (values) {
            for (var i = 0; i < values.length; i++) {
                var val = values[i];

                this._keys[val.key] = i;
                this._values.push({ key: val.key, value: val.value });
            }
        }
    }

    public hasKey(key: string): T {
        var idx = this._keys[key];

        if (idx !== undefined) {
            return this._values[idx].value;
        }

        return null;
    }

    public add(key: string, value: T): T {
        if (!this.hasKey(key)) {
            this._keys[key] = this._values.length;
            this._values.push({ key: key, value: value });
            return value;
        }

        return null;
    }

    public each(fn: (key: string, value: T) => any): void {
        if (fn) {
            for (var i = 0; i < this._values.length; i++) {
                var val = this._values[i];

                if (fn(val.key, val.value) === false) {
                    break;
                }
            }
        }
    }

    public eachReverse(fn: (key: string, value: T) => any): void {
        if (fn) {
            for (var i = this._values.length - 1; i >= 0; i--) {
                var val = this._values[i];

                if (fn(val.key, val.value) === false) {
                    break;
                }
            }
        }
    }
}

/* Provides font registration functionality. */
export class _PdfFontRegistrar {
    // standard fonts, starting from the specific one
    private _fonts = new _OrderedDictionary<_IPdfFontDescription>([
        {
            key: 'zapfdingbats',
            value: {
                attributes: {
                    fantasy: true
                },
                normal: {
                    400: 'ZapfDingbats'
                }
            }
        },
        {
            key: 'symbol',
            value: {
                attributes: {
                    serif: true
                },
                normal: {
                    400: 'Symbol'
                }
            }
        },
        {
            key: 'courier',
            value: {
                attributes: {
                    serif: true,
                    monospace: true
                },
                normal: {
                    400: 'Courier',
                    700: 'Courier-Bold'
                },
                oblique: {
                    400: 'Courier-Oblique',
                    700: 'Courier-BoldOblique'
                }
            }
        },
        {
            key: 'helvetica',
            value: {
                attributes: {
                    sansSerif: true
                },
                normal: {
                    400: 'Helvetica',
                    700: 'Helvetica-Bold'
                },
                oblique: {
                    400: 'Helvetica-Oblique',
                    700: 'Helvetica-BoldOblique'
                }
            }
        },
        {
            key: 'times',
            value: {
                attributes: {
                    serif: true
                },
                normal: {
                    400: 'Times-Roman',
                    700: 'Times-Bold'
                },
                italic: {
                    400: 'Times-Italic',
                    700: 'Times-BoldItalic'
                }
            }
        }
    ]);

    private _weightNameToNum = {
        'normal': 400,
        'bold': 700
    };

    private _doc: _IPdfKitDocument;
    private _findFontCache: { [uid: string]: string } = {};
    private _internalFontNames: { [key: string]: any; } = {}; // stores all internal names of the registered fonts.

    /*
    * Initializes a new instance of the {@link _PdfFontRegistrar} class.
    *
    * @param doc A PDFDocument object.
    */
    constructor(doc: any) {
        this._doc = doc;

        // fill _internalFontNames
        this._fonts.each((key, value) => {
            var facesIterator = (descr: _IPdfFontWeightDescription): any => {
                for (var key in descr) {
                    this._internalFontNames[descr[key]] = 1;
                }
            };

            facesIterator(value.normal) || facesIterator(value.italic) || facesIterator(value.oblique);
        });
    }

    /*
    * Registers a font from ArrayBuffer.
    *
    * @param font A font to register.
    *
    * @return A PDFKit internal font name.
    */
    public registerFont(font: IPdfFontFile): string {
        wijmo.assert(!!font, _Errors.ValueCannotBeEmpty('font'));
        wijmo.asString(font.name);
        wijmo.assert(font.source instanceof ArrayBuffer, _Errors.FontSourceMustBeArrayBuffer);

        font = _shallowCopy(font);

        var ns = this._normalizeFontSelector(font.name, font.style, font.weight),
            fntDscr = this._fonts.hasKey(ns.name);

        if (!fntDscr) {
            fntDscr = this._fonts.add(ns.name, { attributes: <IPdfFontAttributes>font });
        }

        var face = fntDscr[ns.style];
        if (!face) {
            face = fntDscr[ns.style] = {};
        }

        var internalName = this._makeInternalName(ns);

        if (!face[ns.weight]) {
            this._doc.registerFont(internalName, font.source as ArrayBuffer, font.family);
            this._findFontCache = {};
            face[ns.weight] = internalName;
            this._internalFontNames[internalName] = 1;
        }

        return internalName;
    }

    /*
    * Finds the closest registered font for a given font name, style and weight.
    *		
    * If exact font with given style and weight properties is not found then,
    * it tries to search the closest font using font weight fallback 
    * (https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight).
    * If still nothing is found, it tries to find the closest font with other style in 
    * the following order:
    * 'italic': 'oblique', 'normal'.
    * 'oblique': 'italic', 'normal'.
    * 'normal': 'oblique', 'italic'.
    *
    * @param name The name of the font that was registered before using the {@link registerFont}
    * or the name of one of the PDF standard fonts: 'courier', 'helvetica', 'symbol', 'times',
    * 'zapfdingbats', or the superfamily name: 'cursive', 'fantasy', 'monospace', 'serif',
    * 'sans-serif'.
    * @param style The style of the font. One of the following values: 'normal',
    * 'italic', 'oblique'.
    * @param weight The weight of the font. One of the following values: 'normal',
    * 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'.
    * @return A PDFKit internal font name or null.
    */
    public findFont(name: string, style?: string, weight?: string): string {
        var ns = this._normalizeFontSelector(name, style, weight),
            internalName = this._makeInternalName(ns);

        if (this._findFontCache[internalName]) {
            return this._findFontCache[internalName];
        }

        ns.name += ',' + PdfFont._DEF_FAMILY_NAME; // Try to use the default font family with the same style and weight if specifed font will not be found.

        for (var i = 0, names = ns.name.split(','); i < names.length; i++) {
            var tmp = this._findFont(names[i].replace(/["']/g, '').trim(), ns.style, ns.weight);
            if (tmp) {
                return this._findFontCache[internalName] = tmp;
            }
        }

        return this._findFontCache[internalName] = this._internalFontNames[name]
            ? name
            : PdfFont._DEF_NATIVE_NAME; // use default name if closest font can not be found
    }

    private _normalizeFontSelector(name: string, style?: string, weight?: string): _IPdfNormalizedFontSelector {
        return {
            name: (name || '').toLowerCase(),
            style: (style || PdfFont._DEF_FONT.style).toLowerCase(),
            weight: parseInt(this._weightNameToNum[weight] || weight) || parseInt(this._weightNameToNum[PdfFont._DEF_FONT.weight])
        }
    }

    private _findFont(name: string, style?: string, weight?: number): string {
        var facesToTest: string[] = [],
            res: string;

        switch (style) {
            // setup fallback font styles
            case 'italic':
                facesToTest = ['italic', 'oblique', 'normal'];
                break;
            case 'oblique':
                facesToTest = ['oblique', 'italic', 'normal'];
                break;
            default:
                facesToTest = ['normal', 'oblique', 'italic'];
                break;
        }

        switch (name) {
            case 'cursive':
            case 'fantasy':
            case 'monospace':
            case 'serif':
            case 'sans-serif':
                // try to find closest font within the given font superfamily using font-weight and font-style fallbacks if necessary.
                this._fonts.eachReverse((key, font) => { // try custom fonts first
                    var propName = (name === 'sans-serif') ? 'sansSerif' : name;

                    if (font.attributes[propName]) {
                        for (var i = 0; i < facesToTest.length; i++) {
                            res = this._findFontWeightFallback(key, facesToTest[i], weight);
                            if (res) {
                                return false; // break the loop
                            }
                        }
                    }
                });
                break;

            default:
                if (this._fonts.hasKey(name)) {
                    // try to find closest font within the given font family (name) using font-weight and font-style fallbacks if necessary.
                    for (var i = 0; i < facesToTest.length && !res; i++) {
                        res = this._findFontWeightFallback(name, facesToTest[i], weight);
                    }
                }
        }

        return res;
    }

    private _findFontWeightFallback(name: string, style: string, weight: number, availableWeights?: number[]): string {
        var font = this._fonts.hasKey(name);

        if (font && font[style]) {
            var weights = font[style];

            if (weights[weight]) {
                return weights[weight];
            } else {
                // font-weight fallback (https://www.w3.org/TR/2016/WD-CSS22-20160412/fonts.html#font-boldness)

                if (!availableWeights) {
                    availableWeights = [];

                    for (var key in weights) {
                        availableWeights.push(parseFloat(key));
                    }

                    availableWeights.sort((a, b) => { return a - b; });
                }

                if (weight > 500) { // the closest available darker weight is used (or, if there is none, the closest available lighter weight).
                    var less = 0;

                    for (var i = 0; i < availableWeights.length; i++) {
                        var cur = availableWeights[i];

                        if (cur > weight) {
                            return weights[cur];
                        } else {
                            less = cur;
                        }
                    }

                    if (less) {
                        return weights[less];
                    }
                } else {
                    if (weight < 400) { // the closest available lighter weight is used (or, if there is none, the closest available darker weight).
                        var greater = 0;

                        for (var i = availableWeights.length - 1; i >= 0; i--) {
                            var cur = availableWeights[i];

                            if (cur < weight) {
                                return weights[cur];
                            } else {
                                greater = cur;
                            }
                        }

                        if (greater) {
                            return weights[greater];
                        }
                    } else {
                        if (weight == 400) { // If the desired weight is 400...
                            if (weights[500]) { // ...500 is checked first
                                return weights[500]
                            } else { // ...and then the rule for desired weights less than 400 is used
                                return this._findFontWeightFallback(name, style, 300, availableWeights);
                            }
                        } else { // If the desired weight is 500...
                            if (weights[400]) { // ...400 is checked first
                                return weights[400]
                            } else { // ...and then the rule for desired weights less than 400 is used.
                                return this._findFontWeightFallback(name, style, 300, availableWeights);
                            }
                        }
                    }
                }
            }
        }

        return null;
    }

    private _makeInternalName(ns: _IPdfNormalizedFontSelector): string {
        return ns.name + '-' + ns.style + '-' + ns.weight;
    }
}


    }
    


    module wijmo.pdf {
    
























'use strict';

interface _IPageGState {
    pen?: PdfPen;
    brush?: PdfBrush;
}

/**
* Represents a PDF document object, based on <a href="https://github.com/foliojs/pdfkit">PDFKit</a> JavaScript library.
*/
export class PdfDocument extends PdfPageArea {
    private _doc: _IPdfKitDocument;
    private _docInitialized = false;
    private _compress: boolean = true;
    private _bufferPages: boolean = true; // must be true to render headers and footers
    private _chunks: Uint8Array[] = [];
    private _fontReg: _PdfFontRegistrar;
    private _pageIndex = -1;

    private _version = PdfVersion.v1_3;
    private _userPassword: string;
    private _ownerPassword: string;
    private _permissions: IPdfPermissions = {
        // All the permissions are disallowed by default.
        annotating: false,
        contentAccessibility: false,
        copying: false,
        documentAssembly: false,
        fillingForms: false,
        modifying: false,
        printing: PdfPrintPermission.NotAllowed
    };

    private _ehOnPageAdded: (doc: _IPdfKitDocument) => void;
    private _ehOnPageAdding: (doc: _IPdfKitDocument, options: _IPdfKitPageOptions) => void;
    private _ehOnDocData: (chunk: any) => void;
    private _ehOnDocEnding: () => void;
    private _ehOnDocEnded: () => void;

    private _header: PdfRunningTitle;
    private _footer: PdfRunningTitle;

    // stores pens and brushes between the save\ restore roundtrip.
    private _graphicsStack = [];

    // represents an actual stroking (pen) and filling (brush) properties for every page.
    private _currentGS: { [index: number]: _IPageGState } = {};
    // represents default (provided by the setPen method) settings of the document's stroking properties.
    private _defPen: PdfPen;
    // represents default (provided by the setBrush method) settings of the document's filling properties.
    private _defBrush: PdfBrush;

    // represents current font
    private _curFont: PdfFont;
    // represents default font (provided by the setFont method).
    private _defFont: PdfFont;

    /**
    * Initializes a new instance of the {@link PdfDocument} class.
    *
    * @param options An optional object containing initialization settings.
    */
    constructor(options?: IPdfDocumentOptions) {
        super();

        wijmo.copy(this, options);

        let pdfSecurity = softPdfSecurity();

        if ((this._ownerPassword || this._userPassword) && !pdfSecurity) {
            throw _Errors.SecurityRequirements;
        }

        var pre = (doc: _IPdfKitDocument) => {
            this._doc = doc;
            this._fontReg = new _PdfFontRegistrar(this._doc);
        },
            post = () => {
                this.setPen(this._currentGS[this._pageIndex].pen);
                this.setBrush(this._currentGS[this._pageIndex].brush);
                this._curFont = PdfFont._DEF_PDFKIT_FONT;
                this.setFont(new PdfFont()); // change to times-10
            },
            autoPage = false,
            p = this.permissions,
            pdfKitOptions: _IPdfKitDocumentOptions = {
                compress: this._compress,
                bufferPages: this._bufferPages,
                pdfVersion: ['1.3', '1.4', '1.5', '1.6', '1.7', '1.7ext3'][this._version] as _PdfKitVersion,
                ownerPassword: this._ownerPassword || undefined,
                security: pdfSecurity ? pdfSecurity._PDFSecurity : null,
                permissions: {
                    annotating: wijmo.asBoolean(p.annotating, true),
                    contentAccessibility: wijmo.asBoolean(p.contentAccessibility, true),
                    copying: wijmo.asBoolean(p.copying, true),
                    documentAssembly: wijmo.asBoolean(p.documentAssembly, true),
                    fillingForms: wijmo.asBoolean(p.fillingForms, true),
                    modifying: wijmo.asBoolean(p.modifying, true),
                    printing: ((): _PdfKitPrintPermission => {
                        let v = wijmo.asEnum(p.printing, PdfPrintPermission, true);
                        return v == PdfPrintPermission.AllowHighResolution ? 'highResolution' : (v == PdfPrintPermission.AllowLowResolution ? 'lowResolution' : undefined)
                    })()
                },
                userPassword: this._userPassword || undefined,

                pageAdding: this._ehOnPageAdding = (doc: _IPdfKitDocument, options: _IPdfKitPageOptions) => {
                    if (!this._docInitialized) { // The event was raised before the PDFDocument's constructor call is completed.
                        autoPage = true;
                        pre(doc);
                    }

                    this._onPageAdding(doc, options);
                },
                pageAdded: this._ehOnPageAdded = (doc: _IPdfKitDocument) => {
                    // we need to reset current pen\ brush to reflect the actual page's stroking\ filling properties beacause each new page has an empty graphics state.
                    var brush = this._isDrawingText()
                        ? this._currentGS[this._pageIndex].brush // leave current brush because PDFKit spreads fill color between pages in case of page breaks when drawing text.
                        : new PdfSolidBrush()

                    this._currentGS[++this._pageIndex] = {
                        pen: new PdfPen(),
                        brush: brush
                    };

                    if (!this._docInitialized) { // The event was raised before the PDFDocument's constructor call is completed.
                        post();
                    }
                    this._onPageAdded(doc);
                }
            };

        this._setDocInfo(pdfKitOptions.info = {}, this.info);

        this._doc = new PDFDocument(pdfKitOptions);

        if (!autoPage) { // always false until the PDFKit's autoFirstPage option is not exposed to the PdfDocument.
            pre(this._doc);
            post();
        }

        this._doc
            .on('data', this._ehOnDocData = (chunk: any) => { this._onDocData(chunk); })
            .on('ending', this._ehOnDocEnding = () => { this._onDocEnding(); })
            .on('end', this._ehOnDocEnded = () => { this._onDocEnded(); });

        this._docInitialized = true;
    }

    //#region public properties

    /**
    * Gets a value that indicates whether the document compression is enabled.
    *
    * This property can be assigned using the {@link IPdfDocumentOptions} object passed to the {@link PdfDocument} constructor.
    *
    * The default value is true.
    */
    public get compress(): boolean {
        return this._compress;
    }

    /**
    * Gets a value that indicates whether the pages buffering mode is enabled which means
    * that the document's pages can be iterated over using {@link pageIndex} and {@link bufferedPageRange}.
    *
    * This property can be assigned using the {@link IPdfDocumentOptions} object passed to the {@link PdfDocument} constructor.
    * This property can be set to false only if both {@link header} and {@link footer} are invisible.
    *
    * The default value is true.
    */
    public get bufferPages(): boolean {
        return this._bufferPages;
    }

    /**
    * Gets or sets the document information, such as author name, document's creation
    * date and so on.
    */
    public info: IPdfDocumentInfo = {
        // keep wijmo.copy happy
        author: undefined,
        creationDate: undefined,
        keywords: undefined,
        modDate: undefined,
        subject: undefined,
        title: undefined
    };

    /**
    * Gets an object that represents a header, the page area positioned right below
    * the top margin.
    */
    public get header(): PdfRunningTitle {
        if (!this._header) {
            this._header = new PdfRunningTitle({
                _heightChanged: () => {
                    if (this._docInitialized) {
                        this._resetAreasOffset(this._doc);
                    }
                }
            });
        }

        return this._header
    }

    /**
    * Gets an object that represents a footer, the page area positioned right above
    * the bottom margin.
    */
    public get footer(): PdfRunningTitle {
        if (!this._footer) {
            this._footer = new PdfRunningTitle({
                _heightChanged: () => {
                    if (this._docInitialized) {
                        this._resetAreasOffset(this._doc);
                    }
                }
            });
        }

        return this._footer
    }

    /**
    * Gets or sets the index of the current page within the buffered pages range.
    *
    * Use the {@link bufferedPageRange} method to get the range of buffered pages.
    */
    public get pageIndex(): number {
        return this._pageIndex;
    }
    public set pageIndex(value: number) {
        value = wijmo.asNumber(value, false, true);

        if (this._pageIndex !== value) {
            this._doc.switchToPage(value); // an exception will be thrown internally if page is not buffered.
            this._pageIndex = value;
        }
    }

    /**
    * Gets the PDF owner password.
    *
    * This property can be assigned using the {@link IPdfDocumentOptions} object passed to the {@link PdfDocument} constructor.
    */
    public get ownerPassword(): string {
        return this._ownerPassword;
    }

    /**
    * Gets the PDF user password.
    *
    * This property can be assigned using the {@link IPdfDocumentOptions} object passed to the {@link PdfDocument} constructor.
    */
    public get userPassword(): string {
        return this._userPassword;
    }

    /**
    * Gets an object that represents the default page settings for the pages added
    * automatically and for the {@link addPage} method.
    */
    public pageSettings: IPdfPageSettings = <any>{
        layout: PdfPageOrientation.Portrait,
        size: PdfPageSize.Letter,
        margins: {
            top: 72,
            left: 72,
            bottom: 72,
            right: 72
        },
        _copy: function (key: string, value: any) {
            if (key === 'size') { // to avoid PdfPageSize <- wijmo.Size exception
                this.size = value;
                return true;
            }
        }
    };

    /**
    * Gets an object that represents PDF file permissions.
    *
    * This property can be assigned using the {@link IPdfDocumentOptions} object passed to the {@link PdfDocument} constructor.
    * Changing the property after creating PdfDocument will not have any effect.
    */
    public get permissions(): IPdfPermissions {
        return this._permissions;
    }

    /**
    * Gets PDF file version.
    *
    * This property can be assigned using the {@link IPdfDocumentOptions} object passed to the {@link PdfDocument} constructor.
    *
    * The default version is {@link PdfVersion.v1_3}.
    */
    public get version(): PdfVersion {
        return this._version;
    }

    //#endregion

    //#region public events

    /**
    * Occurs when the document has been rendered.
    */
    readonly ended = new wijmo.Event<PdfDocument, PdfDocumentEndedEventArgs>();

    /**
    * Occurs when a new page is added to the document.
    */
    readonly pageAdded = new wijmo.Event<PdfDocument, wijmo.EventArgs>();

    /**
    * Raises the {@link end} event.
    * 
    * @param args A {@link PdfDocumentEndedEventArgs} object that contains the event data.
    */
    public onEnded(args: PdfDocumentEndedEventArgs): void {
        if (this.ended) {
            this.ended.raise(this, args);
        }
    }

    /**
    * Raises the {@link pageAdded} event.
    *
    * @param args A {@link EventArgs} object that contains the event data.
    */
    public onPageAdded(args: wijmo.EventArgs): void {
        if (this.pageAdded) {
            this.pageAdded.raise(this, args);
        }
    }
    //#endregion

    //#region public methods

    /**
    * Disposes the document.
    */
    public dispose(): void {
        if (this._doc) {
            this._doc
                .removeListener('data', this._ehOnDocData)
                .removeListener('ending', this._ehOnDocEnding)
                .removeListener('end', this._ehOnDocEnded)
                .removeListener('pageAdding', this._ehOnPageAdding)
                .removeListener('pageAdded', this._ehOnPageAdded);

            this._doc = null;
            this._chunks = null;
        }
    }

    /**
    * Gets an object that represents the current page settings (read-only).
    *
    * @return A {@link IPdfPageSettings} object that represents the current page settings.
    */
    public get currentPageSettings(): IPdfPageSettings {
        var page = this._doc.page;
        return {
            layout: page.layout === 'landscape'
                ? PdfPageOrientation.Landscape
                : PdfPageOrientation.Portrait,

            size: wijmo.isArray(page.size)
                ? new wijmo.Size(page.size[0], page.size[1])
                // "LETTER" -> PdfPageSize.Letter, "SRA4" -> PdfPageSize.SRA4.
                : <any>PdfPageSize[page.size.match(/\d+/) ? page.size : _toTitleCase(page.size)],

            margins: {
                left: page.margins.left,
                right: page.margins.right,
                top: page.margins.top - this.header.height,
                bottom: page.margins.bottom - this.footer.height
            }
        };
    }

    /**
    * Adds a new page with the given settings.
    *
    * If the settings parameter is omitted, then {@link pageSettings} will be used instead.
    *
    * @param settings Page settings.
    * @return The {@link PdfDocument} object.
    */
    public addPage(settings?: IPdfPageSettings): PdfDocument {
        var native = this._pageSettingsToNative(settings || this.pageSettings);
        this._doc.addPage(native);
        return this;
    }

    /**
    * Gets the range of buffered pages.
    * @return A {@link IPdfBufferedPageRange} object that represents the range of buffered pages.
    */
    public bufferedPageRange(): IPdfBufferedPageRange {
        return this._doc.bufferedPageRange();
    }

    /**
    * Finishes the document rendering.
    */
    public end(): void {
        this._doc.end();
    }


    /**
    * Sets the default document brush.
    * This brush will be used by the {@link PdfPaths.fill}, {@link PdfPaths.fillAndStroke} and
    * {@link drawText} methods, if no specific brush is provided.
    *
    * The brush argument can accept the following values:
    * <ul>
    *   <li>A {@link PdfBrush} object.</li>
    *   <li>
    *     A {@link wijmo.Color} object or any string acceptable by the {@link wijmo.Color.fromString} method. 
    *     In this case, the {@link PdfBrush} object with the specified color will be created internally.
    *    </li>
    * </ul>
    *
    * @param brush The brush or color to use.
    * @return The {@link PdfDocument} object.
    */
    public setBrush(brush: PdfBrush | wijmo.Color | string): PdfDocument {
        this._assertAreasPathStarted();
        this._setCurBrush(this._defBrush = _asPdfBrush(brush, false).clone());
        return this;
    }

    /**
    * Sets the default document pen.
    * This pen will be used by the {@link PdfPaths.stroke}, {@link PdfPaths.fillAndStroke}
    * and {@link drawText} methods, if no specific pen is provided.
    *
    * The pen argument can accept the following values:
    * <ul>
    *   <li>A {@link PdfPen} object.</li>
    *   <li>
    *     A {@link wijmo.Color} object or any string acceptable by the {@link wijmo.Color.fromString} method. 
    *     In this case, the {@link PdfPen} object with the specified color will be created internally.
    *   </li>
    * </ul>
    *
    * @param pen The pen or color to use.
    * @return The {@link PdfDocument} object.
    */
    public setPen(pen: PdfPen | wijmo.Color | string): PdfDocument {
        this._assertAreasPathStarted();
        this._setCurPen(this._defPen = _asPdfPen(pen, false).clone());
        return this;
    }

    /**
    * Sets the document font.
    *
    * If exact font with given style and weight properties is not found then,  
    * <ul>
    *   <li>
    *     It tries to search the closest font using
    *     <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight">font weight fallback</a>.
    *   </li>
    *   <li>
    *     If still nothing is found, it tries to find the closest font with other style in following order:
    *     <ul>
    *       <li><b>'italic'</b>: 'oblique', 'normal'.</li>
    *       <li><b>'oblique'</b>: 'italic', 'normal'.</li>
    *       <li><b>'normal'</b>: 'oblique', 'italic'.</li>
    *     </ul>
    *   </li>
    * </ul>
    *
    * @param font The font object to set.
    *
    * @return The {@link PdfDocument} object.
    */
    public setFont(font: PdfFont): PdfDocument {
        this._setCurFont(this._defFont = _asPdfFont(font, false).clone());
        return this;
    }

    public _getFont(): PdfFont {
        return this._curFont;
    }

    /**
    * Registers a font from a source and associates it with a given font family name
    * and font attributes.
    *
    * @param font The font to register.
    *
    * @return The {@link PdfDocument} object.
    */
    public registerFont(font: IPdfFontFile): PdfDocument {
        wijmo.assert(!!font, _Errors.ValueCannotBeEmpty('font'));

        var buffer: ArrayBuffer;

        if (wijmo.isString(font.source)) { // URL
            let xhrError: any;
            buffer = _XhrHelper.arrayBuffer(font.source, xhr => xhrError = xhr.statusText || xhr.status);
            if (xhrError != null) {
                throw xhrError;
            }
        } else {
            if (font.source instanceof ArrayBuffer) {
                buffer = font.source;
            } else {
                throw _Errors.FontSourceMustBeStringArrayBuffer;
            }
        }

        font = _shallowCopy(font);
        font.source = buffer;

        this._fontReg.registerFont(font);

        return this;
    }

    /**
    * Registers a font from a URL asynchronously and associates it with a given font
    * family name and font attributes.
    *
    * The callback function takes a {@link IPdfFontFile} object as a parameter.
    *
    * @param font The font to register.
    * @param callback A callback function which will be called, when the font has been
    * registered.
    */
    public registerFontAsync(font: IPdfFontFile, callback: (font: IPdfFontFile) => void): void {
        wijmo.assert(typeof (font.source) === 'string', _Errors.FontSourceMustBeString);
        wijmo.asFunction(callback, false);

        _XhrHelper.arrayBufferAsync(font.source as string, (xhr, buffer) => {
            var fnt = _shallowCopy(font);
            fnt.source = buffer;

            this._fontReg.registerFont(fnt);

            callback(font);
        });
    }

    /**
    * Saves the state of the graphic context (including current pen, brush and
    * transformation state) and pushes it onto stack.
    *
    * @return The {@link PdfDocument} object.
    */
    public saveState(): PdfDocument {
        this._assertAreasPathStarted();

        this._graphicsStack.push(this._currentGS[this._pageIndex].pen.clone(), this._defPen.clone(), this._currentGS[this._pageIndex].brush.clone(), this._defBrush.clone());
        (<_IPdfKitDocument>this.document._document).save();

        return this;
    }

    /**
    * Restores the state from the stack and applies it to the graphic context.
    *
    * @return The {@link PdfDocument} object.
    */
    public restoreState(): PdfDocument {
        this._assertAreasPathStarted();

        if (this._graphicsStack.length) {
            this._defBrush = this._graphicsStack.pop();
            this._currentGS[this._pageIndex].brush = this._graphicsStack.pop();
            this._defPen = this._graphicsStack.pop();
            this._currentGS[this._pageIndex].pen = this._graphicsStack.pop();
        }

        (<_IPdfKitDocument>this.document._document).restore();
        return this;
    }

    //#endregion

    //#region internal

    private _runtimeProperties = ['pageIndex', 'x', 'y']; // this read-write properties can be accessed in run-time only.

    public _copy(key: string, value: any): boolean {
        if (key === 'compress') { // read-only property.
            this._compress = wijmo.asBoolean(value);
            return true;
        }

        if (key === 'bufferPages') { // read-only property.
            this._bufferPages = wijmo.asBoolean(value);
            return true;
        }

        if (key === 'ownerPassword') { // read-only property.
            this._ownerPassword = wijmo.asString(value);
            return true;
        }

        if (key === 'userPassword') { // read-only property.
            this._userPassword = wijmo.asString(value);
            return true;
        }

        if (key === 'version') { // read-only property.
            this._version = wijmo.asEnum(value, PdfVersion);
            return true;
        }

        if (this._runtimeProperties.indexOf(key) >= 0) {
            return true;
        }

        return false;
    }

    public get _document(): any {
        return this._doc;
    }

    public _switchTextFlowCtx(state: _IPdfTextFlowCtxState) {
        this._doc.x = state.xo;
        this._doc.y = state.yo;
        this._doc.lineGap(state.lineGap);
    }

    public _getTextFlowCtxState(): _IPdfTextFlowCtxState {
        return {
            xo: this._doc.x,
            yo: this._doc.y,
            lineGap: this._doc.currentLineGap()
        };
    }

    public _toggleBrush(brush?: PdfBrush): void {
        if (brush) {
            this._setCurBrush(brush);
        } else {
            this._setCurBrush(this._defBrush);
        }
    }

    public _togglePen(pen?: PdfPen): void {
        if (pen) {
            this._setCurPen(pen);
        } else {
            this._setCurPen(this._defPen);
        }
    }

    public _toggleFont(font?: PdfFont): void {
        if (font) {
            this._setCurFont(font);
        } else {
            this._setCurFont(this._defFont);
        }
    }

    //#endregion

    //#region private event handlers

    private _onDocData(chunk: any): void {
        this._chunks.push(chunk);
    }

    private _onDocEnding(): void {
        this._processHeadersFooters();
        this._setDocInfo(this._doc.info, this.info);
    }

    private _setDocInfo(native: _IPdfKitDocumentInfo, info: IPdfDocumentInfo) {
        if (info) {
            var v;

            if (v = info.author) {
                native.Author = v;
            }

            if (v = info.creationDate) {
                native.CreationDate = v;
            }

            if (v = info.keywords) {
                native.Keywords = v;
            }

            if (v = info.modDate) {
                native.ModDate = v;
            }

            if (v = info.subject) {
                native.Subject = v;
            }

            if (v = info.title) {
                native.Title = v;
            }
        }
    }

    private _onDocEnded(): void {
        if (_IE && this._chunks.length) { // 'InvalidStateError' exception occurs in IE10 (IE11 works fine) when chunks are passed directly into the Blob constructor, so convert each item to ArrayBuffer first.
            if (!this._chunks[0].buffer) { // Not a typed array? IE10.
                // [] -> ArrayBuffer
                for (var i = 0; i < this._chunks.length; i++) {
                    var chunk = this._chunks[i],
                        buf = new Uint8Array(chunk.length);

                    for (var j = 0; j < chunk.length; j++) {
                        buf[j] = chunk[j];
                    }

                    this._chunks[i] = <any>buf.buffer;
                }
            }
        }

        this.onEnded(new PdfDocumentEndedEventArgs(this._chunks));
        this._chunks = [];
    }

    private _onPageAdding(doc: _IPdfKitDocument, options: _IPdfKitPageOptions): void {
        if (this.pageSettings) {
            var native = this._pageSettingsToNative(this.pageSettings);

            options.layout = doc.options.layout = native.layout;
            options.margins = doc.options.margins = native.margins;
            options.size = doc.options.size = native.size;
        }
    }

    private _onPageAdded(doc: _IPdfKitDocument): void {
        doc.page.originalMargins = _shallowCopy(doc.page.margins);
        this._resetAreasOffset(doc);
        this.onPageAdded(wijmo.EventArgs.empty);
    }

    //#endregion

    //#region private

    private _assertAreasPathStarted(): void {
        if (!this._docInitialized) {
            return;
        }
        this._assertPathStarted();
        this.header._assertPathStarted();
        this.footer._assertPathStarted();
    }

    private _pageSettingsToNative(pageSettings: IPdfPageSettings): _IPdfKitPageOptions {
        var res: _IPdfKitPageOptions = {};

        if (pageSettings) {
            var layout = wijmo.asEnum(pageSettings.layout, PdfPageOrientation, true);
            if (layout != null) {
                res.layout = (PdfPageOrientation[layout] || '').toLowerCase();
            }

            var margins = pageSettings.margins;
            if (margins) {
                res.margins = {
                    left: wijmo.asNumber(margins.left, false, true),
                    right: wijmo.asNumber(margins.right, false, true),
                    top: wijmo.asNumber(margins.top, false, true),
                    bottom: wijmo.asNumber(margins.bottom, false, true)
                };
            }

            var size = pageSettings.size;
            if (size != null) {
                if (size instanceof wijmo.Size) { // custom size
                    res.size = [
                        wijmo.asNumber((<wijmo.Size>size).width, false, true),
                        wijmo.asNumber((<wijmo.Size>size).height, false, true)
                    ];
                } else {
                    size = wijmo.asEnum(size, PdfPageSize);
                    res.size = (PdfPageSize[size] || '').toUpperCase();
                }
            }
        }

        return res;
    }

    private _processHeadersFooters(): void {
        var hdr = this.header,
            ftr = this.footer;

        if (hdr.height > 0 || ftr.height > 0) {
            var doc = this._doc;

            wijmo.assert(doc.options.bufferPages, _Errors.BufferPagesMustBeEnabled);

            var range = doc.bufferedPageRange();
            for (var i = range.start; i < range.count; i++) {
                var frmt = {
                    'Page': i + 1,
                    'Pages': range.count
                };

                this.pageIndex = i; // switch page

                this._renderHeaderFooter(hdr, frmt, true);
                this._renderHeaderFooter(ftr, frmt, false);
            }
        }
    }

    private _renderHeaderFooter(title: PdfRunningTitle, macros: any, isHeader: boolean): void {
        if (title.height > 0 && title.declarative && title.declarative.text) {
            var text = _formatMacros(title.declarative.text, macros),
                parts = text.split('\t');

            if (parts.length > 0 && parts[0]) {
                this._renderHeaderFooterPart(title, parts[0], PdfTextHorizontalAlign.Left, isHeader);
            }

            if (parts.length > 1 && parts[1]) {
                this._renderHeaderFooterPart(title, parts[1], PdfTextHorizontalAlign.Center, isHeader);
            }

            if (parts.length > 2 && parts[2]) {
                this._renderHeaderFooterPart(title, parts[2], PdfTextHorizontalAlign.Right, isHeader);
            }
        }
    }

    private _renderHeaderFooterPart(title: PdfRunningTitle, text: string, alignment: PdfTextHorizontalAlign, isHeader: boolean): void {
        var textSettings: IPdfTextDrawSettings = {
            font: title.declarative.font,
            brush: title.declarative.brush,
            width: title.width,
            height: title.height,
            align: alignment
        };

        if (isHeader) {
            this.header.drawText(text, 0, 0, textSettings); // top alignment
        } else {
            (<IPdfTextMeasurementSettings>textSettings).includeLastLineExternalLeading = false;
            var sz = this.footer.measureText(text, textSettings.font, textSettings);
            this.footer.drawText(text, 0, this.footer.height - sz.size.height, textSettings); // bottom alignment
        }
    }

    private _setCurBrush(brush: PdfBrush): void {
        if (!this._currentGS[this.pageIndex].brush.equals(brush)) {
            this._setNativeDocBrush(brush, false);
            this._currentGS[this.pageIndex].brush = brush.clone();
        }
    }

    private _setCurFont(font: PdfFont): void {
        if (!this._curFont.equals(font)) {
            var internalName = this._fontReg.findFont(font.family, font.style, font.weight);
            this._doc.font(internalName, font.size || PdfFont._DEF_FONT.size);
            this._curFont = font.clone();
        }
    }

    private _setCurPen(pen: PdfPen): void {
        var d = this._doc,
            cp = this._currentGS[this.pageIndex].pen;

        // check color and brush. brush property is nullable.
        if (pen.brush && (!cp.brush || !cp.brush.equals(pen.brush))) { // brush is changed
            this._setNativeDocBrush(pen.brush, true);
        } else {
            if ((cp.brush && !pen.brush) || (!cp.brush && !cp.color.equals(pen.color))) { // color is changed
                d.strokeColor([pen.color.r, pen.color.g, pen.color.b], pen.color.a);
            }
        }

        if (cp.width !== pen.width) {
            d.lineWidth(pen.width);
        }

        if (cp.miterLimit !== pen.miterLimit) {
            d.miterLimit(pen.miterLimit);
        }

        if (cp.cap !== pen.cap) {
            d.lineCap(pen.cap);
        }

        if (cp.join !== pen.join) {
            d.lineJoin(pen.join);
        }

        // check dashPattern. dashPattern.dash == null means no dashes.
        if (!cp.dashPattern.equals(pen.dashPattern)) {
            if (pen.dashPattern.dash != null) {
                d.dash(pen.dashPattern.dash, { space: pen.dashPattern.gap, phase: pen.dashPattern.phase });
            } else {
                if (cp.dashPattern.dash != null) {
                    d.undash();
                }
            }
        }

        this._currentGS[this.pageIndex].pen = pen.clone();
    }

    // true = stroke, fill = false
    private _setNativeDocBrush(brush: PdfBrush, strokeOrFill: boolean): void {
        var d = this._doc,
            nativeColor = brush._getBrushObject(this),
            opacity = 1;

        if (nativeColor instanceof wijmo.Color) { // PdfSolidBrush
            opacity = (<wijmo.Color>nativeColor).a;
            nativeColor = [(<wijmo.Color>nativeColor).r, (<wijmo.Color>nativeColor).g, (<wijmo.Color>nativeColor).b];
        } else { // gradient brushes
            if (brush instanceof PdfGradientBrush) {
                opacity = (<PdfGradientBrush>brush).opacity;
            }
        }

        if (strokeOrFill) {
            d.strokeColor(nativeColor, opacity);
        } else {
            d.fillColor(nativeColor, opacity);
        }
    }

    private _resetAreasOffset(doc: _IPdfKitDocument): void {
        // * update native margins *
        // top margin
        doc.page.margins.top = doc.page.originalMargins.top + this.header.height;
        doc.y = doc.page.margins.top;

        // bottom margin
        doc.page.margins.bottom = doc.page.originalMargins.bottom + this.footer.height;

        // reset page areas offsets
        this._header._initialize(this, doc.page.margins.left, doc.page.originalMargins.top);
        this._initialize(this, doc.page.margins.left, doc.page.margins.top);
        this._footer._initialize(this, doc.page.margins.left, doc.page.height - doc.page.margins.bottom);
    }

    //#endregion
}
    }
    


    module wijmo.pdf {
    









'use strict';

interface _IPathFunc {
    func: Function;
    params: any[];
}

/**
* Provides methods for creating graphics paths and drawing them or using them for clipping. 
*
* Path creation method calls must be finished with the {@link PdfPaths.stroke},
* {@link PdfPaths.fill}, {@link PdfPaths.fillAndStroke} or {@link PdfPaths.clip} method.
* Any document methods which don't apply directly to path creation/ drawing/ clipping 
* (changing a pen, drawing a text, saving the graphics state etc) are prohibited to use
* until the path is finished.
* The {@link PdfPaths.lineTo}, {@link PdfPaths.bezierCurveTo} and {@link PdfPaths.quadraticCurveTo} 
* methods should not start the path, they must be preceded with the {@link PdfPaths.moveTo}.
*
* The methods are chainable:
* <pre>
* doc.paths.moveTo(0, 0).lineTo(100, 100).stroke();
* </pre>
*
* This class is not intended to be instantiated in your code.
*/
export class PdfPaths {
    private _doc: PdfDocument;
    private _offset: wijmo.Point;
    private _pathBuffer: _IPathFunc[] = [];

    /**
    * Initializes a new instance of the {@link PdfPaths} class.
    *
    * @param doc Document.
    * @param offset Offset.
    */
    constructor(doc: PdfDocument, offset: wijmo.Point) {
        this._doc = doc;
        this._offset = offset;
    }

    //#region public

    /**
    * Sets a new current point.
    *
    * @param x The X-coordinate of the new point, in points.
    * @param y The Y-coordinate of the new point, in points.
    * @return The {@link PdfPaths} object.
    */
    public moveTo(x: number, y: number): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).moveTo,
            params: [wijmo.asNumber(x) + this._offset.x, wijmo.asNumber(y) + this._offset.y]
        });

        return this;
    }

    /**
    * Draws a line from the current point to a new point.
    *
    * The new current point is (x, y).
    *
    * @param x The X-coordinate of the new point, in points.
    * @param y The Y-coordinate of the new point, in points.
    * @return The {@link PdfPaths} object.
    */
    public lineTo(x: number, y: number): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).lineTo,
            params: [wijmo.asNumber(x) + this._offset.x, wijmo.asNumber(y) + this._offset.y]
        });

        return this;
    }

    /**
    * Draws a quadratic curve from the current point to a new point using the current point
    * and (cpx, cpy) as the control points.
    *
    * The new current point is (x, y).
    *
    * @param cpx The X-coordinate of the control point, in points.
    * @param cpy The Y-coordinate of the control point, in points.
    * @param x The X-coordinate of the new point, in points.
    * @param y The Y-coordinate of the new point, in points.
    * @return The {@link PdfPaths} object.
    */
    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).quadraticCurveTo,
            params: [
                wijmo.asNumber(cpx) + this._offset.x,
                wijmo.asNumber(cpy) + this._offset.y,
                wijmo.asNumber(x) + this._offset.x,
                wijmo.asNumber(y) + this._offset.y
            ]
        });

        return this;
    }

    /**
    * Draws a bezier curve from the current point to a new point using the (cp1x, cp1y)
    * and (cp2x, cp2y) as the control points.
    *
    * The new current point is (x, y).
    *
    * @param cp1x The X-coordinate of the first control point, in points.
    * @param cp1y The Y-coordinate of the first control point, in points.
    * @param cp2x The X-coordinate of the second control point, in points.
    * @param cp2y The Y-coordinate of the second control point, in points.
    * @param x The X-coordinate of the new point, in points.
    * @param y The Y-coordinate of the new point, in points.
    * @return The {@link PdfPaths} object.
    */
    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).bezierCurveTo,
            params: [
                wijmo.asNumber(cp1x) + this._offset.x,
                wijmo.asNumber(cp1y) + this._offset.y,
                wijmo.asNumber(cp2x) + this._offset.x,
                wijmo.asNumber(cp2y) + this._offset.y,
                wijmo.asNumber(x) + this._offset.x,
                wijmo.asNumber(y) + this._offset.y
            ]
        });

        return this;
    }

    /**
    * Draws a SVG 1.1 path.
    *
    * @param path The SVG path to draw.
    * @return The {@link PdfPaths} object.
    */
    public svgPath(path: string): PdfPaths {
        if (path) {
            var updatedPath = _PdfSvgPathHelper.offset(wijmo.asString(path), this._offset);

            this._pathBuffer.push({
                func: (<_IPdfKitDocument>this._doc._document).path,
                params: [wijmo.asString(updatedPath)]
            });
        }
        return this;
    }

    /**
    * Closes the current path and draws a line from the current point to the initial
    * point of the current path.
    *
    * @return The {@link PdfPaths} object.
    */
    public closePath(): PdfPaths {
        this._writePathBuffer();
        (<_IPdfKitDocument>this._doc._document).closePath();
        return this;
    }

    /**
    * Draws a rectangle.
    *
    * @param x The X-coordinate of the topleft corner of the rectangle, in points.
    * @param y The Y-coordinate of the topleft corner of the rectangle, in points.
    * @param width The width of the rectangle, in points.
    * @param height The width of the rectangle, in points.
    * @return The {@link PdfPaths} object.
    */
    public rect(x: number, y: number, width: number, height: number): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).rect,
            params: [
                wijmo.asNumber(x) + this._offset.x,
                wijmo.asNumber(y) + this._offset.y,
                wijmo.asNumber(width, false, true),
                wijmo.asNumber(height, false, true)
            ]
        });

        return this;
    }

    /**
    * Draws a rounded rectangle.
    *
    * @param x The X-coordinate of the upper-left corner of the rectangle, in points.
    * @param y The Y-coordinate of the upper-left corner of the rectangle, in points.
    * @param width The width of the rectangle, in points.
    * @param height The width of the rectangle, in points.
    * @param cornerRadius The corner radius of the rectangle, in points. The default value is 0.
    * @return The {@link PdfPaths} object.
    */
    public roundedRect(x: number, y: number, width: number, height: number, cornerRadius: number = 0): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).roundedRect,
            params: [
                wijmo.asNumber(x) + this._offset.x,
                wijmo.asNumber(y) + this._offset.y,
                wijmo.asNumber(width, false, true),
                wijmo.asNumber(height, false, true),
                wijmo.asNumber(cornerRadius, false, true)
            ]
        });

        return this;
    }

    /**
    * Draws an ellipse.
    *
    * @param x The X-coordinate of the center of the ellipse, in points.
    * @param y The Y-coordinate of the center of the ellipse, in points.
    * @param radiusX The radius of the ellipse along the X-axis, in points.
    * @param radiusY The radius of the ellipse along the Y-axis, in points. 
    * If it is not provided, then it is assumed to be equal to radiusX.
    * @return The {@link PdfPaths} object.
    */
    public ellipse(x: number, y: number, radiusX: number, radiusY: number = radiusX): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).ellipse,
            params: [
                wijmo.asNumber(x) + this._offset.x,
                wijmo.asNumber(y) + this._offset.y,
                wijmo.asNumber(radiusX, false, true),
                wijmo.asNumber(radiusY, false, true)
            ]
        });

        return this;
    }

    /**
    * Draws a circle.
    *
    * @param x The X-coordinate of the center of the circle, in points.
    * @param y The Y-coordinate of the center of the circle, in points.
    * @param radius The radius of the circle, in points.
    * @return The {@link PdfPaths} object.
    */
    public circle(x: number, y: number, radius: number): PdfPaths {
        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).circle,
            params: [
                wijmo.asNumber(x) + this._offset.x,
                wijmo.asNumber(y) + this._offset.y,
                wijmo.asNumber(radius, false, true)
            ]
        });

        return this;
    }

    /**
    * Draws a polygon using a given points array.
    * 
    * @param points An array of two-elements arrays [x, y] specifying
    * the X and Y coordinates of the point, in points.
    * @return The {@link PdfPaths} object.
    */
    public polygon(points: number[][]): PdfPaths {
        if (points) {
            for (var i = 0; i < points.length; i++) {
                var pnt = points[i];

                pnt[0] = pnt[0] + this._offset.x;
                pnt[1] = pnt[1] + this._offset.y;
            }
        }

        this._pathBuffer.push({
            func: (<_IPdfKitDocument>this._doc._document).polygon,
            params: points
        })

        return this;
    }

    /**
    * Creates a clipping path used to limit the regions of the page affected by 
    * painting operators.
    *
    * @param rule The fill rule to use.
    * @return The {@link PdfPaths} object.
    */
    public clip(rule: PdfFillRule = PdfFillRule.NonZero): PdfPaths {
        this._writePathBuffer();
        (<_IPdfKitDocument>this._doc._document).clip(rule === PdfFillRule.EvenOdd ? 'even-odd' : 'non-zero');
        return this;
    }

    /**
    * Fills the path with the specified brush and rule.
    * If brush is not specified, then the default document brush will be used 
    * (see the {@link PdfDocument.setBrush} method).
    *
    * The brush argument can accept the following values:
    * <ul>
    *   <li>A {@link PdfBrush} object.</li>
    *   <li>
    *     A {@link wijmo.Color} object or any string acceptable by the {@link wijmo.Color.fromString} method. 
    *     In this case, the {@link PdfBrush} object with the specified color will be created internally.
    *    </li>
    * </ul>
    *
    * @param brush The brush or color to use.
    * @param rule The fill rule to use.
    * @return The {@link PdfPaths} object.
    */
    public fill(brush?: PdfBrush | wijmo.Color | string, rule?: PdfFillRule): PdfPaths {
        this._doc._toggleBrush(_asPdfBrush(brush));
        this._writePathBuffer();
        (<_IPdfKitDocument>this._doc._document).fill(rule === PdfFillRule.EvenOdd ? 'even-odd' : 'non-zero');

        return this;
    }

    /**
    * Fills and strokes the path with the specified brush, pen and rule.
    * If brush and pen is not specified, then the default document brush and pen will
    * be used (See the {@link PdfDocument.setBrush}, {@link PdfDocument.setPen} methods).
    *
    * The brush argument can accept the following values:
    * <ul>
    *   <li>A {@link PdfBrush} object.</li>
    *   <li>
    *     A {@link wijmo.Color} object or any string acceptable by the {@link wijmo.Color.fromString} method. 
    *     In this case, the {@link PdfBrush} object with the specified color will be created internally.
    *    </li>
    * </ul>
    *
    * The pen argument can accept the following values:
    * <ul>
    *   <li>A {@link PdfPen} object.</li>
    *   <li>
    *     A {@link wijmo.Color} object or any string acceptable by the {@link wijmo.Color.fromString} method. 
    *     In this case, the {@link PdfPen} object with the specified color will be created internally.
    *   </li>
    * </ul>
    *
    * @param brush The brush or color to use.
    * @param pen The pen or color to use.
    * @param rule The fill rule to use.
    * @return The {@link PdfPaths} object.
    */
    public fillAndStroke(brush?: PdfBrush | wijmo.Color | string, pen?: PdfPen | wijmo.Color | string, rule?: PdfFillRule): PdfPaths {
        this._doc._toggleBrush(_asPdfBrush(brush));
        this._doc._togglePen(_asPdfPen(pen));

        this._writePathBuffer();
        (<_IPdfKitDocument>this._doc._document).fillAndStroke(rule === PdfFillRule.EvenOdd ? 'even-odd' : 'non-zero');

        return this;
    }

    /**
    * Strokes the path with the specified pen.
    * If pen is not specified, then the default document pen will be used 
    * (See the {@link PdfDocument.setPen} method).
    *
    * The pen argument can accept the following values:
    * <ul>
    *   <li>A {@link PdfPen} object.</li>
    *   <li>
    *     A {@link wijmo.Color} object or any string acceptable by the {@link wijmo.Color.fromString} method. 
    *     In this case, the {@link PdfPen} object with the specified color will be created internally.
    *   </li>
    * </ul>
    * 
    * @param pen The pen or color to use.
    * @return The {@link PdfPaths} object.
    */
    public stroke(pen?: PdfPen | wijmo.Color | string): PdfPaths {
        this._doc._togglePen(_asPdfPen(pen));
        this._writePathBuffer();
        (<_IPdfKitDocument>this._doc._document).stroke();

        return this;
    }

    //#endregion

    //#region internal, private 

    public _hasPathBuffer(): boolean {
        return this._pathBuffer.length > 0;
    }

    private _writePathBuffer() {
        var doc = <_IPdfKitDocument>this._doc._document;

        for (var i = 0; i < this._pathBuffer.length; i++) {
            var item = this._pathBuffer[i];

            item.func.apply(doc, item.params);
        }

        this._pathBuffer = [];
    }

    //#endregion.
}
    }
    


    module wijmo.pdf {
    // Entry file. All real code files should be re-exported from here.


wijmo._registerModule('wijmo.pdf', wijmo.pdf);




//export * from './_messages';
//export * from './_safe-color';










//export * from './font/_pdf-font-registrar';



 // Also used in FlexGridPdfConverter

//export * from './_pdf-svg-path-helper';
//export * from './_xhr-helper';


//export * from './svg/_util';
//export * from './svg/_attributes';
//export * from './svg/_elements';
//export * from './svg/_svg-renderer';
    }
    


    module wijmo.pdf {
    


'use strict';

export type _TDictionary<T> = { [key: string]: T };

export function _compressSpaces(value: string): string {
    if (value) {
        value = value.trim().replace(/\s+/gm, ' ');
    }

    return value;
}

export function _resolveUrlIfRelative(url: string, urlResolver: (url: string) => string): string {
    if (url && urlResolver && !/(^[a-z][a-z0-9]*:)?\/\//i.test(url)) { // (protocol:)?//
        url = urlResolver(url);
    }

    return url;
}

export interface _ISvgCssPropertyValue {
    value: string;
    important: boolean;
}

export class _SvgCssRule {
    public declarations: _TDictionary<_ISvgCssPropertyValue> = {};

    constructor(public selector: string, declaration: string) {
        this._fillDeclarations(declaration);
    }

    private _fillDeclarations(declaration: string): void {
        if (!declaration) {
            return;
        }

        declaration.split(';').forEach(item => {
            if (item) {
                var def = item.split(':');
                if (def.length === 2) {
                    var name = def[0].trim().toLowerCase(),
                        value = def[1].trim();

                    if (name && value) {
                        var important = /!important$/i.test(value);

                        if (important) {
                            value = value.replace(/!important$/i, '').trim();
                        }

                        if (value) {
                            this.declarations[name] = {
                                value: value,
                                important: important
                            };
                        }
                    }
                }
            }
        });
    }
}

export class _SvgCssHelper {
    public static matchesSelector(node: Element, selector: string): boolean {
        var res = false;

        try {
            var fn: Function = (<any>node).matches || (<any>node).msMatchesSelector || node.webkitMatchesSelector || (<any>node).mozMatchesSelector;
            res = fn.call(node, selector);
        } catch (ex) { }

        return res;
    }

    public static getSpecificity(selector: string): number {
        var a = 0,
            b = 0,
            c = 0,
            match = (rg: RegExp): number => {
                var match = (selector.match(rg) || []).length;

                if (match) {
                    selector = selector.replace(rg, '');
                }

                return match;
            };

        // An adapted version of https://github.com/keeganstreet/specificity/blob/master/specificity.js

        // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
        selector = selector.replace(/:not\(([^\)]*)\)/g, (match, g1: string) => {
            return ' ' + g1 + ' ';
        });

        // Add attribute selectors to parts collection
        b += match(/(\[[^\]]+\])/g);

        // Add ID selectors to parts collection
        a += match(/(#[^\s\+>~\.\[:]+)/g);

        // Add class selectors to parts collection
        b += match(/(\.[^\s\+>~\.\[:]+)/g);

        // Add pseudo-element selectors to parts collection
        c += match(/(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi);

        // Add pseudo-class selectors to parts collection
        b += match(/(:[\w-]+\([^\)]*\))/gi);
        b += match(/(:[^\s\+>~\.\[:]+)/g);

        // Remove universal selector and separator characters
        selector = selector.replace(/[\*\s\+>~]/g, ' ');

        // Remove any stray dots or hashes which aren't attached to words
        selector = selector.replace(/[#\.]/g, ' ');

        // The only things left should be element selectors
        c += match(/([^\s\+>~\.\[:]+)/g);

        return (a << 16) | (b << 8) | c;
    }

    // Computes the actual styling properties of a node determined by the 'class' and 'style' attributes and returns them as a stylePropName-stylePropValue dictionary.
    public static getComputedStyle(node: SVGElement, registeredRules: _TDictionary<_SvgCssRule>): _TDictionary<string> {
        var composite: _TDictionary<_ISvgCssPropertyValue> = {},
            associatedRules: _SvgCssRule[] = [];

        // find the associated CSS rules
        if (node.className) {
            var associatedRules: _SvgCssRule[] = [];

            for (var i = 0, keys = Object.keys(registeredRules); i < keys.length; i++) {
                var selector = keys[i];

                if (this.matchesSelector(node, selector)) {
                    associatedRules.push(registeredRules[selector]);
                }
            }
        }

        // prioritize
        associatedRules.sort((a, b) => this.getSpecificity(a.selector) - this.getSpecificity(b.selector));

        // append the 'style' attribute (it has the highest specificity)
        var inline = node.getAttribute('style');
        if (inline) {
            associatedRules.push(new _SvgCssRule('_inline_', _compressSpaces(inline)));
        }

        // compose rules
        for (var i = 0; i < associatedRules.length; i++) {
            var rule = associatedRules[i];

            for (var j = 0, keys = Object.keys(rule.declarations); j < keys.length; j++) {
                var name = keys[j],
                    val = rule.declarations[name];

                //!important property has a higher priority than non-!important even if the second one comes from the more specialized rule.
                if ((composite[name] == null) || (val.important || !composite[name].important)) {
                    composite[name] = val;
                }
            }
        }

        // convert to dictionary
        var result: _TDictionary<string> = {};
        for (var i = 0, keys = Object.keys(composite); i < keys.length; i++) {
            var name = keys[i];
            result[name] = composite[name].value;
        }

        return result;
    }

    public static registerFontFace(doc: PdfDocument, rule: _SvgCssRule, urlResolver?: (url: string) => string): void {
        var rd = rule.declarations;

        if (!rd['font-family'] || !rd['src']) {
            return;
        }

        rd['src'].value.split(',').every(url => {
            if (url.match(/format\(\s*['"]?truetype['"]?\s*\)/i)) { // truetype only
                var match = url.match(/url\(\s*['"]?([^'"\)]+)['"]?\s*\)/i);
                if (match) {
                    var src = match[1].trim(),
                        success = false;

                    if (src = _resolveUrlIfRelative(src, urlResolver)) {
                        var font: IPdfFontFile = {
                            name: rd['font-family'].value,
                            source: src,
                            weight: rd['font-weight'] ? rd['font-weight'].value.toLowerCase() : 'normal',
                            style: rd['font-style'] ? rd['font-style'].value.toLowerCase() : 'normal'
                        }

                        try {
                            doc.registerFont(font);
                            success = true;
                        } catch (ex) { }
                    }

                    return !success; // break the loop if success
                }
            }

            return true;
        });
    }
}
    }
    


    module wijmo.pdf {
    









'use strict;'

export interface _ISvgRenderContext {
    area: PdfPageArea;
    urlResolver: (url: string) => string;
    getElement: (id: string) => _SvgElementBase;
    registerCssRule: (rule: _SvgCssRule) => void;
}

export class _SvgRenderer {
    private _elementsById: _TDictionary<_SvgElementBase> = {};
    private _registeredCssRules: _TDictionary<_SvgCssRule> = {};
    private _svg: _SvgSvgElementImpl;
    private _doc: PdfDocument;

    constructor(svgString: string, area: PdfPageArea, vpWidth?: number, vpHeight?: number, urlResolver?: (url: string) => string) {
        wijmo.assert(area != null, _Errors.ValueCannotBeEmpty('svgString'));

        this._doc = area.document;

        var dom = this._parse(svgString);
        if (dom) {
            this._svg = new _SvgSvgElementImpl({
                area: area,
                urlResolver: urlResolver,
                getElement: this._getElementById.bind(this),
                registerCssRule: (rule: _SvgCssRule) => {
                    this._registerCssRule(rule, urlResolver);
                }
            }, null);
            this._copyAttributes(dom, this._svg);
            this._buildTree(dom, this._svg);
            // pre-set viewport, so the outermost svg element's height and width properties can be resolved against the viewport before rendering
            this._svg.viewport = new wijmo.Size(vpWidth != null ? vpWidth : area.width, vpHeight != null ? vpHeight : area.height);
        }
    }

    public get root(): _SvgSvgElementImpl {
        return this._svg;
    }

    public render(viewPort?: wijmo.Size) {
        if (this._svg) {
            this._svg.render(viewPort || this._svg.viewport);
        }
    }

    private _parse(svg: string): SVGSVGElement {
        if (svg) {
            var parser = new DOMParser();
            (<any>parser).async = false;

            return parser.parseFromString(svg, 'text/xml').getElementsByTagName('svg')[0];

            //// IE10\11 throws the "SyntaxError" exception if xmlns:xlink is missed and if the string being parsed contains elements which are use the 'xlink' attribute.
            //svg = '<svg xmlns:xlink="http://www.w3.org/1999/xlink">' + svg + '</svg>';
            //return <SVGElement>parser.parseFromString(svg, 'text/xml').querySelector('svg').querySelector('svg');
        }
    }

    private _buildTree(dom: Node, tree: _SvgElementBase, handleTextNodes?: boolean): void {
        for (var i = 0; dom.childNodes && i < dom.childNodes.length; i++) {
            var domChild = <SVGElement>dom.childNodes.item(i),
                nodeName = domChild.nodeName;

            if (domChild.nodeType === 1) {
                var className = this._getClassName(nodeName);

                // todo: check
                if (wijmo.pdf[className]) {
                    var element = new (<_ISvgElementBaseCtor>wijmo.pdf[className])(tree.ctx, domChild);
                    this._copyAttributes(domChild, element);
                    tree.appendNode(element);

                    var id;
                    if (id = domChild.getAttribute('id')) {
                        this._elementsById[id] = element;
                    }

                    this._buildTree(domChild, element, nodeName === 'text' || (handleTextNodes && nodeName === 'tspan'));
                } else {
                    //DEBUG
                    //alert('Not implemented: ' + nodeName);
                }
            } else {
                if (domChild.nodeType === 3 && handleTextNodes) {
                    var textContent = domChild.textContent.trim();

                    if (textContent) {
                        // <tspan />\r\n[text] => <tspan />_text
                        if (i != 0 && dom.childNodes[i - 1].nodeType === 1 && domChild.textContent.match(/^\s/)) {
                            tree.appendNode(new _SvgTspanElementImpl(tree.ctx, null, ' '));
                        }

                        var text = _compressSpaces(domChild.textContent);
                        tree.appendNode(new _SvgTspanElementImpl(tree.ctx, null, text));
                    }

                    // <tspan />\r\n<tspan /> => <tspan />_<tspan />
                    // [text]\r\n[smth] -> [text]_[smth]
                    if (!textContent || domChild.textContent.match(/\s$/)) {
                        tree.appendNode(new _SvgTspanElementImpl(tree.ctx, null, ' '));
                    }
                }
            }
        }
    }

    // Any class that wraps a SVG element must follow this naming pattern
    private _getClassName(nodeName: string): string {
        return '_Svg' + nodeName.charAt(0).toUpperCase() + nodeName.substring(1) + 'ElementImpl';
    }

    private _copyAttributes(node: SVGElement, element: _SvgElementBase): void {
        // copy attributes
        for (var i = 0; i < node.attributes.length; i++) {
            var attr = node.attributes.item(i);
            element.attr(attr.name, attr.value);
        }

        var css = _SvgCssHelper.getComputedStyle(node, this._registeredCssRules);

        // convert CSS to attributes (some of the presentation attributes will be overwritten as they have lower priority than CSS)
        for (var i = 0, keys = Object.keys(css); i < keys.length; i++) {
            var name = keys[i];
            element.attr(name, css[name]);
        }
    }

    private _getElementById(id: string): _SvgElementBase {
        id = (id || '').replace('#', '');
        return this._elementsById[id];
    }

    private _registerCssRule(rule: _SvgCssRule, urlResolver?: (url: string) => string): void {
        if (rule.selector[0] !== '@') {
            this._registeredCssRules[rule.selector] = rule;
        } else {
            if (rule.selector === '@font-face') {
                _SvgCssHelper.registerFontFace(this._doc, rule, urlResolver);
            }
        }
    }
}
    }
    


    module wijmo.pdf {
    















'use strict';

//#region Base elements

export enum _SvgRenderMode {
    Render,
    Ignore,
    Clip
}

export interface _ISvgElementBaseCtor {
    new(ctx: _ISvgRenderContext, node: SVGElement, defRenderMode?: _SvgRenderMode): _SvgElementBase;
}

export class _SvgElementBase {
    private _children: _SvgElementBase[] = [];
    private _attributes = {};
    private _parent: _SvgElementBase;
    private _style: _SvgStyleAttributes;
    private _ctx: _ISvgRenderContext;
    private _viewport: wijmo.Size;
    private _defRenderMode: _SvgRenderMode;
    private _curRenderMode: _SvgRenderMode;

    // at the moment the 'node' argument is used ONLY by the _SvgStyleElementImpl class.
    constructor(ctx: _ISvgRenderContext, node: SVGElement, defRenderMode = _SvgRenderMode.Render) {
        this._defRenderMode = defRenderMode;
        this._ctx = ctx;
    }

    //#region public

    public get children(): _SvgElementBase[] {
        return this._children;
    }

    public get ctx(): _ISvgRenderContext {
        return this._ctx;
    }

    public get parent(): _SvgElementBase {
        return this._parent;
    }
    public set parent(value: _SvgElementBase) {
        this._parent = value;
    }

    public get style(): _SvgStyleAttributes {
        if (!this._style) {
            this._style = new _SvgStyleAttributes(this);
        }

        return this._style;
    }

    public get viewport(): wijmo.Size {
        return this._viewport;
    }
    public set viewport(value: wijmo.Size) {
        this._viewport = value.clone();
    }

    public attr(name: string, value?: any): any {
        name = name.toLowerCase();

        if (arguments.length > 1) {
            this._attributes[name] = value;
        }

        return this._attributes[name];
    }

    public appendNode(node: _SvgElementBase): void {
        if (!node || (node === this)) {
            return;
        }

        if (node.parent !== this) {
            node.remove();

            this.children.push(node);
            node.parent = this;
        }
    }

    public copyAttributesFrom(el: _SvgElementBase, except?: string[]): void {
        if (!el) {
            return;
        }

        var fa = el._attributes,
            ta = this._attributes;

        for (var key in fa) {
            if (fa.hasOwnProperty(key) && (ta[key] == null) && (!except || (except.indexOf(key) < 0))) {
                ta[key] = fa[key];
            }
        }
    }

    public clone(): _SvgElementBase {
        var el = <_SvgElementBase>new (Function.prototype.bind.call(this.constructor, null /*this*/, this.ctx, null /*node*/));

        el.copyAttributesFrom(this);

        // clone children
        this._children.forEach((item) => {
            el.appendNode(item.clone());
        });

        return el;
    }

    public remove(): void {
        var p = this.parent;

        if (p) {
            for (var i = 0; i < p.children.length; i++) {
                if (p.children[i] === this) {
                    p.children.splice(i, 1);
                    break;
                }
            }

            this.parent = null;
        }
    }

    public clearAttr(name: string): void {
        delete this._attributes[name.toLowerCase()];
    }

    public render(viewPort: wijmo.Size, renderMode?: _SvgRenderMode): void {
        this._viewport = viewPort.clone();

        if ((this._curRenderMode = renderMode || this._defRenderMode) !== _SvgRenderMode.Ignore) {
            this._render();
        }
    }

    public get renderMode(): _SvgRenderMode {
        return this._curRenderMode;
    }

    //#endregion

    //#region protected

    protected _render(): void {
        this._renderContent();
    }

    protected _renderContent(): void {
        for (var i = 0; i < this._children.length; i++) {
            this._children[i].render(this.viewport, this.renderMode);
        }
    }

    //#endregion
}

export class _SvgClippableElementBase extends _SvgElementBase {
    private _clipPath: _SvgIdRefAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement, defRenderMode = _SvgRenderMode.Render) {
        super(ctx, node, defRenderMode);
        this._clipPath = new _SvgIdRefAttr(this, 'clip-path');
    }

    protected _render(): void {
        var clip: boolean,
            area = this.ctx.area;

        if (this._clipPath.val) {
            var clipPath = <_SvgClipPathElementImpl>this.ctx.getElement(this._clipPath.val);
            if (clip = !!(clipPath && (clipPath instanceof _SvgClipPathElementImpl))) {
                area.document.saveState();
                clipPath.render(this.viewport, _SvgRenderMode.Clip); // force rendering using a clipping mode
                area.paths.clip(this.style.clipRule.val);
            }
        }

        super._render();

        if (clip) {
            area.document.restoreState();
        }
    }
}

export class _SvgTransformableElementBase extends _SvgClippableElementBase {
    private _transform: _SvgTransformAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node);
        this._transform = new _SvgTransformAttr(this);
    }

    protected _render(): void {
        var transform = this._transform.hasVal && this.renderMode !== _SvgRenderMode.Clip; // clipping path cannot use tranformations

        if (transform) {
            this.ctx.area.document.saveState();
            this._transform.apply(this);
        }

        super._render();

        if (transform) {
            this.ctx.area.document.restoreState();
        }
    }
}

//#endregion Base elements



//#region Shape elements

export class _SvgShapeElementBase extends _SvgTransformableElementBase {
    protected _fill = true;
    protected _stroke = true;

    protected _renderContent(): void {
        //super._renderContent();
        this._draw();
        this.style.apply(this, this._fill, this._stroke);
    }

    protected _draw(): void {
        wijmo.assert(false, _Errors.AbstractMethod);
    }
}

export class _SvgCircleElementImpl extends _SvgShapeElementBase {
    protected _draw(): void {
        var r = new _SvgNumAttr(this, 'r', 0).val;

        if (r > 0) {
            var cx = new _SvgNumAttr(this, 'cx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
                cy = new _SvgNumAttr(this, 'cy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;

            this.ctx.area.paths.circle(cx, cy, r);
        }
    }
}

export class _SvgEllipseElementImpl extends _SvgShapeElementBase {
    protected _draw(): void {
        var rx = new _SvgNumAttr(this, 'rx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
            ry = new _SvgNumAttr(this, 'ry', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;

        if (rx > 0 && ry > 0) {
            var cx = new _SvgNumAttr(this, 'cx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
                cy = new _SvgNumAttr(this, 'cy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;

            this.ctx.area.paths.ellipse(cx, cy, rx, ry);
        }
    }
}

export class _SvgLineElementImpl extends _SvgShapeElementBase {
    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node);
        this._fill = false;
    }

    protected _draw(): void {
        var x1 = new _SvgNumAttr(this, 'x1', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
            y1 = new _SvgNumAttr(this, 'y1', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val,
            x2 = new _SvgNumAttr(this, 'x2', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
            y2 = new _SvgNumAttr(this, 'y2', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;

        this.ctx.area.paths
            .moveTo(x1, y1)
            .lineTo(x2, y2);
    }
}

export class _SvgPathElementImpl extends _SvgShapeElementBase {
    private _d: _SvgStrAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node);
        this._d = new _SvgStrAttr(this, 'd');
    }

    protected _renderContent() {
        var area = this.ctx.area;

        if (this.renderMode === _SvgRenderMode.Clip) {
            // the element is placed within the "clip-path" element, we can't use scale + saveState\ restoreState here
            // because it isolates clipping from an element that refers to the "clip-path" element.
            if (this._d.hasVal) {
                var path = _PdfSvgPathHelper.scale(this._d.val, 0.75); // px -> pt
                this.attr('d', path);
                this._d.reset();
            }
            super._renderContent();
        } else {
            area.document.saveState();
            area.scale(0.75); // px -> pt
            super._renderContent();
            area.document.restoreState();
        }
    }

    protected _draw(): void {
        if (this._d.hasVal) {
            this.ctx.area.paths.svgPath(this._d.val);
        }
    }
}

export class _SvgPolylineElementImpl extends _SvgShapeElementBase {
    protected _draw(): boolean {
        var _points = new _SvgPointsArrayAttr(this, 'points');

        if (_points.hasVal) {
            var points = _points.val,
                area = this.ctx.area;

            if (points.length > 1) {
                for (var i = 0; i < points.length; i++) {
                    if (i == 0) {
                        area.paths.moveTo(points[i].x, points[i].y);
                    } else {
                        area.paths.lineTo(points[i].x, points[i].y);
                    }
                }

                return true;
            }
        }

        return false;
    }
}

export class _SvgPolygonElementImpl extends _SvgPolylineElementImpl {
    protected _draw(): boolean {
        if (super._draw()) {
            this.ctx.area.paths.closePath();
            return true;
        }

        return false;
    }
}

export class _SvgRectElementImpl extends _SvgShapeElementBase {
    protected _draw(): void {
        var w = new _SvgNumAttr(this, 'width', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
            h = new _SvgNumAttr(this, 'height', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;

        if (w > 0 && h > 0) {
            var x = new _SvgNumAttr(this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
                y = new _SvgNumAttr(this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val,
                rx = Math.max(new _SvgNumAttr(this, 'rx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, 0),
                ry = Math.max(new _SvgNumAttr(this, 'ry', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val, 0),
                paths = this.ctx.area.paths;

            if (rx || ry) {
                rx = Math.min(rx || ry, w / 2);
                ry = Math.min(ry || rx, h / 2);

                // An updated version of the PdfKit's roundedRect method
                paths.moveTo(x + rx, y)
                paths.lineTo(x + w - rx, y)
                paths.quadraticCurveTo(x + w, y, x + w, y + ry);
                paths.lineTo(x + w, y + h - ry);
                paths.quadraticCurveTo(x + w, y + h, x + w - rx, y + h);
                paths.lineTo(x + rx, y + h);
                paths.quadraticCurveTo(x, y + h, x, y + h - ry);
                paths.lineTo(x, y + ry);
                paths.quadraticCurveTo(x, y, x + rx, y);
            } else {
                paths.rect(x, y, w, h);
            }
        }
    }
}

//#endregion Shape elements



//#region Other elements

export class _SvgClipPathElementImpl extends _SvgElementBase /*_TransformableElementBase*/ { // clipping path can not use tranformations
    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node, _SvgRenderMode.Ignore);
    }
}

export class _SvgDefsElementImpl extends _SvgClippableElementBase {
    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node, _SvgRenderMode.Ignore);
    }
}

export class _SvgGElementImpl extends _SvgTransformableElementBase {
}

export class _SvgLinearGradientElementImpl extends _SvgElementBase {
    private _x1: _SvgStrAttr;
    private _x2: _SvgStrAttr;
    private _y1: _SvgStrAttr;
    private _y2: _SvgStrAttr;
    private _gradientUnits: _SvgStrAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node, _SvgRenderMode.Ignore);

        // context-dependent values, read as strings
        this._x1 = new _SvgStrAttr(this, 'x1', '0%');
        this._x2 = new _SvgStrAttr(this, 'x2', '100%');
        this._y1 = new _SvgStrAttr(this, 'y1', '0%');
        this._y2 = new _SvgStrAttr(this, 'y2', '0%');

        this._gradientUnits = new _SvgStrAttr(this, 'gradientUnits', 'objectBoundingBox');
    }

    public toBrush(element: _SvgElementBase): PdfLinearGradientBrush {
        // move to base class?
        var rect = new wijmo.Rect(new _SvgNumAttr(element, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
            new _SvgNumAttr(element, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val,
            new _SvgNumAttr(element, 'width', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val,
            new _SvgNumAttr(element, 'height', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val),

            vp = (this._gradientUnits.val === 'objectBoundingBox')
                ? new wijmo.Size(rect.width, rect.height)
                : element.viewport.clone(); // not tested

        var x1 = _SvgNumAttr.parseValue(this._x1.val, _SvgAttrType.Number, vp, _SvgLengthContext.Width, _SvgNumConversion.Default),
            x2 = _SvgNumAttr.parseValue(this._x2.val, _SvgAttrType.Number, vp, _SvgLengthContext.Width, _SvgNumConversion.Default),
            y1 = _SvgNumAttr.parseValue(this._y1.val, _SvgAttrType.Number, vp, _SvgLengthContext.Height, _SvgNumConversion.Default),
            y2 = _SvgNumAttr.parseValue(this._y2.val, _SvgAttrType.Number, vp, _SvgLengthContext.Height, _SvgNumConversion.Default),
            stops: PdfGradientStop[] = [];

        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i] instanceof _SvgStopElementImpl) {
                var stop = <_SvgStopElementImpl>this.children[i];

                stops.push(new PdfGradientStop(
                    _SvgNumAttr.parseValue(stop.offset.val, _SvgAttrType.Number, vp, _SvgLengthContext.Other, _SvgNumConversion.Default),
                    stop.color.val,
                    stop.opacity.val));
            }
        }

        return new PdfLinearGradientBrush(rect.left + x1, rect.top + y1, rect.left + x2, rect.top + y2, stops);
    }
}

export class _SvgStopElementImpl extends _SvgElementBase {
    public color: _SvgColorAttr;
    public opacity: _SvgNumAttr;
    public offset: _SvgStrAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node, _SvgRenderMode.Ignore);

        this.color = new _SvgColorAttr(this, 'stop-color', 'black');
        this.opacity = new _SvgNumAttr(this, 'stop-opacity', 1, _SvgNumConversion.None, undefined, true);
        this.offset = new _SvgStrAttr(this, 'offset', '0'); // context-dependent value, read as string.
    }
}

export class _SvgImageElementImpl extends _SvgTransformableElementBase {
    private _x: _SvgNumAttr;
    private _y: _SvgNumAttr;
    private _width: _SvgNumAttr;
    private _height: _SvgNumAttr;
    private _href: _SvgHRefAttr;
    private _par: _SvgPreserveAspectRatioAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node);

        this._x = new _SvgNumAttr(this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._y = new _SvgNumAttr(this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._width = new _SvgNumAttr(this, 'width', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._height = new _SvgNumAttr(this, 'height', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._href = new _SvgHRefAttr(this, 'xlink:href');

        this._par = new _SvgPreserveAspectRatioAttr(this);
    }

    protected _renderContent(): void {
        var width = this._width.val,
            height = this._height.val;

        if (width > 0 && height > 0 && this._href.hasVal) {
            var url = _resolveUrlIfRelative(this._href.val, this.ctx.urlResolver);

            if (url) {
                this.ctx.area.document.saveState();

                if (this._x.val || this._y.val) {
                    this.ctx.area.translate(this._x.val, this._y.val);
                }

                this.viewport = new wijmo.Size(width, height);

                try {
                    if (this._href.val.match(/\.svg$/i)) { // need a better detection??
                        this._renderSvgImage(url);
                    } else {
                        this._renderRasterImage(url);
                    }
                } catch (ex) {
                }

                this.ctx.area.document.restoreState();
            }
        }
    }

    private _renderSvgImage(url: string): void {
        var xhrError: string,
            str = _XhrHelper.text(url, xhr => xhrError = xhr.statusText);

        if (xhrError) {
            throw xhrError;
        }

        var svg = new _SvgRenderer(str, this.ctx.area),
            r = svg.root;

        this.attr('viewBox', r.attr('viewBox'));
        r.clearAttr('viewBox');
        r.clearAttr('x');
        r.clearAttr('y');
        r.clearAttr('width');
        r.clearAttr('height');
        r.clearAttr('preserveAspectRatio');
        r.clearAttr('clip');
        r.clearAttr('overflow');

        this.ctx.area.paths.rect(0, 0, this.viewport.width, this.viewport.height).clip();

        var scale = new _SvgScaleAttributes(this); // uses fake 'viewBox' attribute, see above
        svg.render(scale.apply(this));
    }

    private _renderRasterImage(url: string): void {
        var image = this.ctx.area.openImage(_PdfImageHelper.getDataUri(url)),
            ar = this._par.val,
            w = this.viewport.width,
            h = this.viewport.height,
            opt: IPdfImageDrawSettings = {
                width: w,
                height: h,
                align: PdfImageHorizontalAlign.Left,
                vAlign: PdfImageVerticalAlign.Top
            };

        if (ar.align === 'none') {
            opt.stretchProportionally = false;
        } else {
            opt.stretchProportionally = true;

            if (ar.meet) { // meet
                if (ar.align.match(/^xMid/)) {
                    opt.align = PdfImageHorizontalAlign.Center;
                } else {
                    if (ar.align.match(/^xMax/)) {
                        opt.align = PdfImageHorizontalAlign.Right;
                    }
                }

                if (ar.align.match(/YMid$/)) {
                    opt.vAlign = PdfImageVerticalAlign.Center;
                } else {
                    if (ar.align.match(/YMax$/)) {
                        opt.vAlign = PdfImageVerticalAlign.Bottom;
                    }
                }
            } else { // slice
                let iw = pxToPt(image.width),
                    ih = pxToPt(image.height),
                    rw = w / iw,
                    rh = h / ih;

                if (rw > rh) {
                    opt.width = iw * rw;
                    opt.height = ih * rw;
                } else {
                    opt.width = iw * rh;
                    opt.height = ih * rh;
                }

                let tx = 0,
                    ty = 0;

                if (ar.align.match(/^xMid/)) {
                    tx = -(opt.width / 2) + w / 2;
                } else {
                    if (ar.align.match(/^xMax/)) {
                        tx = -opt.width + w;
                    }
                }

                if (ar.align.match(/YMid$/)) {
                    ty = -(opt.height / 2) + h / 2;
                } else {
                    if (ar.align.match(/YMax$/)) {
                        ty = -opt.height + h;
                    }
                }

                this.ctx.area.paths.rect(0, 0, this.viewport.width, this.viewport.height).clip();

                if (tx || ty) {
                    this.ctx.area.translate(tx, ty);
                }
            }
        }

        this.ctx.area.drawImage(image, 0, 0, opt);
    }
}

export class _SvgStyleElementImpl extends _SvgElementBase {
    constructor(ctx: _ISvgRenderContext, node: SVGStyleElement) {
        super(ctx, node, _SvgRenderMode.Ignore);

        if (node && (!node.type || node.type === 'text/css')) {
            var css = '';

            for (var i = 0; i < node.childNodes.length; i++) {
                css += node.childNodes[i].textContent;
            }

            css = _compressSpaces(css);
            css = css.replace(/\/\*([^*]|\*+[^*/])*\*+\//gm, ''); // remove comments

            var rules = css.match(/[^{}]*{[^}]*}/g);
            if (rules) {
                for (var i = 0; i < rules.length; i++) {
                    var rule = rules[i].match(/([^{}]*){([^}]*)}/);

                    if (rule) {
                        var selectors = rule[1].trim().split(','),
                            declaration = rule[2].trim();

                        if (selectors.length && declaration) {
                            selectors.forEach(selector => {
                                if (selector = selector.trim()) {
                                    this.ctx.registerCssRule(new _SvgCssRule(selector, declaration));
                                }
                            });
                        }
                    }
                }
            }
        }
    }
}

export class _SvgSvgElementImpl extends _SvgClippableElementBase {
    private _x: _SvgNumAttr;
    private _y: _SvgNumAttr;
    private _width: _SvgNumAttr;
    private _height: _SvgNumAttr;
    private _scale: _SvgScaleAttributes;
    private _overflow: _SvgStrAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node);

        this._x = new _SvgNumAttr(this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._y = new _SvgNumAttr(this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._width = new _SvgNumAttr(this, 'width', '100%', _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._height = new _SvgNumAttr(this, 'height', '100%', _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._scale = new _SvgScaleAttributes(this);
        this._overflow = new _SvgStrAttr(this, 'overflow', 'hidden');
    }

    public get width(): _SvgNumAttr {
        return this._width;
    }

    public get height(): _SvgNumAttr {
        return this._height;
    }

    protected _render(): void {
        var area = this.ctx.area;

        area.document.saveState();

        // pecentage values of these attributes are resolved using the old ("parent") viewport.
        var width = this._width.val,
            height = this._height.val,
            x = this._x.val,
            y = this._y.val;

        if (this.parent && (x || y)) {
            area.translate(x, y);
        }

        this.viewport = new wijmo.Size(width, height);

        // don't clip the outermost svg element
        if (/*this.parent && */this._overflow.val !== 'visible') {
            area.paths.rect(0, 0, width, height).clip();
        }

        // establish a new viewport using the viewBox and preserveAspectRatio attributes
        this.viewport = this._scale.apply(this);

        // debug
        //this.ctx.area.paths
        //	.rect(0, 0, this.viewPort.width, this.viewPort.height)
        //	.stroke(new PdfPen('lime', 2, new PdfDashPattern(5)));
        // debug

        // don't render if width = 0 or height = 0; viewBox.width = 0 or viewBox.height = 0
        if (this.viewport.width > 0 && this.viewport.height > 0) {
            super._render();
        }

        area.document.restoreState();
    }
}

export class _SvgSymbolElementImpl extends _SvgClippableElementBase {
    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node, _SvgRenderMode.Ignore);
    }
}

export class _SvgUseElementImpl extends _SvgElementBase {
    private _xlink: _SvgIdRefAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node);
        this._xlink = new _SvgIdRefAttr(this, 'xlink:href');
    }

    protected _render(): void {
        var ref: _SvgElementBase,
            foo: any;

        if (!this._xlink.hasVal || !(ref = this.ctx.getElement(this._xlink.val))) {
            return;
        }

        // ** https://www.w3.org/TR/SVG/struct.html#UseElement **

        var g = new _SvgGElementImpl(this.ctx, null);
        g.parent = this.parent;

        g.copyAttributesFrom(this, ['x', 'y', 'width', 'height', 'xlink:href']);

        // x, y
        if (this.attr('x') != null || this.attr('y') != null) {
            var trans = wijmo.format('translate({x},{y})', { x: this.attr('x') || 0, y: this.attr('y') || 0 });
            g.attr('transform', (foo = g.attr('transform')) ? foo + ' ' + trans : trans);
        }

        if (ref instanceof _SvgSymbolElementImpl) { // symbol
            // convert symbol to svg
            var svg = new _SvgSvgElementImpl(this.ctx, null);

            svg.copyAttributesFrom(ref);

            for (var i = 0; i < ref.children.length; i++) {
                svg.appendNode(ref.children[i].clone());
            }

            g.appendNode(svg);

            // width, height
            svg.attr('width', this.attr('width') || '100%');
            svg.attr('height', this.attr('height') || '100%');
        } else { // svg or any other element
            ref = ref.clone();
            g.appendNode(ref);

            if (ref instanceof _SvgSvgElementImpl) { // svg
                // width, height
                if ((foo = this.attr('width')) != null) {
                    ref.attr('width', foo);
                }

                if ((foo = this.attr('height')) != null) {
                    ref.attr('height', foo);
                }
            }
        }

        g.render(this.viewport, this.renderMode);
    }
}

//#endregion Other elements



//#region Text elements

export interface _TextDecorator {
    decoration: _SvgTextDecorationAttr;
    style: _SvgStyleAttributes;
}

export class _SvgTextElementImpl extends _SvgTransformableElementBase {
    private _x: _SvgNumAttr;
    private _y: _SvgNumAttr;
    private _dx: _SvgNumAttr;
    private _dy: _SvgNumAttr;
    private _textDecoration: _SvgTextDecorationAttr;

    constructor(ctx: _ISvgRenderContext, node: SVGElement) {
        super(ctx, node);

        this._x = new _SvgNumAttr(this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._y = new _SvgNumAttr(this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._dx = new _SvgNumAttr(this, 'dx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._dy = new _SvgNumAttr(this, 'dy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._textDecoration = new _SvgTextDecorationAttr(this);
    }

    protected _render() {
        if (this.renderMode === _SvgRenderMode.Render) { // render only; text elements cannot be used as a clipping path in PdfKit.
            super._render();
        }
    }

    protected _renderContent() {
        this._prepareNodes();

        var cx = this._x.val + this._dx.val,
            cy = this._y.val + this._dy.val,
            func = (node: _SvgTspanElementImpl, decorators: _TextDecorator[]): void => {
                if (node._x.hasVal) {
                    cx = node._x.val;
                }

                if (node._y.hasVal) {
                    cy = node._y.val;
                }

                cx += node._dx.val;
                cy += node._dy.val;

                if (node._text) {
                    node._cx = cx;
                    node._cy = cy;

                    node._setDecorators(decorators);

                    node.render(this.viewport, this.renderMode);

                    cx += this.ctx.area.measureText(node._text, node.style.font.toFont(), {
                        width: Infinity,
                        height: Infinity,
                        includeLastLineExternalLeading: false
                    }).size.width;
                } else {
                    for (var i = 0; i < node.children.length; i++) {
                        var dec = decorators.slice();
                        dec.push({ decoration: node._textDecoration, style: node.style });
                        func(<_SvgTspanElementImpl>node.children[i], dec);
                    }
                }
            };

        for (var i = 0; i < this.children.length; i++) {
            func(<_SvgTspanElementImpl>this.children[i], [{ decoration: this._textDecoration, style: this.style }]);
        }
    }

    private _prepareNodes() {
        var removeEmptyNodes = (node: _SvgTspanElementImpl | _SvgTextElementImpl): boolean => {
            for (var i = 0; i < node.children.length; i++) {
                var child = <_SvgTspanElementImpl>node.children[i];

                if (!child._text && removeEmptyNodes(child)) {
                    child.remove();
                }
            }

            return node.children.length === 0;
        };

        var list: _SvgTspanElementImpl[] = [];
        var buildTextList = (node: _SvgElementBase): void => {
            for (var i = 0; i < node.children.length; i++) {
                var child = <_SvgTspanElementImpl>node.children[i];

                if (child._text) {
                    list.push(<any>child);
                } else {
                    buildTextList(child);
                }
            }
        }

        removeEmptyNodes(this);
        buildTextList(this);

        for (var i = 0; i < list.length; i++) {
            var len = list.length;

            // remove whitespaces
            if (list[i]._text === ' ' && (
                (i === 0) || // leading
                (i === len - 1) || // trailing
                (i < len - 1 && list[i + 1]._text === ' '))) { // duplicate
                list[i].remove();
                list.splice(i, 1);
                i--;
            }
        }
    }
}

export class _SvgTspanElementImpl extends _SvgClippableElementBase {
    _text: string;
    _x: _SvgNumAttr;
    _y: _SvgNumAttr;
    _dx: _SvgNumAttr;
    _dy: _SvgNumAttr;
    _textDecoration = new _SvgTextDecorationAttr(this);
    _decorators: _TextDecorator[];

    _cx: number;
    _cy: number;

    constructor(ctx: _ISvgRenderContext, node: SVGElement, text?: string) {
        super(ctx, node);

        this._text = wijmo.asString(text);

        this._x = new _SvgNumAttr(this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._y = new _SvgNumAttr(this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._dx = new _SvgNumAttr(this, 'dx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        this._dy = new _SvgNumAttr(this, 'dy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        this._textDecoration = new _SvgTextDecorationAttr(this);
    }

    public clone(): _SvgElementBase {
        var clone = <_SvgTspanElementImpl>super.clone();
        clone._text = this._text;
        return clone;
    }

    _setDecorators(value: _TextDecorator[]) {
        this._decorators = value;
    }

    protected _renderContent(): void {
        if (this._text) {
            var opt: IPdfTextDrawSettings = {
                font: this.style.font.toFont(),
                width: Infinity,
                height: Infinity,
                lineBreak: false,
                fill: this.style.fill.color.val !== 'none',
                stroke: this.style.stroke.color.val !== 'none',
                _baseline: _PdfTextBaseline.Alphabetic
            };

            this._decorate();

            if (opt.fill || opt.stroke) {
                if (opt.fill) {
                    opt.brush = this.style.fill.toBrush(this);
                }

                if (opt.stroke) {
                    opt.pen = this.style.stroke.toPen(this);
                }

                this.ctx.area.drawText(this._text, this._cx, this._cy, opt);
            }
        }
    }

    private _decorate(): void {
        var area = this.ctx.area,
            hasValue = false;

        this._decorators.push({ decoration: this._textDecoration, style: this.style });

        for (var i = 0; i < this._decorators.length && !hasValue; i++) {
            hasValue = this._decorators[i].decoration.val != null;
        }

        if (hasValue) {
            area.document.saveState();

            var d = <_IPdfKitDocument>area.document._document,
                sz = area.measureText(this._text, this.style.font.toFont(), {
                    width: Infinity,
                    height: Infinity,
                    includeLastLineExternalLeading: false
                }).size,
                lineHeight = Math.max(d.currentFontSize() / 20, 0.1),
                ascender = d.currentFontAscender(),
                x = this._cx;

            for (var dec: _TextDecorator; dec = this._decorators.shift();) {
                var decVal = dec.decoration.val;

                if (decVal) {
                    for (var j = 0; j < decVal.length; j++) {
                        var y = this._cy - ascender; // baseline offset (Alphabetic)

                        switch (decVal[j]) {
                            case 'line-through':
                                y = y + sz.height / 2 - lineHeight / 2;
                                break;

                            case 'overline':
                                y = y - (d.currentFontBBox().ury - d.currentFontAscender());
                                break;

                            case 'underline':
                                y = y + sz.height - lineHeight * 1.5;
                                break;
                        }

                        area.paths.rect(x, y, sz.width, lineHeight);
                    }

                    dec.style.apply(this, true, true);
                }
            }

            area.document.restoreState();
        }
    }
}

//#endregion Text elements
    }
    


    module wijmo.pdf {
    















'use strict';

//#region Basic attributes

export enum _SvgNumConversion {
    Default = 1, // convert value according to its unit identifier
    None = 2, // no unit conversion, unit identifier is not allowed
    Px = 3 // always treat value as a 'px', unit identifier is not allowed
}

export enum _SvgLengthContext {
    Width = 1,
    Height = 2,
    Other = 3
}

export enum _SvgAttrType {
    Number = 1,
    String = 2
}

export class _SvgAttr<T> {
    public static parseValue(value: any, attrType: _SvgAttrType, viewPort: wijmo.Size, lCtx: _SvgLengthContext, numConv: _SvgNumConversion): any {
        if (value == null) {
            return value;
        }

        // some attributes can have both numerical and string values (font-size)
        if (attrType & _SvgAttrType.Number) {
            var numVal: number,
                unitType: string;

            if (typeof (value) === 'number') {
                numVal = value;
            } else {
                var match = value.match(/^([\+-]?[\d\.]+)(em|ex|px|pt|pc|cm|mm|in|%)?$/);
                if (match) {
                    numVal = parseFloat(match[1]);
                    unitType = match[2];
                }
            }

            if (numVal != null && numVal === numVal) {
                if (numConv !== _SvgNumConversion.Default) {
                    if (unitType) {
                        throw _Errors.InvalidFormat(value);
                    }

                    if (numConv === _SvgNumConversion.None) {
                        return numVal;
                    }
                }

                // convert to pt
                switch (unitType) {
                    case 'mm':
                        return numVal * 72 / 25.4

                    case 'cm':
                        return numVal * 72 / 2.54

                    case 'in':
                        return numVal * 72;

                    case 'pt':
                        return numVal;

                    case 'pc':
                        return numVal * 12;

                    case '%':
                        switch (lCtx) {
                            case _SvgLengthContext.Height:
                                numVal *= viewPort.height / 100;
                                break;

                            case _SvgLengthContext.Width:
                                numVal *= viewPort.width / 100;
                                break;

                            case _SvgLengthContext.Other:
                                numVal *= (Math.sqrt(viewPort.width * viewPort.width + viewPort.height * viewPort.height) / Math.sqrt(2)) / 100;
                                break;
                        }
                        return numVal;

                    case 'px':
                    default:
                        return numVal * 0.75;
                }
            }
        }

        if (attrType & _SvgAttrType.String) {
            return value + '';
        }

        throw _Errors.InvalidFormat(value);
    }

    private _owner: _SvgElementBase
    private _value: any;
    private _defValue: any;
    private _propName: string;
    private _propType: _SvgAttrType;
    private _searchValue: boolean;
    private _inheritable: boolean;
    private _pCtx: _SvgLengthContext;
    private _nc: _SvgNumConversion;

    constructor(owner: _SvgElementBase, propName: string, propType: _SvgAttrType, defValue = undefined, nc = _SvgNumConversion.Default, lCtx = _SvgLengthContext.Other, inheritable = false) {
        wijmo.assert(!!owner, _Errors.ValueCannotBeEmpty('owner'));
        wijmo.assert(!!propName, _Errors.ValueCannotBeEmpty('propName'));

        this._owner = owner;
        this._propName = propName;
        this._propType = propType;
        this._defValue = defValue;
        this._inheritable = inheritable;
        this._nc = nc;
        this._pCtx = lCtx;
        this._searchValue = true;
    }

    public get hasVal(): boolean {
        return this._val != null;
    }

    public get val(): T {
        if (this._val != null) {
            return this._val;
        } else {
            var value = wijmo.isFunction(this._defValue) ? (<Function>this._defValue).call(this, this._owner.ctx) : this._defValue;
            return this._parse(value);
        }
    }

    public set val(value: T) {
        this._searchValue = false;
        this._value = value;
    }

    protected get _val(): any {
        if (this._searchValue) {
            this._searchValue = false;

            var value;

            for (var p = this._owner; p; p = p.parent) {
                value = p.attr(this._propName);

                if (!(this._inheritable && (value == null || value == 'inherit'))) {
                    break;
                }
            }

            this._value = (value === 'inherit') ? undefined : this._parse(value);
        }

        return this._value;
    }

    public reset(): void {
        this._value = undefined;
        this._searchValue = true;
    }

    protected _parse(value: any, nc?: _SvgNumConversion): any {
        var value = _SvgAttr.parseValue(value, this._propType, this._owner.viewport, this._pCtx, nc || this._nc);
        return value;
    }
}

export class _SvgNumAttr extends _SvgAttr<number> {
    constructor(owner: _SvgElementBase, propName: string, defValue = undefined, nc = _SvgNumConversion.Default, pCtx = _SvgLengthContext.Other, inheritable?: boolean) {
        super(owner, propName, _SvgAttrType.Number, defValue, nc, pCtx, inheritable);
    }
}

export class _SvgStrAttr extends _SvgAttr<string> {
    constructor(owner: _SvgElementBase, propName: string, defValue?: any, inheritable?: boolean) {
        super(owner, propName, _SvgAttrType.String, defValue, undefined, undefined, inheritable);
    }
}

//#endregion Basic attributes

export class _SvgColorAttr extends _SvgAttr<string> {
    constructor(owner: _SvgElementBase, propName: string, defValue = undefined, inheritable = true) {
        super(owner, propName, _SvgAttrType.String, defValue, _SvgNumConversion.None, _SvgLengthContext.Other, inheritable);
    }

    public asHref(): string {
        var match = this.val.match(/url\((.+)\)/);
        if (match) {
            return match[1];
        }
        return null;
    }

    protected _parse(value: any): any {
        if (value === '' || value === 'null' || value === 'undefined') { // handle wijmo5 invalid values
            return undefined; // use default value then
        }

        return super._parse(value);
    }
}

export class _SvgDashArrayAttr extends _SvgAttr<number[]> {
    constructor(owner: _SvgElementBase) {
        super(owner, 'stroke-dasharray', _SvgAttrType.Number, undefined, _SvgNumConversion.Px, _SvgLengthContext.Other, true);
    }

    protected _parse(value: any): number[] {
        var res: number[],
            vals = (<string>value || '').trim().split(/[\s,]+/);

        if (vals.length) {
            res = [];

            try {
                for (var i = 0; i < vals.length; i++) {
                    if (vals[i]) {
                        res.push(super._parse(vals[i]));
                    }
                }
            } catch (ex) {
                return undefined;
            }

            return res.length ? res : undefined;
        }

        return res;
    }
}

export class _SvgFillRuleAttr extends _SvgAttr<PdfFillRule> {
    constructor(owner: _SvgElementBase, propName: string) {
        super(owner, propName, _SvgAttrType.String, PdfFillRule.NonZero, undefined, undefined, true);
    }

    protected _parse(value: string): PdfFillRule {
        if (wijmo.isNumber(value)) { // defValue
            return <any>value;
        } else {
            var match = (value || '').match(/(nonzero|evenodd)/i);
            if (match) {
                return match[1] === 'nonzero' ? PdfFillRule.NonZero : PdfFillRule.EvenOdd;
            }
            return undefined;
        }
    }
}

// supports attributes like attr="smth" and attr="url(smth)"
export class _SvgHRefAttr extends _SvgStrAttr {
    constructor(owner: _SvgElementBase, propName: string) {
        super(owner, propName);
    }

    protected _parse(value: string): string {
        value = (value || '').trim();

        // url(smth) => smth
        var match = value.match(/url\((.+)\)/);
        if (match) {
            value = match[1].trim();
        }

        // "smth" => smth
        value = value.replace(/["']/g, '');

        return value;
    }
}

// supports attributes like attr="#id" and attr="url(#id)"
export class _SvgIdRefAttr extends _SvgHRefAttr {
    protected _parse(value: string): string {
        value = super._parse(value);

        // #smth => smth
        if (value && value[0] === '#') {
            return value.substring(1);
        }

        return undefined;
    }
}

export class _SvgPointsArrayAttr extends _SvgAttr<wijmo.Point[]> {
    constructor(owner: _SvgElementBase, propName: string) {
        super(owner, propName, _SvgAttrType.Number, undefined, _SvgNumConversion.Px);
    }

    protected _parse(value: any): wijmo.Point[] {
        var res: wijmo.Point[],
            vals = (<string>value || '').trim().split(/[\s,]+/),
            len = Math.floor(vals.length / 2) * 2;

        if (len) {
            res = [];

            try {
                for (var i = 0; i < len - 1; i = i + 2) {
                    res.push(new wijmo.Point(super._parse(vals[i]), super._parse(vals[i + 1])));
                }
            }
            catch (ex) {
                return undefined;
            }
        }

        return res;
    }
}

export class _SvgTransformAttr extends _SvgAttr<((doc: PdfPageArea) => void)[]> {
    constructor(owner: _SvgElementBase) {
        super(owner, 'transform', _SvgAttrType.Number, undefined, _SvgNumConversion.None);
    }

    public apply(element: _SvgElementBase): void {
        var area = element.ctx.area;

        if (this.hasVal) {
            this.val.forEach((item) => {
                item(area);
            });
        }
    }

    protected _parse(value: any): ((doc: PdfPageArea) => void)[] {
        var res: ((doc: PdfPageArea) => void)[] = [],
            match = (<string>value || '').match(/((matrix|translate|scale|rotate|skewX|skewY)\([^\)]+\))+/g);

        if (match) {
            for (var i = 0; i < match.length; i++) {
                var item = match[i],
                    sgnr = item.match(/(\w+)\(([^\)]+)\)/),
                    args: number[] = [];

                try {
                    sgnr[2].trim().split(/[\s,]+/).forEach((numStr: string) => {
                        if (numStr) {
                            args.push(super._parse(numStr, _SvgNumConversion.None));
                        }
                    });
                } catch (ex) {
                    return undefined;
                }

                if (args.length) {
                    // replace closures with bind?
                    switch (sgnr[1]) {
                        case 'matrix':
                            res.push(((a: number, b: number, c: number, d: number, e: number, f: number) => {
                                return (area: PdfPageArea) => {
                                    area.transform(a, b, c, d, e, f);
                                }
                            })(args[0], args[1], args[2], args[3], super._parse(args[4], _SvgNumConversion.Px), super._parse(args[5], _SvgNumConversion.Px)));
                            break;

                        case 'translate':
                            res.push(((x: number, y: number) => {
                                return (area: PdfPageArea) => {
                                    area.translate(x, y);
                                }
                            })(super._parse(args[0], _SvgNumConversion.Px), super._parse(args[1] || 0, _SvgNumConversion.Px)));
                            break;

                        case 'scale':
                            res.push(((xFactor: number, yFactor: number) => {
                                return (area: PdfPageArea) => {
                                    area.scale(xFactor, yFactor);
                                }
                            })(args[0], args[1]));
                            break;

                        case 'rotate':
                            res.push(((angle: number, point: wijmo.Point) => {
                                return (area: PdfPageArea) => {
                                    area.rotate(angle, point);
                                }
                            })(args[0], new wijmo.Point(super._parse(args[1] || 0, _SvgNumConversion.Px), super._parse(args[2] || 0, _SvgNumConversion.Px))));
                            break;

                        case 'skewX':
                            res.push(((angle: number) => {
                                return (area: PdfPageArea) => {
                                    area.transform(1, 0, angle, 1, 0, 0);
                                }
                            })(Math.tan(args[0] * Math.PI / 180)));
                            break;

                        case 'skewY':
                            res.push(((angle: number) => {
                                return (area: PdfPageArea) => {
                                    area.transform(1, angle, 0, 1, 0, 0);
                                }
                            })(Math.tan(args[0] * Math.PI / 180)));
                            break;
                    }
                }
            }
        }

        return res.length ? res : undefined;
    }
}

export class _SvgTextDecorationAttr extends _SvgAttr<string[]> {
    constructor(owner: _SvgElementBase) {
        super(owner, 'text-decoration', _SvgAttrType.String, undefined, _SvgNumConversion.None);
    }

    protected _parse(value: any): string[] {
        var res: string[],
            vals = (<string>value || '').trim().toLowerCase().split(/[\s,]+/);

        if (vals.length) {
            res = [];

            for (var i = 0; i < vals.length; i++) {
                if (/line-through|overline|underline/.test(vals[i])) {
                    res.push(vals[i]);
                }
            }
        }

        return res && res.length ? res : undefined;
    }
}

export interface _ISvgViewBoxAttr {
    minX: number;
    minY: number;
    width: number;
    height: number;
}

export class _SvgViewboxAttr extends _SvgAttr<_ISvgViewBoxAttr> {
    constructor(owner: _SvgElementBase) {
        super(owner, 'viewBox', _SvgAttrType.Number, undefined, _SvgNumConversion.Px);
    }

    protected _parse(value: any): _ISvgViewBoxAttr {
        var res: _ISvgViewBoxAttr,
            vals = (<string>value || '').trim().split(/[\s,]+/);

        if (vals.length === 4) {
            res = {
                minX: super._parse(vals[0]),
                minY: super._parse(vals[1]),
                width: super._parse(vals[2]),
                height: super._parse(vals[3])
            };
        }

        return res;
    }
}

export interface _ISvgPreserveAspectRatioAttr {
    align: string;
    meet: boolean;
}

export class _SvgPreserveAspectRatioAttr extends _SvgAttr<_ISvgPreserveAspectRatioAttr> {
    constructor(owner: _SvgElementBase) {
        super(owner, 'preserveAspectRatio', _SvgAttrType.Number, 'xMidYMid meet');
    }

    protected _parse(value: any): _ISvgPreserveAspectRatioAttr {
        var res: _ISvgPreserveAspectRatioAttr;

        if (typeof (value) === 'string') {
            var vals = (<string>value).replace(/^defer\s+/, '').trim().split(/\s+/);  // skip 'defer', it is used only with images

            res = {
                align: vals[0],
                meet: !(vals[1] === 'slice')
            };
        } else {
            res = value;
        }

        return res;
    }
}

// combines both viewBox and preserveAspectRatio attributes
export class _SvgScaleAttributes {
    private _owner: _SvgElementBase;

    public aspect: _SvgPreserveAspectRatioAttr;
    public viewBox: _SvgViewboxAttr;

    constructor(owner: _SvgElementBase) {
        this._owner = owner;
        this.aspect = new _SvgPreserveAspectRatioAttr(this._owner);
        this.viewBox = new _SvgViewboxAttr(this._owner);
    }

    public apply(element: _SvgElementBase): wijmo.Size {
        var area = element.ctx.area,
            viewPort = element.viewport,
            viewBox = this.viewBox.val;

        if (viewPort && viewBox) {
            if (viewBox.width && viewBox.height) {
                var ar = this.aspect.val,
                    sx = viewPort.width / viewBox.width,
                    sy = viewPort.height / viewBox.height,
                    sMin = Math.min(sx, sy),
                    sMax = Math.max(sx, sy),
                    uniScaledWidth = viewBox.width * (ar.meet ? sMin : sMax),
                    uniScaledHeight = viewBox.height * (ar.meet ? sMin : sMax);

                if (ar.align === 'none') { // non-uniform scaling
                    area.scale(sx, sy);
                } else { // uniform scaling
                    var scale = ar.meet ? sMin : sMax,
                        tx = 0, ty = 0;

                    if (ar.align.match(/^xMid/) && (scale === sy)) {
                        tx = viewPort.width / 2 - uniScaledWidth / 2;
                    } else {
                        if (ar.align.match(/^xMax/) && (scale === sy)) {
                            tx = viewPort.width - uniScaledWidth;
                        }
                    }

                    if (ar.align.match(/YMid$/) && (scale === sx)) {
                        ty = viewPort.height / 2 - uniScaledHeight / 2;
                    } else {
                        if (ar.align.match(/YMax$/) && (scale === sx)) {
                            ty = viewPort.height - uniScaledHeight;
                        }
                    }

                    if (tx || ty) {
                        area.translate(tx, ty);
                    }

                    if (ar.meet) {
                        area.scale(sMin, sMin);
                    } else {
                        area.scale(sMax, sMax);
                    }

                    if (viewBox.minX || viewBox.minY) {
                        area.translate(-viewBox.minX, -viewBox.minY);
                    }
                }
            }

            //return new Size(viewPort.width / sx, viewPort.height / sy);
            return new wijmo.Size(viewBox.width, viewBox.height); // establish a new viewport.  
        }

        return viewPort;
    }
}

// combines all stroking attributes
export class _SvgStrokeAttributes {
    private _owner: _SvgElementBase;

    public color: _SvgColorAttr;
    public dashArray: _SvgDashArrayAttr;
    public dashOffset: _SvgNumAttr;
    public lineCap: _SvgStrAttr;
    public lineJoin: _SvgStrAttr;
    public miterLimit: _SvgNumAttr;
    public opacity: _SvgNumAttr;
    public width: _SvgNumAttr;

    constructor(owner: _SvgElementBase) {
        this._owner = owner;

        this.color = new _SvgColorAttr(this._owner, 'stroke', 'none');
        this.dashArray = new _SvgDashArrayAttr(this._owner);
        this.dashOffset = new _SvgNumAttr(this._owner, 'stroke-dashoffset', 0, _SvgNumConversion.Default, _SvgLengthContext.Other, true);
        this.lineCap = new _SvgStrAttr(this._owner, 'stroke-linecap', 'butt', true);
        this.lineJoin = new _SvgStrAttr(this._owner, 'stroke-linejoin', 'miter', true);
        this.miterLimit = new _SvgNumAttr(this._owner, 'stroke-miterlimit', 4, _SvgNumConversion.None, _SvgLengthContext.Other, true);
        this.opacity = new _SvgNumAttr(this._owner, 'stroke-opacity', 1, _SvgNumConversion.None, _SvgLengthContext.Other, true);
        this.width = new _SvgNumAttr(this._owner, 'stroke-width', 1, _SvgNumConversion.Default, _SvgLengthContext.Other, true);
    }

    public toPen(element?: _SvgElementBase): PdfPen {
        var color = new _SafeColor(this.color.val);

        if (this.opacity.hasVal) {
            color.a = this.opacity.val;
        }

        var pen = new PdfPen(color, this.width.val);

        if (this.dashArray.hasVal) {
            var dashes = this.dashArray.val;

            if (dashes.length) {
                pen.dashPattern = new PdfDashPattern(dashes[0],
                    dashes.length > 1 ? dashes[1] : undefined,
                    this.dashOffset.val);
            }
        }

        switch (this.lineCap.val) {
            case 'butt':
                pen.cap = PdfLineCapStyle.Butt;
                break;

            case 'round':
                pen.cap = PdfLineCapStyle.Round;
                break;

            case 'square':
                pen.cap = PdfLineCapStyle.Square;
                break;
        }

        switch (this.lineJoin.val) {
            case 'miter':
                pen.join = PdfLineJoinStyle.Miter;
                break;

            case 'round':
                pen.join = PdfLineJoinStyle.Round;
                break;

            case 'bevel':
                pen.join = PdfLineJoinStyle.Bevel;
                break;
        }

        pen.miterLimit = this.miterLimit.val;

        return pen;
    }
}

// combines all the filling attributes
export class _SvgFillAttributes {
    private _owner: _SvgElementBase;

    public color: _SvgColorAttr;
    public opacity: _SvgNumAttr;
    public rule: _SvgFillRuleAttr;

    constructor(owner: _SvgElementBase) {
        this._owner = owner;

        this.color = new _SvgColorAttr(this._owner, 'fill', 'black');
        this.opacity = new _SvgNumAttr(this._owner, 'fill-opacity', 1, _SvgNumConversion.None, undefined, true);
        this.rule = new _SvgFillRuleAttr(this._owner, 'fill-rule');
    }

    public toBrush(element?: _SvgElementBase): PdfBrush {
        let color: wijmo.Color;
        let href: string = this.color.asHref();

        if (href && element) {
            var gradient = element.ctx.getElement(href);
            if (gradient instanceof _SvgLinearGradientElementImpl) {
                return (<_SvgLinearGradientElementImpl>gradient).toBrush(element);
            }
        }

        color = new _SafeColor(this.color.val);
        if (this.opacity.hasVal) {
            color.a = this.opacity.val;
        }

        return new PdfSolidBrush(color);
    }
}

// combines all of the font attributes
export class _SvgFontAttributes {
    private _owner: _SvgElementBase;

    public family: _SvgStrAttr;
    public size: _SvgAttr<string | number>;
    public style: _SvgStrAttr;
    public weight: _SvgStrAttr;

    constructor(owner: _SvgElementBase) {
        this._owner = owner;
        this.family = new _SvgStrAttr(this._owner, 'font-family', (ctx: _ISvgRenderContext) => {
            var font = ctx.area.document._getFont();
            return font ? font.family : undefined;
        }, true);
        this.size = new _SvgAttr<string | number>(this._owner, 'font-size', _SvgAttrType.Number | _SvgAttrType.String, 'medium', undefined, _SvgLengthContext.Other, true);
        this.style = new _SvgStrAttr(this._owner, 'font-style', 'normal', true);
        this.weight = new _SvgStrAttr(this._owner, 'font-weight', 'normal', true);
    }

    public toFont(): PdfFont {
        var size = _asPt(this.size.val); // handle string values like 'small', 'medium' etc
        return new PdfFont(this.family.val, size, this.style.val, this.weight.val);
    }
}

export class _SvgStyleAttributes {
    private _owner: _SvgElementBase;
    public fill: _SvgFillAttributes;
    public font: _SvgFontAttributes;
    public stroke: _SvgStrokeAttributes;
    public clipRule: _SvgFillRuleAttr;

    constructor(owner: _SvgElementBase) {
        this._owner = owner;
        this.clipRule = new _SvgFillRuleAttr(this._owner, 'clip-rule');
        this.fill = new _SvgFillAttributes(this._owner);
        this.font = new _SvgFontAttributes(this._owner);
        this.stroke = new _SvgStrokeAttributes(this._owner);
    }

    public apply(element: _SvgElementBase, fill?: boolean, stroke?: boolean): void {
        var area = element.ctx.area;

        if (element.renderMode === _SvgRenderMode.Clip) {
            // Clipping has been moved to the _SvgClippableElementBase.render() method because in PDF the clipping operator
            // intersects (not unites) a given path with the current clipping path to create a new one, so we need to call
            // the clip() method only once to unite all the clipPath's nested elements.

            // area.paths.clip(this.clipRule.val);
        } else { // fill + stroke
            if (fill && stroke && this.fill.color.val !== 'none' && this.stroke.color.val !== 'none') {
                area.paths.fillAndStroke(this.fill.toBrush(element), this.stroke.toPen(element), this.fill.rule.val);
            } else {
                if (fill && (this.fill.color.val !== 'none')) {
                    area.paths.fill(this.fill.toBrush(element), this.fill.rule.val);
                } else {
                    if (stroke && (this.stroke.color.val !== 'none')) {
                        area.paths.stroke(this.stroke.toPen(element));
                    } else { // use transparent color then (we need to finish the current path anyway).
                        area.paths.stroke(wijmo.Color.fromRgba(0, 0, 0, 0));
                    }
                }
            }
        }
    }
}
    }
    