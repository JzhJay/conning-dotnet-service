import {AppIcon, BlueprintDialog, bp} from 'components'
import {OmdbTagForm} from 'components/system/ObjectCatalog/OmdbAdminPage/tabs/ManageTags/OmdbTagEditDialog';
import {ObjectChooser} from 'components/system/ObjectChooser/ObjectChooser';
import {NameInputField} from 'components/system/ObjectNameChecker/NameInputField';
import {BlueprintFileInput} from 'components/widgets/BlueprintFileInput';
import * as React from 'react';
import {FormattedMessage} from 'react-intl';
import type {ObjectNameCheckerResult} from 'stores'
import {routing, site, rsSimulationStore, Simulation, appIcons, repositoryStore, UserFile, simulationStore, user, i18n} from 'stores';
import {observer} from 'mobx-react'
import {observable, computed, action, makeObservable, runInAction} from 'mobx'

import * as dialogCss from '../../site/dialogs.css';
import * as css from './NewSimulationDialog.css';
import {Select} from '@blueprintjs/select';
import { ParameterTemplateOptions } from './ParameterTemplateOptions';
import {ITemplateFilter} from 'stores/rsSimulation/models';

type SimulationType = 'Repository' | 'GEMS' | 'FIRM';

interface MyProps {
	name?: string;
	type?: SimulationType;
	focusTarget?: 'name' | 'specification';
	showCreateFromFileButton?: boolean;
	onClosing?: () => void;
	userFile?: UserFile;
}

@observer
export class NewSimulationDialog extends React.Component<MyProps, {}> {
	static DEFAULT_TYPE: SimulationType = 'Repository';
	static DEFAULT_TARGET = 'name';

	static get PARAMETER_ITEMS(){
		return [
			{value: "template", label: i18n.intl.formatMessage({defaultMessage: "Template", description: "[NewSimulationDialog] a option for the parameter dropdown"})},
			{value: "dfa", label: "DFA"}
		];
	}

	@observable type: SimulationType;
	@observable updating: boolean;
	@observable errorMessage;
	@observable parametersSelection = "template";
	templateFilter: ITemplateFilter = null;

	nameInputFieldRef: NameInputField;
	@observable hasValidName: boolean;
	@observable nameInputFieldResult: ObjectNameCheckerResult;

	// for repository simulation
	@observable selectedUserFile: UserFile;

	// for gems/firm simulations
	@observable uploadedSpecFile: File;

	omdbTagFormRef;
	@observable allRequiredTagSelected;

	@observable collapseIsOpen: boolean;

	constructor(props) {
		super(props);
		makeObservable(this);
		this.type = this.props.type || NewSimulationDialog.DEFAULT_TYPE;
		this.updating = false;
		this.collapseIsOpen = false;

		if (this.props.type == "Repository" && this.props.userFile) {
			this.selectedUserFile = this.props.userFile;
		}
	}

	@computed get name() {
		return this.nameInputFieldResult?.input;
	}

	@computed get actionsDisabled() {
		return this.updating;
	}

	@computed get okDisabled() {
		return this.actionsDisabled || this.hasValidName !== true || this.allRequiredTagSelected !== true;
	}

	@computed get isRepositorySimulation() {
		return this.type == "Repository";
	}

	setSimulationType(type: SimulationType) {
		runInAction(() => {
			const currentName = this.name;
			if (!this.nameInputFieldResult || this.nameInputFieldResult.isAutoGenerated) {
				this.nameInputFieldRef.updateName("");
			}

			if (type == "FIRM")
				this.collapseIsOpen = true;

			if (type == "Repository") {
				this.uploadedSpecFile = null;
			} else {
				this.selectedUserFile = null;
			}
			this.type = type;
		});
	}

	@computed get enableTypeChooser() {
		return this.props.type == null && user.isESGLicensed;
	}

	@action fileIdUpdate(userFile: UserFile) {

		this.selectedUserFile = userFile;

		if(userFile && this.nameInputFieldResult.isAutoGenerated) {
			this.nameInputFieldRef.updateName(userFile.name).then( (result) => {
				result.isAutoGenerated = true
				this.nameInputFieldResult = result;
			});
		}
	}

	@action onFileOpenInput_Change = (fileList: FileList) => {

		const uploadedSpecFile = fileList?.length == 1 ? fileList[0] : null;

		if (!uploadedSpecFile) {
			this.uploadedSpecFile = null;
			this.errorMessage = null;
			return;
		}

		this.uploadedSpecFile = uploadedSpecFile;

		this.errorMessage =
			!uploadedSpecFile.name.toLowerCase().endsWith('.json')
			? i18n.intl.formatMessage({defaultMessage: 'File must be JSON', description: "[NewSimulationDialog] error message - the file user selected must be a .JSON file"})
			: null;

		if(!this.errorMessage && this.nameInputFieldResult.isAutoGenerated) {
			const name = uploadedSpecFile.name.replace(/.json$/i, '').replace(/_inputs$/, '');
			this.nameInputFieldRef.updateName(name).then( (result) => {
				result.isAutoGenerated = true
				this.nameInputFieldResult = result;
			});
		}
	}

	@action updateParametersSelection = (item) => {
		this.parametersSelection = item.value;
		this.templateFilter = null;
	}

	saveTemplateFilter = (templateFilter) => {
		this.templateFilter = templateFilter;
	}

	@computed get newObjectDetailsWithTypeSwitcher() {
		const {updating} = this;

		return <>
			<bp.Label tabIndex={0} className={css.typeField}>
				{user.isRSSimulationLicensed && <bp.Switch disabled={updating} checked={this.type == "GEMS"} label={Simulation.translateSourceType(Simulation.SOURCE_TYPE.GEMS)} onChange={() => this.setSimulationType("GEMS")}/>}
				{user.isFIRMLicensed && <bp.Switch disabled={updating} checked={this.type == "FIRM"} label={Simulation.translateSourceType(Simulation.SOURCE_TYPE.FIRM)} onChange={() => this.setSimulationType("FIRM")}/>}
				<bp.Switch disabled={updating} checked={this.type == "Repository"} label={Simulation.translateSourceType(Simulation.SOURCE_TYPE.REPOSITORY)} onChange={() => this.setSimulationType("Repository")}/>
			</bp.Label>

			<br />
			<div>
				<bp.Button
					intent={bp.Intent.PRIMARY}
					minimal={true}
					onClick={action(() => this.collapseIsOpen = !this.collapseIsOpen)}
					icon={this.collapseIsOpen ? "chevron-down" : "chevron-right" }
					text={i18n.intl.formatMessage({defaultMessage: "Additional Settings", description: "[NewSimulationDialog] a button to show/hide some additional options for create simulation"})}
				/>
			</div>

			<bp.Collapse keepChildrenMounted={true} isOpen={this.collapseIsOpen}>
				<bp.Callout>
					{this.newObjectDetails}
				</bp.Callout>
			</bp.Collapse>
		</>
	}

	@computed get newObjectDetails() {
		const {actionsDisabled} = this;
		const focusTarget = this.props.name ? this.props.name : NewSimulationDialog.DEFAULT_TARGET;

		return <>
			<bp.Label tabIndex={1} >
				<span className={classNames(dialogCss.fieldLabelAlignTop, dialogCss.requiredField)}>{i18n.common.WORDS.NAME}</span>
				<NameInputField
					objectType={Simulation.ObjectType}
					value={this.props.name}
					autoFocus={focusTarget == 'name'}
					disabled={actionsDisabled}
					ref={r => this.nameInputFieldRef = r}
					onChange={action((e, component) => this.hasValidName = component.hasValidName)}
					onUpdateResult={action((result, component) => {
						this.hasValidName = component.hasValidName;
						this.nameInputFieldResult = result;
					})}
				/>
			</bp.Label>

			{this.isRepositorySimulation && <bp.Label tabIndex={2}>
				<span>{i18n.common.WORDS.FILE}</span>
				<ObjectChooser<UserFile>
					objectType={UserFile}
					selections={this.selectedUserFile ? [this.selectedUserFile] : []}
					chooseItemFilters={{status: ["Complete"]}}
					onSave={(selected) => this.fileIdUpdate(selected[0])}
					launcherClassName={classNames(bp.Classes.INPUT, {[bp.Classes.DISABLED]: actionsDisabled})}
					disabled={actionsDisabled}
				/>
			</bp.Label>}

			{!this.isRepositorySimulation && <>
				{this.type !== 'FIRM' &&
				<bp.Label tabIndex={2} className={dialogCss.definitionFileField}>
					<span><FormattedMessage defaultMessage={"Specification (.JSON)"} description={"[NewSimulationDialog] input field name - Specification File"} /></span>
					<BlueprintFileInput
						autoFocus={focusTarget == 'specification'}
						disabled={actionsDisabled}
						accept={"application/json"}
						onfileListChange={this.onFileOpenInput_Change}
					/>
				</bp.Label>}
			</>}

			<OmdbTagForm
				objectType={"Simulation"}
				ref={ r => this.omdbTagFormRef = r}
				selectionStatusUpdate={action((status) => this.allRequiredTagSelected = status)}
				disabled={actionsDisabled}
			>{(tag, selector,index) => {
				return <bp.Label tabIndex={(this.isRepositorySimulation || !user.isFeatureEnabled("gemsDefinitionFile") ? 3 : 4)+index} key={`${tag.name}_index`}>
					<div className={dialogCss.requiredField}>{tag.name}</div>
					{selector}
				</bp.Label>
			}}</OmdbTagForm>

			{this.type === "FIRM" && <div className={classNames("bp3-label", css.parameters)}> {/*Using the Label component here screws up the select interaction however we still use .bp3-label to get the correct formatting*/}
				<span className={classNames(dialogCss.fieldLabelAlignTop, dialogCss.requiredField)}><FormattedMessage defaultMessage={"Parameters Basis"} description={"[NewSimulationDialog] input field name - Parameters Basis"} /></span>

				<Select
					activeItem={this.parametersSelection}
					items={NewSimulationDialog.PARAMETER_ITEMS}
					itemRenderer={(item, {handleClick, modifiers}) => {
						//this.parametersSelection
						//updateParametersSelection
						return <bp.MenuItem key={item.value} text={item.label} onClick={() => this.updateParametersSelection(item)}/>
					}}
					onItemSelect={this.updateParametersSelection}
					popoverProps={{ minimal: true, popoverClassName: css.highchartsPopoverToolbarSelect }}
					filterable={false}
				>
					<bp.Button
						text={NewSimulationDialog.PARAMETER_ITEMS.find(item => this.parametersSelection == item.value).label}
						rightIcon="chevron-down" />
				</Select>
			</div>}

			{this.parametersSelection == "template" && this.type === "FIRM" && <ParameterTemplateOptions saveTemplateFilter={this.saveTemplateFilter}/>}
			{((user.isFeatureEnabled("gemsDefinitionFile") && this.type == "GEMS") || this.parametersSelection == "dfa") && <>
				<bp.Label tabIndex={3}>
					<span className={classNames({[dialogCss.requiredField]: this.type === "FIRM"})}><FormattedMessage defaultMessage={"Definition File (.DFA)"} description={"[Common] input field name - Definition File"} /></span>
					<ObjectChooser<UserFile>
						objectType={UserFile}
						selections={this.selectedUserFile ? [this.selectedUserFile] : []}
						chooseItemFilters={{status:["Complete"], type:["DFA"] }}
						onSave={(selected) => this.fileIdUpdate(selected[0])}
						launcherClassName={classNames(bp.Classes.INPUT, {[bp.Classes.DISABLED]: actionsDisabled})}
						disabled={actionsDisabled}
					/>
				</bp.Label></>}
		</>;
	}

	render() {
		const { errorMessage, updating, okDisabled, enableTypeChooser} = this;

		return (
			<BlueprintDialog
				className={classNames(css.root, dialogCss.newObjectDialog)}
				icon={<AppIcon icon={appIcons.cards.simulation.cardIcon} />}
				title={user.enableGEMSOnlyMode ?
				       <FormattedMessage defaultMessage={"Create Simulation"} description={"[NewSimulationDialog] title on the dialog if its on GEMS only mode"} />:
				       <FormattedMessage defaultMessage={"Select Simulation Data Source"} description={"[NewSimulationDialog] default title on the dialog"} />}

				canCancel={!updating}

				okDisabled={okDisabled}
				ok={this.onOK}
				message={updating ? <FormattedMessage defaultMessage={"Creating Simulation..."} description={"[NewSimulationDialog] message when system start creating a new simulation object"} /> : errorMessage}

				error={errorMessage != null}
			>
				{enableTypeChooser && this.newObjectDetailsWithTypeSwitcher}
				{!enableTypeChooser && this.newObjectDetails}
			</BlueprintDialog>);
	}



	@action onOK = async () => {
		const {okDisabled} = this;
		if (okDisabled) {
			throw new Error("Cannot call ok() when disabled")
		}

		try {
			site.busy = true;
			this.updating = true;

			let tagValues = this.omdbTagFormRef ? this.omdbTagFormRef.getSelectedTagValues() : null;
			if (!this.isRepositorySimulation) {
				await this.createRSSimulation(tagValues, this.templateFilter);
			} else {
				await this.createSimulation(tagValues);
			}

			this.updating = false;
		}
		finally {
			site.busy = false;
		}

		return 'OK';
	}

	createSimulation = async (tagValues: string[]) => {
		const {name, selectedUserFile} = this;
		if (this.enableTypeChooser && ( !this.collapseIsOpen || !selectedUserFile?._id)) {
			routing.push(simulationStore.clientRoute + "?createRepository=true" +
				(!this.nameInputFieldResult.isAutoGenerated ? `&repositoryName=${name}` : '') +
				(tagValues.length > 0 ? `&tagValues=${tagValues}` : ''));
			return 'ok';
		}

		await repositoryStore.createNewRespository(selectedUserFile?._id, name, tagValues);
	}

	createRSSimulation = async (tagValues: string[], templateFilter?: ITemplateFilter) => {
		const {name, uploadedSpecFile, selectedUserFile} = this;

		if (uploadedSpecFile) {
			const promise = new Promise<void>((res, rej) => {
				const reader     = new FileReader();
				reader.onloadend = async loaded => {
					try {
						const definitionJson = JSON.parse(loaded.target['result'] as string);

						// Load the simulation definition
						rsSimulationStore.createNewObject(this.type, name, definitionJson, selectedUserFile?.id, tagValues);
						res()
					} catch (err) {
						this.errorMessage = err.message;
						rej(err);
					}
				}

				reader.onerror = (error: any) => {
					this.errorMessage = error.message;
					site.raiseError(error.error);
				}

				reader.readAsText(uploadedSpecFile);
			});

			await promise;
		} else {
			// Create new object but avoid waiting for it to be fully created so the dialog can be dismissed.
			rsSimulationStore.createNewObject(this.type, name, null, selectedUserFile?.id, tagValues, templateFilter);
		}
	}
}

