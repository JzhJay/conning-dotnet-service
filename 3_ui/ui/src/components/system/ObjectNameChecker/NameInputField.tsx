import {bp} from 'components';
import {action, computed, makeObservable, observable, runInAction} from 'mobx';
import {observer} from 'mobx-react';
import * as React from 'react';
import {ObjectNameChecker} from 'stores';
import type {ObjectNameCheckerConfig, ObjectNameCheckerResult} from 'stores';

import * as css from './NameInputField.css';

interface NameInputFieldProps {
	objectType: string;
	value?: string;
	className?: string;
	tabIndex?: number;
	disabled?: boolean;
	autoFocus?: boolean;
	onUpdateResult?: (checkResult: ObjectNameCheckerResult, component: NameInputField) => void;
	onChange?: (e: React.BaseSyntheticEvent, component: NameInputField) => void;
	onBlur?: (e: React.BaseSyntheticEvent, component: NameInputField) => void;
	helpText?: (
		result: ObjectNameCheckerResult,
		applySuggestNameElementCreator: (suggestNameWithoutPath:string, suggestName:string) => React.ReactElement
	) => React.ReactElement;

	canDuplicate?: boolean;
	objectNameChecker?: ObjectNameChecker;
	objectNameCheckerConfig?: ObjectNameCheckerConfig;
	excludeCheckObjectId?: string;
}

@observer
export class NameInputField extends React.Component<NameInputFieldProps, any> {

	_id = uuid.v4();
	inputRef: HTMLInputElement;

	objectNameChecker: ObjectNameChecker;
	canDuplicate: boolean;

	@observable initialized: boolean;
	@observable loading: boolean;

	@observable valueUnchecked: boolean;
	@observable checkResult: ObjectNameCheckerResult;

	constructor(props) {
		super(props);
		makeObservable(this);

		this.objectNameChecker = this.props.objectNameChecker || new ObjectNameChecker(this.props.objectNameCheckerConfig);
		this.updateName(this.props.value).finally(() => {
			this.objectNameChecker.canDuplicated(this.props.objectType, this.props.canDuplicate)
				.then( r => this.canDuplicate = r )
				.finally(action(() => { this.initialized = true; }))
		});
	}

	componentDidMount() {
		$(this.inputRef).keydown((e) => {
			if (e.keyCode == 13) { //stop ENTER event, only call blur event.
				this.onBlur(e as any)
				e.stopPropagation();
			}
		})
	}

	updateName = async (name: string): Promise<ObjectNameCheckerResult> => {
		if (this.checkResult && this.checkResult.input === name) {
			return this.checkResult;
		}

		this.loading = true;
		const checkResult: ObjectNameCheckerResult = await this.objectNameChecker.isDuplicated(this.props.objectType, name, this.props.excludeCheckObjectId, this.props.canDuplicate)
			.finally(action(() => this.loading = false));

		if (this.inputRef && this.inputRef.value != checkResult.input) {
			this.inputRef.value = checkResult.input;
		}

		runInAction( () => {
			this.valueUnchecked = false;
			this.checkResult = checkResult;
		});

		this.props.onUpdateResult && this.props.onUpdateResult(checkResult, this)

		return checkResult;

	}

	@computed get name() {
		return this.checkResult?.input;
	}

	set name(newName) {
		this.updateName(newName);
	}

	@computed get hasValidName(): boolean {
		return this.valueUnchecked !== true && this.checkResult?.isDuplicated === false;
	}

	@computed get disabled() {
		return !this.initialized || this.props.disabled;
	}

	@computed get helperText() {
		const result = this.checkResult;
		if (result?.isDuplicated === true) {
			const applySuggestNameElementCreator = (suggestNameWithoutPath, suggestName) => {
				return <bp.Tooltip content={"Click to apply"}>
					<span  onClick={() => this.applySuggestion(suggestNameWithoutPath, suggestName)} style={{color: `${bp.Colors.BLUE3}`, cursor: 'pointer'}}>
						{suggestNameWithoutPath}
					</span>
				</bp.Tooltip>
			}
			let rtnMessage;
			if (this.props.helpText)
				rtnMessage = this.props.helpText(result, applySuggestNameElementCreator);

			if (!rtnMessage) {
				const applySuggestName = applySuggestNameElementCreator(result.suggestNameWithoutPath, result.suggestName);
				rtnMessage = <>An object with the name "{result.inputWithoutPath}" already exists. Would you like to use "{applySuggestName}" instead?</>
			}
			return rtnMessage;
		} else {
			return null;
		}
	}

	applySuggestion = (suggestNameWithoutPath, suggestName) => {
		let checkResult = {
			isAutoGenerated: this.checkResult.isAutoGenerated,
			isCaseInsensitive: this.checkResult.isCaseInsensitive,
			isDuplicated: false,
			input: suggestName,
			inputWithoutPath: suggestNameWithoutPath
		}

		this.inputRef.value = checkResult.input;

		runInAction( () => {
			this.valueUnchecked = false;
			this.checkResult = checkResult;
		});

		this.props.onUpdateResult && this.props.onUpdateResult(checkResult, this)
	}

	@action onChange = (e: React.BaseSyntheticEvent) => {
		const newName = e.target.value;

		if (this.canDuplicate === true || this.objectNameChecker.canUsingCache(this.props.objectType, newName)) {
			this.updateName(newName).then(() => {
				this.props.onChange && this.props.onChange(e, this);
			})
		} else {
			this.valueUnchecked = e.target.value != this.checkResult?.input;
			this.props.onChange && this.props.onChange(e, this);
		}
	}

	@action onBlur = (e: React.BaseSyntheticEvent) => {
		this.updateName(e.target.value).then(() => {
			this.props.onBlur && this.props.onBlur(e, this);
		});
	}

	render() {

		const {className, tabIndex, autoFocus, value} = this.props;

		return <bp.FormGroup
			className={classNames(css.root,className)}
			helperText={this.helperText}
			labelFor={this._id}
		>
			<bp.InputGroup
				inputRef={r => this.inputRef = r}
				id={this._id}
				tabIndex={tabIndex}
				autoFocus={autoFocus !== false}
				placeholder={"Name"}
				disabled={this.disabled}
				defaultValue={value}
				onChange={this.onChange}
				onBlur={this.onBlur}
				rightElement={this.loading ? <bp.Spinner size={bp.SpinnerSize.SMALL} /> : null}
			/>
		</bp.FormGroup>;
	}
}