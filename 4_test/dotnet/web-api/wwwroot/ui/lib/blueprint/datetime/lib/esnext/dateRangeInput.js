var DateRangeInput_1;import{__decorate}from"tslib";import classNames from"classnames";import*as React from"react";import DayPicker from"react-day-picker";import{polyfill}from"react-lifecycles-compat";import{AbstractPureComponent2,Boundary,Classes,DISPLAYNAME_PREFIX,InputGroup,Intent,Keys,Popover,Position,refHandler,setRef}from"@blueprintjs/core";import{areSameTime,isDateValid,isDayInRange}from"./common/dateUtils";import*as Errors from"./common/errors";import{getFormattedDateString}from"./dateFormat";import{getDefaultMaxDate,getDefaultMinDate}from"./datePickerCore";import{DateRangePicker}from"./dateRangePicker";let DateRangeInput=DateRangeInput_1=class extends AbstractPureComponent2{constructor(t,e){super(t,e),this.startInputElement=null,this.endInputElement=null,this.handleStartInputRef=refHandler(this,"startInputElement",this.props.startInputProps?.inputRef),this.handleEndInputRef=refHandler(this,"endInputElement",this.props.endInputProps?.inputRef),this.renderInputGroup=t=>{const e=this.getInputProps(t),s=t===Boundary.START?this.handleStartInputEvent:this.handleEndInputEvent;return React.createElement(InputGroup,Object.assign({autoComplete:"off",disabled:e.disabled||this.props.disabled},e,{intent:this.isInputInErrorState(t)?Intent.DANGER:e.intent,inputRef:this.getInputRef(t),onBlur:s,onChange:s,onClick:s,onFocus:s,onKeyDown:s,onMouseDown:s,placeholder:this.getInputPlaceholderString(t),value:this.getInputDisplayString(t)}))},this.handleDateRangePickerChange=(t,e=!1)=>{if(!this.state.isOpen)return;const[s,n]=t;let a,r,i,o,u,l=!0;null==s?(null==this.props.timePrecision?(a=!0,r=!1):(a=!1,r=!1,u=Boundary.START),i=null):null==n?(null==this.props.timePrecision?(a=!1,r=!0):(a=!1,r=!1,u=Boundary.END),o=null):this.props.closeOnSelection?(l=this.getIsOpenValueWhenDateChanges(s,n),a=!1,null==this.props.timePrecision&&e?r=!0:(r=!1,u=Boundary.END)):this.state.lastFocusedField===Boundary.START?null==this.props.timePrecision?(a=!0,r=!1):(a=!1,r=!1,u=Boundary.START):null==this.props.timePrecision?(a=!1,r=!0):(a=!1,r=!1,u=Boundary.END);const p={boundaryToModify:u,endHoverString:o,endInputString:this.formatDate(n),isEndInputFocused:r,isOpen:l,isStartInputFocused:a,startHoverString:i,startInputString:this.formatDate(s),wasLastFocusChangeDueToHover:!1};this.isControlled()?this.setState(p):this.setState({...p,selectedEnd:n,selectedStart:s}),this.props.onChange?.(t)},this.handleShortcutChange=(t,e)=>{this.setState({selectedShortcutIndex:e})},this.handleDateRangePickerHoverChange=(t,e,s)=>{if(this.state.isOpen)if(null==t){const t=this.state.boundaryToModify===Boundary.END;this.setState({endHoverString:null,isEndInputFocused:t,isStartInputFocused:!t,lastFocusedField:this.state.boundaryToModify,startHoverString:null})}else{const[e,n]=t,a=null!=s?s===Boundary.START:this.state.isStartInputFocused,r=null!=s?s===Boundary.END:this.state.isEndInputFocused;this.setState({endHoverString:this.formatDate(n),isEndInputFocused:r,isStartInputFocused:a,lastFocusedField:a?Boundary.START:Boundary.END,shouldSelectAfterUpdate:this.props.selectAllOnFocus,startHoverString:this.formatDate(e),wasLastFocusChangeDueToHover:!0})}},this.handleStartInputEvent=t=>{this.handleInputEvent(t,Boundary.START)},this.handleEndInputEvent=t=>{this.handleInputEvent(t,Boundary.END)},this.handleInputEvent=(t,e)=>{const s=this.getInputProps(e);switch(t.type){case"blur":this.handleInputBlur(t,e),s.onBlur?.(t);break;case"change":this.handleInputChange(t,e),s.onChange?.(t);break;case"click":this.handleInputClick(t),s.onClick?.(t);break;case"focus":this.handleInputFocus(t,e),s.onFocus?.(t);break;case"keydown":this.handleInputKeyDown(t),s.onKeyDown?.(t);break;case"mousedown":this.handleInputMouseDown(),s.onMouseDown?.(t)}},this.handleInputKeyDown=t=>{const e=t.which===Keys.TAB,s=t.which===Keys.ENTER,n=t.shiftKey,{selectedStart:a,selectedEnd:r}=this.state,i=this.state.lastFocusedField===Boundary.START,o=this.state.lastFocusedField===Boundary.END;if(e){let e,s,a=!0;i&&!n?(s=!1,e=!0,t.preventDefault()):o&&n?(s=!0,e=!1,t.preventDefault()):(s=!1,e=!1,a=!1),this.setState({isEndInputFocused:e,isOpen:a,isStartInputFocused:s,wasLastFocusChangeDueToHover:!1})}else if(i&&s){const t=this.parseDate(this.state.startInputString);this.handleDateRangePickerChange([t,r],!0)}else{if(!o||!s)return;{const t=this.parseDate(this.state.endInputString);this.handleDateRangePickerChange([a,t],!0)}}},this.handleInputMouseDown=()=>{this.setState({wasLastFocusChangeDueToHover:!1})},this.handleInputClick=t=>{t.stopPropagation()},this.handleInputFocus=(t,e)=>{const{keys:s,values:n}=this.getStateKeysAndValuesForBoundary(e),a=getFormattedDateString(n.selectedValue,this.props,!0),r=this.state.wasLastFocusChangeDueToHover?this.state.boundaryToModify:e;this.setState({[s.inputString]:a,[s.isInputFocused]:!0,boundaryToModify:r,isOpen:!0,lastFocusedField:e,shouldSelectAfterUpdate:this.props.selectAllOnFocus,wasLastFocusChangeDueToHover:!1})},this.handleInputBlur=(t,e)=>{const{keys:s,values:n}=this.getStateKeysAndValuesForBoundary(e),a=this.parseDate(n.inputString),r=this.isControlled();let i={[s.isInputFocused]:!1,shouldSelectAfterUpdate:!1};this.isInputEmpty(n.inputString)?i=r?{...i,[s.inputString]:getFormattedDateString(n.controlledValue,this.props)}:{...i,[s.inputString]:null,[s.selectedValue]:null}:this.isNextDateRangeValid(a,e)||(r||(i={...i,[s.inputString]:null,[s.selectedValue]:a}),this.props.onError?.(this.getDateRangeForCallback(a,e))),this.setState(i)},this.handleInputChange=(t,e)=>{const s=t.target.value,{keys:n}=this.getStateKeysAndValuesForBoundary(e),a=this.parseDate(s),r=this.isControlled();let i={shouldSelectAfterUpdate:!1};if(0===s.length){const t={...i,[n.inputString]:""};i=r?t:{...t,[n.selectedValue]:null},this.props.onChange?.(this.getDateRangeForCallback(null,e))}else if(this.isDateValidAndInRange(a)){const t={...i,[n.hoverString]:null,[n.inputString]:s};i=r?t:{...t,[n.selectedValue]:a},this.isNextDateRangeValid(a,e)&&this.props.onChange?.(this.getDateRangeForCallback(a,e))}else i={...i,[n.inputString]:s,[n.hoverString]:null};this.setState(i)},this.handlePopoverClose=t=>{this.setState({isOpen:!1}),this.props.popoverProps.onClose?.(t)},this.getIsOpenValueWhenDateChanges=(t,e)=>{if(this.props.closeOnSelection){if(null==this.props.timePrecision)return!1;const s=new Date((new Date).setHours(0,0,0,0)),[n,a]=this.getSelectedRange([s,s]);return!0!==areSameTime(n,t)||!0!==areSameTime(a,e)}return!0},this.getInitialRange=(t=this.props)=>{const{defaultValue:e,value:s}=t;return null!=s?s:null!=e?e:[null,null]},this.getSelectedRange=t=>{let e,s;return this.isControlled()?[e,s]=this.props.value:(e=this.state.selectedStart,s=this.state.selectedEnd),[e,this.doBoundaryDatesOverlap(e,Boundary.START)?void 0:s].map(((e,s)=>{const n=null!=t?t[s]:void 0;return this.isDateValidAndInRange(e)?e:n}))},this.getInputDisplayString=t=>{const{values:e}=this.getStateKeysAndValuesForBoundary(t),{isInputFocused:s,inputString:n,selectedValue:a,hoverString:r}=e;return null!=r?r:s?null==n?"":n:null==a?"":this.doesEndBoundaryOverlapStartBoundary(a,t)?this.props.overlappingDatesMessage:getFormattedDateString(a,this.props)},this.getInputPlaceholderString=t=>{const e=t===Boundary.START,s=t===Boundary.END,n=this.getInputProps(t),{isInputFocused:a}=this.getStateKeysAndValuesForBoundary(t).values;return null!=n.placeholder?n.placeholder:e?a?this.state.formattedMinDateString:"Start date":s?a?this.state.formattedMaxDateString:"End date":""},this.getInputProps=t=>t===Boundary.START?this.props.startInputProps:this.props.endInputProps,this.getInputRef=t=>t===Boundary.START?this.handleStartInputRef:this.handleEndInputRef,this.getStateKeysAndValuesForBoundary=t=>{const e=this.props.value;return t===Boundary.START?{keys:{hoverString:"startHoverString",inputString:"startInputString",isInputFocused:"isStartInputFocused",selectedValue:"selectedStart"},values:{controlledValue:null!=e?e[0]:void 0,hoverString:this.state.startHoverString,inputString:this.state.startInputString,isInputFocused:this.state.isStartInputFocused,selectedValue:this.state.selectedStart}}:{keys:{hoverString:"endHoverString",inputString:"endInputString",isInputFocused:"isEndInputFocused",selectedValue:"selectedEnd"},values:{controlledValue:null!=e?e[1]:void 0,hoverString:this.state.endHoverString,inputString:this.state.endInputString,isInputFocused:this.state.isEndInputFocused,selectedValue:this.state.selectedEnd}}},this.getDateRangeForCallback=(t,e)=>{const s=this.getOtherBoundary(e),n=this.getStateKeysAndValuesForBoundary(s).values.selectedValue;return e===Boundary.START?[t,n]:[n,t]},this.getOtherBoundary=t=>t===Boundary.START?Boundary.END:Boundary.START,this.doBoundaryDatesOverlap=(t,e)=>{const{allowSingleDayRange:s}=this.props,n=this.getOtherBoundary(e),a=this.getStateKeysAndValuesForBoundary(n).values.selectedValue;return null!=t&&null!=a&&(e===Boundary.START?t>a||!s&&DayPicker.DateUtils.isSameDay(t,a):t<a||!s&&DayPicker.DateUtils.isSameDay(t,a))},this.doesEndBoundaryOverlapStartBoundary=(t,e)=>e!==Boundary.START&&this.doBoundaryDatesOverlap(t,e),this.isControlled=()=>void 0!==this.props.value,this.isInputEmpty=t=>null==t||0===t.length,this.isInputInErrorState=t=>{const e=this.getStateKeysAndValuesForBoundary(t).values,{isInputFocused:s,hoverString:n,inputString:a,selectedValue:r}=e;if(null!=n||this.isInputEmpty(a))return!1;const i=s?this.parseDate(a):r;return null!=i&&(!this.isDateValidAndInRange(i)||this.doesEndBoundaryOverlapStartBoundary(i,t))},this.isDateValidAndInRange=t=>isDateValid(t)&&isDayInRange(t,[this.props.minDate,this.props.maxDate]),this.reset(t)}reset(t=this.props){const[e,s]=this.getInitialRange();this.state={formattedMaxDateString:this.getFormattedMinMaxDateString(t,"maxDate"),formattedMinDateString:this.getFormattedMinMaxDateString(t,"minDate"),isOpen:!1,selectedEnd:s,selectedShortcutIndex:-1,selectedStart:e}}componentDidUpdate(t,e){super.componentDidUpdate(t,e);const{isStartInputFocused:s,isEndInputFocused:n,shouldSelectAfterUpdate:a}=this.state;t.startInputProps?.inputRef!==this.props.startInputProps?.inputRef&&(setRef(t.startInputProps?.inputRef,null),this.handleStartInputRef=refHandler(this,"startInputElement",this.props.startInputProps?.inputRef),setRef(this.props.startInputProps?.inputRef,this.startInputElement)),t.endInputProps?.inputRef!==this.props.endInputProps?.inputRef&&(setRef(t.endInputProps?.inputRef,null),this.handleEndInputRef=refHandler(this,"endInputElement",this.props.endInputProps?.inputRef),setRef(this.props.endInputProps?.inputRef,this.endInputElement));const r=this.shouldFocusInputRef(s,this.startInputElement),i=this.shouldFocusInputRef(n,this.endInputElement);r?this.startInputElement?.focus():i&&this.endInputElement?.focus(),s&&a?this.startInputElement?.select():n&&a&&this.endInputElement?.select();let o={};if(this.props.value!==t.value){const[t,e]=this.getInitialRange(this.props);o={...o,selectedStart:t,selectedEnd:e}}if(this.props.minDate!==t.minDate){const t=this.getFormattedMinMaxDateString(this.props,"minDate");o={...o,formattedMinDateString:t}}if(this.props.maxDate!==t.maxDate){const t=this.getFormattedMinMaxDateString(this.props,"maxDate");o={...o,formattedMaxDateString:t}}this.setState(o)}render(){const{selectedShortcutIndex:t}=this.state,{popoverProps:e={}}=this.props,s=React.createElement(DateRangePicker,Object.assign({},this.props,{selectedShortcutIndex:t,boundaryToModify:this.state.boundaryToModify,onChange:this.handleDateRangePickerChange,onShortcutChange:this.handleShortcutChange,onHoverChange:this.handleDateRangePickerHoverChange,value:this.getSelectedRange()})),n=classNames(e.className,this.props.className);return React.createElement(Popover,Object.assign({isOpen:this.state.isOpen,position:Position.BOTTOM_LEFT},this.props.popoverProps,{autoFocus:!1,className:n,content:s,enforceFocus:!1,onClose:this.handlePopoverClose}),React.createElement("div",{className:Classes.CONTROL_GROUP},this.renderInputGroup(Boundary.START),this.renderInputGroup(Boundary.END)))}validateProps(t){if(null===t.value)throw new Error(Errors.DATERANGEINPUT_NULL_VALUE)}shouldFocusInputRef(t,e){return t&&void 0!==e&&document.activeElement!==e}isNextDateRangeValid(t,e){return this.isDateValidAndInRange(t)&&!this.doBoundaryDatesOverlap(t,e)}getFormattedMinMaxDateString(t,e){const s=t[e],n=DateRangeInput_1.defaultProps[e];return getFormattedDateString(void 0===s?n:s,this.props)}parseDate(t){if(t===this.props.outOfRangeMessage||t===this.props.invalidDateMessage)return null;const{locale:e,parseDate:s}=this.props,n=s(t,e);return!1===n?new Date(void 0):n}formatDate(t){if(!this.isDateValidAndInRange(t))return"";const{locale:e,formatDate:s}=this.props;return s(t,e)}};DateRangeInput.defaultProps={allowSingleDayRange:!1,closeOnSelection:!0,contiguousCalendarMonths:!0,dayPickerProps:{},disabled:!1,endInputProps:{},invalidDateMessage:"Invalid date",maxDate:getDefaultMaxDate(),minDate:getDefaultMinDate(),outOfRangeMessage:"Out of range",overlappingDatesMessage:"Overlapping dates",popoverProps:{},selectAllOnFocus:!1,shortcuts:!0,singleMonthOnly:!1,startInputProps:{}},DateRangeInput.displayName=`${DISPLAYNAME_PREFIX}.DateRangeInput`,DateRangeInput=DateRangeInput_1=__decorate([polyfill],DateRangeInput);export{DateRangeInput};