import{requestIdleCallback}from"./requestIdleCallback";export class Batcher{constructor(){this.currentObjects={},this.oldObjects={},this.batchArgs={},this.done=!0,this.handleIdleCallback=()=>{const t=this.callback;delete this.callback,t?.()},this.mapCurrentObjectKey=t=>this.currentObjects[t]}reset(){this.batchArgs={},this.oldObjects=this.currentObjects,this.currentObjects={}}startNewBatch(){this.batchArgs={}}addArgsToBatch(...t){this.batchArgs[this.getKey(t)]=t}removeOldAddNew(t,e=Batcher.DEFAULT_ADD_LIMIT,s=Batcher.DEFAULT_REMOVE_LIMIT,c=Batcher.DEFAULT_UPDATE_LIMIT){this.setKeysDifference(this.currentObjects,this.batchArgs,s).forEach((t=>delete this.currentObjects[t])),this.setKeysDifference(this.oldObjects,this.batchArgs,-1).forEach((t=>delete this.oldObjects[t])),Object.keys(this.oldObjects).forEach((t=>{null==this.currentObjects[t]&&(this.currentObjects[t]=this.oldObjects[t])})),this.setKeysIntersection(this.oldObjects,this.currentObjects,c).forEach((e=>{delete this.oldObjects[e],this.currentObjects[e]=t.apply(void 0,this.batchArgs[e])})),this.setKeysDifference(this.batchArgs,this.currentObjects,e).forEach((e=>this.currentObjects[e]=t.apply(void 0,this.batchArgs[e]))),this.done=this.setHasSameKeys(this.batchArgs,this.currentObjects)&&0===Object.keys(this.oldObjects).length}isDone(){return this.done}getList(){return Object.keys(this.currentObjects).map(this.mapCurrentObjectKey)}idleCallback(t){this.callback||(this.callback=t,requestIdleCallback(this.handleIdleCallback))}cancelOutstandingCallback(){delete this.callback}setList(t,e){this.reset(),t.forEach(((t,s)=>{this.addArgsToBatch(...t),this.currentObjects[this.getKey(t)]=e[s]})),this.done=!0}getKey(t){return t.join(Batcher.ARG_DELIMITER)}setKeysDifference(t,e,s){return this.setKeysOperation(t,e,"difference",s)}setKeysIntersection(t,e,s){return this.setKeysOperation(t,e,"intersect",s)}setKeysOperation(t,e,s,c){const r=[],h=Object.keys(t);for(let i=0;i<h.length&&(c<0||r.length<c);i++){const c=h[i];("difference"===s&&t[c]&&!e[c]||"intersect"===s&&t[c]&&e[c])&&r.push(c)}return r}setHasSameKeys(t,e){const s=Object.keys(t),c=Object.keys(e);if(s.length!==c.length)return!1;for(const t of s)if(void 0===e[t])return!1;return!0}}Batcher.DEFAULT_ADD_LIMIT=20,Batcher.DEFAULT_UPDATE_LIMIT=20,Batcher.DEFAULT_REMOVE_LIMIT=20,Batcher.ARG_DELIMITER="|";